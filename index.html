<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Byte的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Byte的博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="One Byte">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/"/>





  <title>Byte的博客</title>
  








<meta name="generator" content="Hexo 7.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Byte的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/07/learnRust12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Byte的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/07/learnRust12/" itemprop="url">Rust入门-基础 第十二节 结构体</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-10-07T21:49:44+08:00">
                2024-10-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>结构体跟之前讲过的元组有些相像：都是由多种类型组合而成。但是与元组不同的是，结构体可以为内部的每个字段起一个富有含义的名称。因此结构体更加灵活更加强大，你无需依赖这些字段的顺序来访问和解析它们。</p>
<h1 id="1-结构体语法"><a href="#1-结构体语法" class="headerlink" title="1.结构体语法"></a>1.结构体语法</h1><h1 id="2-定义结构体"><a href="#2-定义结构体" class="headerlink" title="2 定义结构体"></a>2 定义结构体</h1><p>一个结构体由几部分组成：</p>
<ul>
<li>通过关键字 struct 定义</li>
<li>一个清晰明确的结构体 名称</li>
<li>几个有名字的结构体 字段</li>
</ul>
<p>例如, 以下结构体定义了某网站的用户：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct User &#123;</span><br><span class="line">    active: bool,</span><br><span class="line">    username: String,</span><br><span class="line">    email: String,</span><br><span class="line">    sign_in_count: u64,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该结构体名称是 User，拥有 4 个字段，且每个字段都有对应的字段名及类型声明，例如 username 代表了用户名，是一个可变的 String 类型。</p>
<h1 id="3-创建结构体实例"><a href="#3-创建结构体实例" class="headerlink" title="3 创建结构体实例"></a>3 创建结构体实例</h1><p>为了使用上述结构体，我们需要创建 User 结构体的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let user1 = User &#123;</span><br><span class="line">    email: String::from(&quot;someone@example.com&quot;),</span><br><span class="line">    username: String::from(&quot;someusername123&quot;),</span><br><span class="line">    active: true,</span><br><span class="line">    sign_in_count: 1,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有几点值得注意:</p>
<ol>
<li>初始化实例时，每个字段都需要进行初始化</li>
<li>初始化时的字段顺序不需要和结构体定义时的顺序一致</li>
</ol>
<h1 id="4-访问结构体字段"><a href="#4-访问结构体字段" class="headerlink" title="4 访问结构体字段"></a>4 访问结构体字段</h1><p>通过 . 操作符即可访问结构体实例内部的字段值，也可以修改它们：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let mut user1 = User &#123;</span><br><span class="line">    email: String::from(&quot;someone@example.com&quot;),</span><br><span class="line">    username: String::from(&quot;someusername123&quot;),</span><br><span class="line">    active: true,</span><br><span class="line">    sign_in_count: 1,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user1.email = String::from(&quot;anotheremail@example.com&quot;);</span><br></pre></td></tr></table></figure>
<p>需要注意的是，必须要将结构体实例声明为可变的，才能修改其中的字段，Rust 不支持将某个结构体某个字段标记为可变。</p>
<h1 id="5-简化结构体创建"><a href="#5-简化结构体创建" class="headerlink" title="5 简化结构体创建"></a>5 简化结构体创建</h1><p>下面的函数类似一个构建函数，返回了 User 结构体的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn build_user(email: String, username: String) -&gt; User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email: email,</span><br><span class="line">        username: username,</span><br><span class="line">        active: true,</span><br><span class="line">        sign_in_count: 1,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它接收两个字符串参数： email 和 username，然后使用它们来创建一个 User 结构体，并且返回。可以注意到这两行： email: email 和 username: username，非常的扎眼，因为实在有些啰嗦，如果你从 TypeScript 过来，肯定会鄙视 Rust 一番，不过好在，它也不是无可救药：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn build_user(email: String, username: String) -&gt; User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email,</span><br><span class="line">        username,</span><br><span class="line">        active: true,</span><br><span class="line">        sign_in_count: 1,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，当函数参数和结构体字段同名时，可以直接使用缩略的方式进行初始化，跟 TypeScript 中一模一样。</p>
<h1 id="6-结构体更新语法"><a href="#6-结构体更新语法" class="headerlink" title="6 结构体更新语法"></a>6 结构体更新语法</h1><p>在实际场景中，有一种情况很常见：根据已有的结构体实例，创建新的结构体实例，例如根据已有的 user1 实例来构建 user2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let user2 = User &#123;</span><br><span class="line">      active: user1.active,</span><br><span class="line">      username: user1.username,</span><br><span class="line">      email: String::from(&quot;another@example.com&quot;),</span><br><span class="line">      sign_in_count: user1.sign_in_count,</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>老话重提，如果你从 TypeScript 过来，肯定觉得啰嗦爆了：竟然手动把 user1 的三个字段逐个赋值给 user2，好在 Rust 为我们提供了 结构体更新语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let user2 = User &#123;</span><br><span class="line">      email: String::from(&quot;another@example.com&quot;),</span><br><span class="line">      ..user1</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>因为 user2 仅仅在 email 上与 user1 不同，因此我们只需要对 email 进行赋值，剩下的通过结构体更新语法 ..user1 即可完成。</p>
<p>.. 语法表明凡是我们没有显式声明的字段，全部从 user1 中自动获取。需要注意的是 ..user1 必须在结构体的尾部使用。</p>
<table>
    <td bgcolor=#F0F8FF>
        结构体更新语法跟赋值语句 = 非常相像，因此在上面代码中，user1 的部分字段所有权被转移到 user2 中：username 字段发生了所有权转移，作为结果，user1 无法再被使用。

<pre><code>    聪明的读者肯定要发问了：明明有三个字段进行了自动赋值，为何只有 username 发生了所有权转移？

    仔细回想一下所有权那一节的内容，我们提到了 Copy 特征：实现了 Copy 特征的类型无需所有权转移，可以直接在赋值时进行 数据拷贝，其中 bool 和 u64 类型就实现了 Copy 特征，因此 active 和 sign_in_count 字段在赋值给 user2 时，仅仅发生了拷贝，而不是所有权转移。

    值得注意的是：username 所有权被转移给了 user2，导致了 user1 无法再被使用，但是并不代表 user1 内部的其它字段不能被继续使用，例如：
&lt;/td&gt;
</code></pre>
</table>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let user1 = User &#123;</span><br><span class="line">    email: String::from(&quot;someone@example.com&quot;),</span><br><span class="line">    username: String::from(&quot;someusername123&quot;),</span><br><span class="line">    active: true,</span><br><span class="line">    sign_in_count: 1,</span><br><span class="line">&#125;;</span><br><span class="line">let user2 = User &#123;</span><br><span class="line">    active: user1.active,</span><br><span class="line">    username: user1.username,</span><br><span class="line">    email: String::from(&quot;another@example.com&quot;),</span><br><span class="line">    sign_in_count: user1.sign_in_count,</span><br><span class="line">&#125;;</span><br><span class="line">println!(&quot;&#123;&#125;&quot;, user1.active);</span><br><span class="line">// 下面这行会报错</span><br><span class="line">println!(&quot;&#123;:?&#125;&quot;, user1);</span><br></pre></td></tr></table></figure>

<h1 id="7-结构体的内存排列"><a href="#7-结构体的内存排列" class="headerlink" title="7 结构体的内存排列"></a>7 结构体的内存排列</h1><p>先来看以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#[derive(Debug)]</span><br><span class="line"> struct File &#123;</span><br><span class="line">   name: String,</span><br><span class="line">   data: Vec&lt;u8&gt;,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> fn main() &#123;</span><br><span class="line">   let f1 = File &#123;</span><br><span class="line">     name: String::from(&quot;f1.txt&quot;),</span><br><span class="line">     data: Vec::new(),</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   let f1_name = &amp;f1.name;</span><br><span class="line">   let f1_length = &amp;f1.data.len();</span><br><span class="line"></span><br><span class="line">   println!(&quot;&#123;:?&#125;&quot;, f1);</span><br><span class="line">   println!(&quot;&#123;&#125; is &#123;&#125; bytes long&quot;, f1_name, f1_length);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>上面定义的 File 结构体在内存中的排列如下图所示：<br><img src="/../images/struct-mem.png"><br>从图中可以清晰地看出 File 结构体两个字段 name 和 data 分别拥有底层两个 [u8] 数组的所有权(String 类型的底层也是 [u8] 数组)，通过 ptr 指针指向底层数组的内存地址，这里你可以把 ptr 指针理解为 Rust 中的引用类型。</p>
<p>该图片也侧面印证了：<em>把结构体中具有所有权的字段转移出去后，将无法再访问该字段，但是可以正常访问其它的字段。</em></p>
<h1 id="8-元组结构体-Tuple-Struct"><a href="#8-元组结构体-Tuple-Struct" class="headerlink" title="8 元组结构体(Tuple Struct)"></a>8 元组结构体(Tuple Struct)</h1><p>结构体必须要有名称，但是结构体的字段可以没有名称，这种结构体长得很像元组，因此被称为元组结构体，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Color(i32, i32, i32);</span><br><span class="line">struct Point(i32, i32, i32);</span><br><span class="line"></span><br><span class="line">let black = Color(0, 0, 0);</span><br><span class="line">let origin = Point(0, 0, 0);</span><br></pre></td></tr></table></figure>
<p>元组结构体在你希望有一个整体名称，但是又不关心里面字段的名称时将非常有用。例如上面的 Point 元组结构体，众所周知 3D 点是 (x, y, z) 形式的坐标点，因此我们无需再为内部的字段逐一命名为：x, y, z。</p>
<h1 id="9-单元结构体-Unit-like-Struct"><a href="#9-单元结构体-Unit-like-Struct" class="headerlink" title="9 单元结构体(Unit-like Struct)"></a>9 单元结构体(Unit-like Struct)</h1><p>还记得之前讲过的基本没啥用的单元类型吧？单元结构体就跟它很像，没有任何字段和属性，但是好在，它还挺有用。</p>
<p>如果你定义一个类型，但是不关心该类型的内容, 只关心它的行为时，就可以使用 单元结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct AlwaysEqual;</span><br><span class="line"></span><br><span class="line">let subject = AlwaysEqual;</span><br><span class="line"></span><br><span class="line">// 我们不关心 AlwaysEqual 的字段数据，只关心它的行为，因此将它声明为单元结构体，然后再为它实现某个特征</span><br><span class="line">impl SomeTrait for AlwaysEqual &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="10-结构体数据的所有权"><a href="#10-结构体数据的所有权" class="headerlink" title="10 结构体数据的所有权"></a>10 结构体数据的所有权</h1><p>在之前的 User 结构体的定义中，有一处细节：我们使用了自身拥有所有权的 String 类型而不是基于引用的 &amp;str 字符串切片类型。这是一个有意而为之的选择：因为我们想要这个结构体拥有它所有的数据，而不是从其它地方借用数据。</p>
<p>你也可以让 User 结构体从其它对象借用数据，不过这么做，就需要引入生命周期(lifetimes)这个新概念（也是一个复杂的概念），简而言之，生命周期能确保结构体的作用范围要比它所借用的数据的作用范围要小。</p>
<p>总之，如果你想在结构体中使用一个引用，就必须加上生命周期，否则就会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct User &#123;</span><br><span class="line">    username: &amp;str,</span><br><span class="line">    email: &amp;str,</span><br><span class="line">    sign_in_count: u64,</span><br><span class="line">    active: bool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let user1 = User &#123;</span><br><span class="line">        email: &quot;someone@example.com&quot;,</span><br><span class="line">        username: &quot;someusername123&quot;,</span><br><span class="line">        active: true,</span><br><span class="line">        sign_in_count: 1,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器会抱怨它需要生命周期标识符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> --&gt; src/main.rs:2:15</span><br><span class="line">  |</span><br><span class="line">2 |     username: &amp;str,</span><br><span class="line">  |               ^ expected named lifetime parameter // 需要一个生命周期</span><br><span class="line">  |</span><br><span class="line">help: consider introducing a named lifetime parameter // 考虑像下面的代码这样引入一个生命周期</span><br><span class="line">  |</span><br><span class="line">1 ~ struct User&lt;&#x27;a&gt; &#123;</span><br><span class="line">2 ~     username: &amp;&#x27;a str,</span><br><span class="line">  |</span><br><span class="line"></span><br><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> --&gt; src/main.rs:3:12</span><br><span class="line">  |</span><br><span class="line">3 |     email: &amp;str,</span><br><span class="line">  |            ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">help: consider introducing a named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">1 ~ struct User&lt;&#x27;a&gt; &#123;</span><br><span class="line">2 |     username: &amp;str,</span><br><span class="line">3 ~     email: &amp;&#x27;a str,</span><br><span class="line">  |</span><br></pre></td></tr></table></figure>
<p>未来在生命周期中会讲到如何修复这个问题以便在结构体中存储引用，不过在那之前，我们会避免在结构体中使用引用类型。</p>
<h1 id="11-使用-derive-Debug-来打印结构体的信息"><a href="#11-使用-derive-Debug-来打印结构体的信息" class="headerlink" title="11 使用 #[derive(Debug)] 来打印结构体的信息"></a>11 使用 #[derive(Debug)] 来打印结构体的信息</h1><p>在前面的代码中我们使用 #[derive(Debug)] 对结构体进行了标记，这样才能使用 println!(“{:?}”, s); 的方式对其进行打印输出，如果不加，看看会发生什么:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct Rectangle &#123;</span><br><span class="line">    width: u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let rect1 = Rectangle &#123;</span><br><span class="line">        width: 30,</span><br><span class="line">        height: 50,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;rect1 is &#123;&#125;&quot;, rect1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先可以观察到，上面使用了 {} 而不是之前的 {:?}，运行后报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: `Rectangle` doesn&#x27;t implement `std::fmt::Display`</span><br></pre></td></tr></table></figure>
<p>提示我们结构体 Rectangle 没有实现 Display 特征，这是因为如果我们使用 {} 来格式化输出，那对应的类型就必须实现 Display 特征，以前学习的基本类型，都默认实现了该特征:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let v = 1;</span><br><span class="line">    let b = true;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;, &#123;&#125;&quot;, v, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码不会报错，那么结构体为什么不默认实现 Display 特征呢？原因在于结构体较为复杂，例如考虑以下问题：你想要逗号对字段进行分割吗？需要括号吗？加在什么地方？所有的字段都应该显示？类似的还有很多，由于这种复杂性，Rust 不希望猜测我们想要的是什么，而是把选择权交给我们自己来实现：如果要用 {} 的方式打印结构体，那就自己实现 Display 特征。</p>
<p>接下来继续阅读报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">= help: the trait `std::fmt::Display` is not implemented for `Rectangle`</span><br><span class="line">= note: in format strings you may be able to use `&#123;:?&#125;` (or &#123;:#?&#125; for pretty-print) instead</span><br></pre></td></tr></table></figure>
<p>上面提示我们使用 {:?} 来试试，这个方式我们在本文的前面也见过，下面来试试:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println!(&quot;rect1 is &#123;:?&#125;&quot;, rect1);</span><br></pre></td></tr></table></figure>
<p>可是依然无情报错了:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: `Rectangle` doesn&#x27;t implement `Debug`</span><br></pre></td></tr></table></figure>
<p>好在，聪明的编译器又一次给出了提示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">= help: the trait `Debug` is not implemented for `Rectangle`</span><br><span class="line">= note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`</span><br></pre></td></tr></table></figure>
<p>让我们实现 Debug 特征，Oh No，就是不想实现 Display 特征，才用的 {:?}，怎么又要实现 Debug，但是仔细看，提示中有一行： add #[derive(Debug)] to Rectangle， 哦？这不就是我们前文一直在使用的吗？</p>
<p>首先，Rust 默认不会为我们实现 Debug，为了实现，有两种方式可以选择：</p>
<ul>
<li>手动实现</li>
<li>使用 derive 派生实现</li>
</ul>
<p>后者简单的多，但是也有限制，具体见附录 D，这里我们就不再深入讲解，来看看该如何使用:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#[derive(Debug)]</span><br><span class="line">struct Rectangle &#123;</span><br><span class="line">    width: u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let rect1 = Rectangle &#123;</span><br><span class="line">        width: 30,</span><br><span class="line">        height: 50,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;rect1 is &#123;:?&#125;&quot;, rect1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时运行程序，就不再有错误，输出如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">rect1 is Rectangle &#123; width: 30, height: 50 &#125;</span><br></pre></td></tr></table></figure>
<p>这个输出格式看上去也不赖嘛，虽然未必是最好的。这种格式是 Rust 自动为我们提供的实现，看上基本就跟结构体的定义形式一样。</p>
<p>当结构体较大时，我们可能希望能够有更好的输出表现，此时可以使用 {:#?} 来替代 {:?}，输出如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rect1 is Rectangle &#123;</span><br><span class="line">    width: 30,</span><br><span class="line">    height: 50,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时结构体的输出跟我们创建时候的代码几乎一模一样了</p>
<p>还有一个简单的输出 debug 信息的方法，那就是使用 dbg! 宏，它会拿走表达式的所有权，然后打印出相应的文件名、行号等 debug 信息，当然还有我们需要的表达式的求值结果。除此之外，它最终还会把表达式值的所有权返回！</p>
<table>
    <td bgcolor=#F0F8FF>
        dbg! 输出到标准错误输出 stderr，而 println! 输出到标准输出 stdout。
    </td>
</table>

<p>下面的例子中清晰的展示了 dbg! 如何在打印出信息的同时，还把表达式的值赋给了 width:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#[derive(Debug)]</span><br><span class="line">struct Rectangle &#123;</span><br><span class="line">    width: u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let scale = 2;</span><br><span class="line">    let rect1 = Rectangle &#123;</span><br><span class="line">        width: dbg!(30 * scale),</span><br><span class="line">        height: 50,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    dbg!(&amp;rect1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的 debug 输出如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">[src/main.rs:10] 30 * scale = 60</span><br><span class="line">[src/main.rs:14] &amp;rect1 = Rectangle &#123;</span><br><span class="line">    width: 60,</span><br><span class="line">    height: 50,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，我们想要的 debug 信息几乎都有了：代码所在的文件名、行号、表达式以及表达式的值，简直完美！</p>
<h1 id="12-方法"><a href="#12-方法" class="headerlink" title="12 方法"></a>12 方法</h1><h2 id="12-1-定义方法"><a href="#12-1-定义方法" class="headerlink" title="12.1 定义方法"></a>12.1 定义方法</h2><p>Rust 使用 impl 来定义方法，例如以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct Circle &#123;</span><br><span class="line">    x: f64,</span><br><span class="line">    y: f64,</span><br><span class="line">    radius: f64,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Circle &#123;</span><br><span class="line">    // new是Circle的关联函数，因为它的第一个参数不是self，且new并不是关键字</span><br><span class="line">    // 这种方法往往用于初始化当前结构体的实例</span><br><span class="line">    fn new(x: f64, y: f64, radius: f64) -&gt; Circle &#123;</span><br><span class="line">        Circle &#123;</span><br><span class="line">            x: x,</span><br><span class="line">            y: y,</span><br><span class="line">            radius: radius,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Circle的方法，&amp;self表示借用当前的Circle结构体</span><br><span class="line">    fn area(&amp;self) -&gt; f64 &#123;</span><br><span class="line">        std::f64::consts::PI * (self.radius * self.radius)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们这里先不详细展开讲解，只是先建立对方法定义的大致印象。下面的图片将 Rust 方法定义与其它语言的方法定义做了对比：<br><img src="/../images/method-mem.png"><br>可以看出，其它语言中所有定义都在 class 中，但是 Rust 的对象定义和方法定义是分离的，这种数据和使用分离的方式，会给予使用者极高的灵活度。</p>
<p>再来看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#[derive(Debug)]</span><br><span class="line">struct Rectangle &#123;</span><br><span class="line">    width: u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Rectangle &#123;</span><br><span class="line">    fn area(&amp;self) -&gt; u32 &#123;</span><br><span class="line">        self.width * self.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let rect1 = Rectangle &#123; width: 30, height: 50 &#125;;</span><br><span class="line"></span><br><span class="line">    println!(</span><br><span class="line">        &quot;The area of the rectangle is &#123;&#125; square pixels.&quot;,</span><br><span class="line">        rect1.area()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该例子定义了一个 Rectangle 结构体，并且在其上定义了一个 area 方法，用于计算该矩形的面积。</p>
<p>impl Rectangle {} 表示为 Rectangle 实现方法(impl 是实现 implementation 的缩写)，这样的写法表明 impl 语句块中的一切都是跟 Rectangle 相关联的。</p>
<h1 id="12-2-self、-self-和-mut-self"><a href="#12-2-self、-self-和-mut-self" class="headerlink" title="12.2 self、&amp;self 和 &amp;mut self"></a>12.2 self、&amp;self 和 &amp;mut self</h1><p>接下来的内容非常重要，请大家仔细看。在 area 的签名中，我们使用 &amp;self 替代 rectangle: &amp;Rectangle，&amp;self 其实是 self: &amp;Self 的简写（注意大小写）。在一个 impl 块内，Self 指代被实现方法的结构体类型，self 指代此类型的实例，换句话说，self 指代的是 Rectangle 结构体实例，这样的写法会让我们的代码简洁很多，而且非常便于理解：我们为哪个结构体实现方法，那么 self 就是指代哪个结构体的实例。</p>
<p>需要注意的是，self 依然有所有权的概念：</p>
<ul>
<li>self 表示 Rectangle 的所有权转移到该方法中，这种形式用的较少</li>
<li>&amp;self 表示该方法对 Rectangle 的不可变借用</li>
<li>&amp;mut self 表示可变借用<br>总之，self 的使用就跟函数参数一样，要严格遵守 Rust 的所有权规则。</li>
</ul>
<p>回到上面的例子中，选择 &amp;self 的理由跟在函数中使用 &amp;Rectangle 是相同的：我们并不想获取所有权，也无需去改变它，只是希望能够读取结构体中的数据。如果想要在方法中去改变当前的结构体，需要将第一个参数改为 &amp;mut self。仅仅通过使用 self 作为第一个参数来使方法获取实例的所有权是很少见的，这种使用方式往往用于把当前的对象转成另外一个对象时使用，转换完后，就不再关注之前的对象，且可以防止对之前对象的误调用。</p>
<p>简单总结下，使用方法代替函数有以下好处：</p>
<ul>
<li>不用在函数签名中重复书写 self 对应的类型</li>
<li>代码的组织性和内聚性更强，对于代码维护和阅读来说，好处巨大</li>
</ul>
<h1 id="12-3-方法名跟结构体字段名相同"><a href="#12-3-方法名跟结构体字段名相同" class="headerlink" title="12.3 方法名跟结构体字段名相同"></a>12.3 方法名跟结构体字段名相同</h1><p>在 Rust 中，允许方法名跟结构体的字段名相同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">impl Rectangle &#123;</span><br><span class="line">    fn width(&amp;self) -&gt; bool &#123;</span><br><span class="line">        self.width &gt; 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let rect1 = Rectangle &#123;</span><br><span class="line">        width: 30,</span><br><span class="line">        height: 50,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    if rect1.width() &#123;</span><br><span class="line">        println!(&quot;The rectangle has a nonzero width; it is &#123;&#125;&quot;, rect1.width);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们使用 rect1.width() 时，Rust 知道我们调用的是它的方法，如果使用 rect1.width，则是访问它的字段。</p>
<p>一般来说，方法跟字段同名，往往适用于实现 getter 访问器，例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pub struct Rectangle &#123;</span><br><span class="line">    width: u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Rectangle &#123;</span><br><span class="line">    pub fn new(width: u32, height: u32) -&gt; Self &#123;</span><br><span class="line">        Rectangle &#123; width, height &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pub fn width(&amp;self) -&gt; u32 &#123;</span><br><span class="line">        return self.width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let rect1 = Rectangle::new(30, 50);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, rect1.width());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用这种方式，我们可以把 Rectangle 的字段设置为私有属性，只需把它的 new 和 width 方法设置为公开可见，那么用户就可以创建一个矩形，同时通过访问器 rect1.width() 方法来获取矩形的宽度，因为 width 字段是私有的，当用户访问 rect1.width 字段时，就会报错。注意在此例中，Self 指代的就是被实现方法的结构体 Rectangle。</p>
<table>
    <td bgcolor=#F0F8FF>
        -> 运算符到哪去了？
        在 C/C++ 语言中，有两个不同的运算符来调用方法：. 直接在对象上调用方法，而 -> 在一个对象的指针上调用方法，这时需要先解引用指针。换句话说，如果 object 是一个指针，那么 object->something() 和 (*object).something() 是一样的。

<pre><code>    Rust 并没有一个与 -&gt; 等效的运算符；相反，Rust 有一个叫 自动引用和解引用的功能。方法调用是 Rust 中少数几个拥有这种行为的地方。

    他是这样工作的：当使用 object.something() 调用方法时，Rust 会自动为 object 添加 &amp;、&amp;mut 或 * 以便使 object 与方法签名匹配。也就是说，这些代码是等价的：

    p1.distance(&amp;p2);
    (&amp;p1).distance(&amp;p2);
    第一行看起来简洁的多。这种自动引用的行为之所以有效，是因为方法有一个明确的接收者———— self 的类型。在给出接收者和方法名的前提下，Rust 可以明确地计算出方法是仅仅读取（&amp;self），做出修改（&amp;mut self）或者是获取所有权（self）。事实上，Rust 对方法接收者的隐式借用让所有权在实践中更友好。
&lt;/td&gt;
</code></pre>
</table>

<h1 id="12-4-带有多个参数的方法"><a href="#12-4-带有多个参数的方法" class="headerlink" title="12.4 带有多个参数的方法"></a>12.4 带有多个参数的方法</h1><p>方法和函数一样，可以使用多个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">impl Rectangle &#123;</span><br><span class="line">    fn area(&amp;self) -&gt; u32 &#123;</span><br><span class="line">        self.width * self.height</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool &#123;</span><br><span class="line">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let rect1 = Rectangle &#123; width: 30, height: 50 &#125;;</span><br><span class="line">    let rect2 = Rectangle &#123; width: 10, height: 40 &#125;;</span><br><span class="line">    let rect3 = Rectangle &#123; width: 60, height: 45 &#125;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;Can rect1 hold rect2? &#123;&#125;&quot;, rect1.can_hold(&amp;rect2));</span><br><span class="line">    println!(&quot;Can rect1 hold rect3? &#123;&#125;&quot;, rect1.can_hold(&amp;rect3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="12-5-关联函数"><a href="#12-5-关联函数" class="headerlink" title="12.5 关联函数"></a>12.5 关联函数</h1><p>现在大家可以思考一个问题，如何为一个结构体定义一个构造器方法？也就是接受几个参数，然后构造并返回该结构体的实例。其实答案在开头的代码片段中就给出了，很简单，参数中不包含 self 即可。</p>
<p>这种定义在 impl 中且没有 self 的函数被称之为关联函数： 因为它没有 self，不能用 f.read() 的形式调用，因此它是一个函数而不是方法，它又在 impl 中，与结构体紧密关联，因此称为关联函数。</p>
<p>在之前的代码中，我们已经多次使用过关联函数，例如 String::from，用于创建一个动态字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">impl Rectangle &#123;</span><br><span class="line">    fn new(w: u32, h: u32) -&gt; Rectangle &#123;</span><br><span class="line">        Rectangle &#123; width: w, height: h &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
    <td bgcolor=#F0F8FF>
        Rust 中有一个约定俗成的规则，使用 new 来作为构造器的名称，出于设计上的考虑，Rust 特地没有用 new 作为关键字。
    </td>
</table>
因为是函数，所以不能用 . 的方式来调用，我们需要用 :: 来调用，例如 let sq = Rectangle::new(3, 3);。这个方法位于结构体的命名空间中：:: 语法用于关联函数和模块创建的命名空间。

<h1 id="12-6-多个-impl-定义"><a href="#12-6-多个-impl-定义" class="headerlink" title="12.6 多个 impl 定义"></a>12.6 多个 impl 定义</h1><p>Rust 允许我们为一个结构体定义多个 impl 块，目的是提供更多的灵活性和代码组织性，例如当方法多了后，可以把相关的方法组织在同一个 impl 块中，那么就可以形成多个 impl 块，各自完成一块儿目标：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">impl Rectangle &#123;</span><br><span class="line">    fn area(&amp;self) -&gt; u32 &#123;</span><br><span class="line">        self.width * self.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Rectangle &#123;</span><br><span class="line">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool &#123;</span><br><span class="line">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，就这个例子而言，我们没必要使用两个 impl 块，这里只是为了演示方便。</p>
<h1 id="12-7-为枚举实现方法"><a href="#12-7-为枚举实现方法" class="headerlink" title="12.7 为枚举实现方法"></a>12.7 为枚举实现方法</h1><p>枚举类型之所以强大，不仅仅在于它好用、可以同一化类型，还在于，我们可以像结构体一样，为枚举实现方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#![allow(unused)]</span><br><span class="line">enum Message &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: i32, y: i32 &#125;,</span><br><span class="line">    Write(String),</span><br><span class="line">    ChangeColor(i32, i32, i32),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Message &#123;</span><br><span class="line">    fn call(&amp;self) &#123;</span><br><span class="line">        // 在这里定义方法体</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let m = Message::Write(String::from(&quot;hello&quot;));</span><br><span class="line">    m.call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/06/learnRust11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Byte的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/06/learnRust11/" itemprop="url">Rust入门-基础 第十一节 枚举Enum</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-10-06T23:08:00+08:00">
                2024-10-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-1-枚举-enum-或-enumeration-允许你通过列举可能的成员来定义一个枚举类型，例如扑克牌花色："><a href="#1-1-枚举-enum-或-enumeration-允许你通过列举可能的成员来定义一个枚举类型，例如扑克牌花色：" class="headerlink" title="1.1 枚举(enum 或 enumeration)允许你通过列举可能的成员来定义一个枚举类型，例如扑克牌花色："></a>1.1 枚举(enum 或 enumeration)允许你通过列举可能的成员来定义一个枚举类型，例如扑克牌花色：</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum PokerSuit &#123;</span><br><span class="line">  Clubs,</span><br><span class="line">  Spades,</span><br><span class="line">  Diamonds,</span><br><span class="line">  Hearts,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在此之前你没有在其它语言中使用过枚举，那么可能需要花费一些时间来理解这些概念，一旦上手，就会发现枚举的强大，甚至对它爱不释手，枚举虽好，可不要滥用哦。</p>
<p>再回到之前创建的 PokerSuit，扑克总共有四种花色，而这里我们枚举出所有的可能值，这也正是 枚举 名称的由来。</p>
<p>任何一张扑克，它的花色肯定会落在四种花色中，而且也只会落在其中一个花色上，这种特性非常适合枚举的使用，因为枚举值只可能是其中某一个成员。抽象来看，四种花色尽管是不同的花色，但是它们都是扑克花色这个概念，因此当某个函数处理扑克花色时，可以把它们当作相同的类型进行传参。</p>
<p>细心的读者应该注意到，我们对之前的 枚举类型 和 枚举值 进行了重点标注，这是因为对于新人来说容易混淆相应的概念，总而言之：<strong>枚举类型是一个类型，它会包含所有可能的枚举成员, 而枚举值是该类型中的具体某个成员的实例。</strong> </p>
<h2 id="1-2-枚举值"><a href="#1-2-枚举值" class="headerlink" title="1.2 枚举值"></a>1.2 枚举值</h2><p>现在来创建 PokerSuit 枚举类型的两个成员实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let heart = PokerSuit::Hearts;</span><br><span class="line">let diamond = PokerSuit::Diamonds;</span><br></pre></td></tr></table></figure>
<p>我们通过 :: 操作符来访问 PokerSuit 下的具体成员，从代码可以清晰看出，heart 和 diamond 都是 PokerSuit 枚举类型的，接着可以定义一个函数来使用它们：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#[derive(Debug)]</span><br><span class="line">enum PokerSuit &#123;</span><br><span class="line">    Clubs,</span><br><span class="line">    Spades,</span><br><span class="line">    Diamonds,</span><br><span class="line">    Hearts,</span><br><span class="line">  &#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let heart = PokerSuit::Hearts;</span><br><span class="line">    let diamond = PokerSuit::Diamonds;</span><br><span class="line"></span><br><span class="line">    print_suit(heart);</span><br><span class="line">    print_suit(diamond);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn print_suit(card: PokerSuit) &#123;</span><br><span class="line">    </span><br><span class="line">    // 需要在定义 enum PokerSuit 的上面添加上 #[derive(Debug)]，否则会报 card 没有实现 Debug</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;,card);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>print_suit 函数的参数类型是 PokerSuit，因此我们可以把 heart 和 diamond 传给它，虽然 heart 是基于 PokerSuit 下的 Hearts 成员实例化的，但是它是货真价实的 PokerSuit 枚举类型。</p>
<p>接下来，我们想让扑克牌变得更加实用，那么需要给每张牌赋予一个值：A(1)-K(13)，这样再加上花色，就是一张真实的扑克牌了，例如红心 A。</p>
<p>目前来说，枚举值还不能带有值，因此先用结构体来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">enum PokerSuit &#123;</span><br><span class="line">    Clubs,</span><br><span class="line">    Spades,</span><br><span class="line">    Diamonds,</span><br><span class="line">    Hearts,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct PokerCard &#123;</span><br><span class="line">    suit: PokerSuit,</span><br><span class="line">    value: u8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">   let c1 = PokerCard &#123;</span><br><span class="line">       suit: PokerSuit::Clubs,</span><br><span class="line">       value: 1,</span><br><span class="line">   &#125;;</span><br><span class="line">   let c2 = PokerCard &#123;</span><br><span class="line">       suit: PokerSuit::Diamonds,</span><br><span class="line">       value: 12,</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码很好的完成了它的使命，通过结构体 PokerCard 来代表一张牌，结构体的 suit 字段表示牌的花色，类型是 PokerSuit 枚举类型，value 字段代表扑克牌的数值。</p>
<p>可以吗？可以！好吗？说实话，不咋地，因为还有简洁得多的方式来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum PokerCard &#123;</span><br><span class="line">    Clubs(u8),</span><br><span class="line">    Spades(u8),</span><br><span class="line">    Diamonds(u8),</span><br><span class="line">    Hearts(u8),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">   let c1 = PokerCard::Spades(5);</span><br><span class="line">   let c2 = PokerCard::Diamonds(13);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接将数据信息关联到枚举成员上，省去近一半的代码，这种实现是不是更优雅？</p>
<p>不仅如此，同一个枚举类型下的不同成员还能持有不同的数据类型，例如让某些花色打印 1-13 的字样，另外的花色打印上 A-K 的字样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum PokerCard &#123;</span><br><span class="line">    Clubs(u8),</span><br><span class="line">    Spades(u8),</span><br><span class="line">    Diamonds(char),</span><br><span class="line">    Hearts(char),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">   let c1 = PokerCard::Spades(5);</span><br><span class="line">   let c2 = PokerCard::Diamonds(&#x27;A&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回想一下，遇到这种不同类型的情况，再用我们之前的结构体实现方式，可行吗？也许可行，但是会复杂很多。</p>
<p>再来看一个来自标准库中的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct Ipv4Addr &#123;</span><br><span class="line">    // --snip--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Ipv6Addr &#123;</span><br><span class="line">    // --snip--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum IpAddr &#123;</span><br><span class="line">    V4(Ipv4Addr),</span><br><span class="line">    V6(Ipv6Addr),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子跟我们之前的扑克牌很像，只不过枚举成员包含的类型更复杂了，变成了结构体：分别通过 Ipv4Addr 和 Ipv6Addr 来定义两种不同的 IP 数据。</p>
<p>从这些例子可以看出，任何类型的数据都可以放入枚举成员中: 例如字符串、数值、结构体甚至另一个枚举。</p>
<p>增加一些挑战？先看以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enum Message &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: i32, y: i32 &#125;,</span><br><span class="line">    Write(String),</span><br><span class="line">    ChangeColor(i32, i32, i32),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let m1 = Message::Quit;</span><br><span class="line">    let m2 = Message::Move&#123;x:1,y:1&#125;;</span><br><span class="line">    let m3 = Message::ChangeColor(255,255,0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该枚举类型代表一条消息，它包含四个不同的成员：</p>
<ul>
<li>Quit 没有任何关联数据</li>
<li>Move 包含一个匿名结构体</li>
<li>Write 包含一个 String 字符串</li>
<li>ChangeColor 包含三个 i32</li>
</ul>
<p>当然，我们也可以用结构体的方式来定义这些消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct QuitMessage; // 单元结构体</span><br><span class="line">struct MoveMessage &#123;</span><br><span class="line">    x: i32,</span><br><span class="line">    y: i32,</span><br><span class="line">&#125;</span><br><span class="line">struct WriteMessage(String); // 元组结构体</span><br><span class="line">struct ChangeColorMessage(i32, i32, i32); // 元组结构体</span><br></pre></td></tr></table></figure>
<p>由于每个结构体都有自己的类型，因此我们无法在需要同一类型的地方进行使用，例如某个函数它的功能是接受消息并进行发送，那么用枚举的方式，就可以接收不同的消息，但是用结构体，该函数无法接受 4 个不同的结构体作为参数。</p>
<p>而且从代码规范角度来看，枚举的实现更简洁，代码内聚性更强，不像结构体的实现，分散在各个地方。</p>
<h2 id="1-3在-Rust-中，field-less-enum-和-unit-only-enum-是常见的枚举类型，虽然二者有些相似，但它们的用途和语义略有不同。"><a href="#1-3在-Rust-中，field-less-enum-和-unit-only-enum-是常见的枚举类型，虽然二者有些相似，但它们的用途和语义略有不同。" class="headerlink" title="1.3在 Rust 中，field-less enum 和 unit-only enum 是常见的枚举类型，虽然二者有些相似，但它们的用途和语义略有不同。"></a>1.3在 Rust 中，field-less enum 和 unit-only enum 是常见的枚举类型，虽然二者有些相似，但它们的用途和语义略有不同。</h2><h3 id="1-3-1-Field-less-Enum（无字段枚举）"><a href="#1-3-1-Field-less-Enum（无字段枚举）" class="headerlink" title="1.3.1 Field-less Enum（无字段枚举）"></a>1.3.1 Field-less Enum（无字段枚举）</h3><p>Field-less Enum 是指那些变体没有任何附加数据的枚举。每个变体只是简单的标签，用于表示某种状态或选项。这种枚举可以用于状态管理或一组固定的常量选项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">    North,</span><br><span class="line">    South,</span><br><span class="line">    East,</span><br><span class="line">    West,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个 Direction 枚举中，四个方向 North、South、East 和 West 都没有附加字段，这就是 field-less enum。你可以通过枚举的名字引用不同的变体，它们本身就是唯一的常量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn get_direction(direction: Direction) &#123;</span><br><span class="line">    match direction &#123;</span><br><span class="line">        Direction::North =&gt; println!(&quot;Heading North!&quot;),</span><br><span class="line">        Direction::South =&gt; println!(&quot;Heading South!&quot;),</span><br><span class="line">        Direction::East =&gt; println!(&quot;Heading East!&quot;),</span><br><span class="line">        Direction::West =&gt; println!(&quot;Heading West!&quot;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let direction = Direction::North;</span><br><span class="line">    get_direction(direction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-2-Unit-only-Enum（单元枚举）"><a href="#1-3-2-Unit-only-Enum（单元枚举）" class="headerlink" title="1.3.2 Unit-only Enum（单元枚举）"></a>1.3.2 Unit-only Enum（单元枚举）</h3><p>Unit-only Enum 是 field-less enum 的一个子集，所有的枚举变体都是单位类型（unit type）。也就是说，每个变体都是没有任何状态和数据的唯一值。</p>
<p>在 Rust 中，unit-only enum 与 field-less enum 的区别在于：当所有变体都是单位类型时，枚举可以看作是一组不带数据的状态标记，类似于 C 中的常量枚举值。</p>
<p>实际上，上面 Direction 的例子也可以看作是 unit-only enum，因为它的变体都不带字段。单位类型的特点是它占用的内存非常小，通常用于定义一组状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Status &#123;</span><br><span class="line">    Success,</span><br><span class="line">    Failure,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 Status 枚举是典型的 unit-only enum，两个变体 Success 和 Failure 没有任何附加数据。</p>
<h3 id="1-3-3-区别总结"><a href="#1-3-3-区别总结" class="headerlink" title="1.3.3 区别总结"></a>1.3.3 区别总结</h3><ul>
<li>Field-less Enum：变体没有字段（不携带数据）。每个变体只是一个状态或标记，可以有或没有关联的数据。</li>
</ul>
<p>例如：enum Shape { Circle(f64), Square(f64) } 中，Square 和 Circle 是 field-less 枚举变体，虽然 Circle(f64) 包含字段数据，但这种定义中的变体本质上还是 field-less，它们主要被用作类型标识符。</p>
<ul>
<li>Unit-only Enum：所有变体都是单位类型（unit type），即没有任何关联数据。可以认为是 field-less enum 的特例，所有变体都只是一种标记，没有数据。</li>
</ul>
<p>例如：enum TrafficLight { Red, Yellow, Green }，这是典型的 unit-only 枚举，每个变体都没有附带的数据。</p>
<p>使用场景<br>Field-less Enum：当你需要表示某个状态，且不需要附带数据时，非常合适。例如状态机、错误代码等。<br>Unit-only Enum：适合用来表示有限且互斥的标记，像开关状态、交通信号灯等情境。</p>
<h1 id="2-Option-枚举和其相对于空值的优势"><a href="#2-Option-枚举和其相对于空值的优势" class="headerlink" title="2. Option 枚举和其相对于空值的优势"></a>2. Option 枚举和其相对于空值的优势</h1><p>在其它编程语言中，往往都有一个 null 关键字，该关键字用于表明一个变量当前的值为空（不是零值，例如整型的零值是 0），也就是不存在值。当你对这些 null 进行操作时，例如调用一个方法，就会直接抛出null 异常，导致程序的崩溃，因此我们在编程时需要格外的小心去处理这些 null 空值。</p>
<p>Tony Hoare， null 的发明者，曾经说过一段非常有名的话：</p>
<table>
    <td bgcolor=#F0F8FF>[package]
        我称之为我十亿美元的错误。当时，我在使用一个面向对象语言设计第一个综合性的面向引用的类型系统。我的目标是通过编译器的自动检查来保证所有引用的使用都应该是绝对安全的。不过在设计过程中，我未能抵抗住诱惑，引入了空引用的概念，因为它非常容易实现。就是因为这个决策，引发了无数错误、漏洞和系统崩溃，在之后的四十多年中造成了数十亿美元的苦痛和伤害。
    </td>
</table>
尽管如此，空值的表达依然非常有意义，因为空值表示当前时刻变量的值是缺失的。有鉴于此，Rust 吸取了众多教训，决定抛弃 null，而改为使用 Option 枚举变量来表述这种结果。

<p>Option 枚举包含两个成员，一个成员表示含有值：Some(T), 另一个表示没有值：None，定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Option&lt;T&gt; &#123;</span><br><span class="line">    Some(T),</span><br><span class="line">    None,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 T 是泛型参数，Some(T)表示该枚举成员的数据类型是 T，换句话说，Some 可以包含任何类型的数据。</p>
<p>Option<T> 枚举是如此有用以至于它被包含在了 prelude（prelude 属于 Rust 标准库，Rust 会将最常用的类型、函数等提前引入其中，省得我们再手动引入）之中，你不需要将其显式引入作用域。另外，它的成员 Some 和 None 也是如此，无需使用 Option:: 前缀就可直接使用 Some 和 None。总之，不能因为 Some(T) 和 None 中没有 Option:: 的身影，就否认它们是 Option 下的卧龙凤雏。</p>
<p>再来看以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let some_number = Some(5);</span><br><span class="line">let some_string = Some(&quot;a string&quot;);</span><br><span class="line"></span><br><span class="line">let absent_number: Option&lt;i32&gt; = None;</span><br></pre></td></tr></table></figure>
<p>如果使用 None 而不是 Some，需要告诉 Rust Option<T> 是什么类型的，因为编译器只通过 None 值无法推断出 Some 成员保存的值的类型。</p>
<p>当有一个 Some 值时，我们就知道存在一个值，而这个值保存在 Some 中。当有个 None 值时，在某种意义上，它跟空值具有相同的意义：并没有一个有效的值。那么，Option<T> 为什么就比空值要好呢？</p>
<p>简而言之，因为 Option<T> 和 T（这里 T 可以是任何类型）是不同的类型，例如，这段代码不能编译，因为它尝试将 Option<i8>(Option<T>) 与 i8(T) 相加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let x: i8 = 5;</span><br><span class="line">let y: Option&lt;i8&gt; = Some(5);</span><br><span class="line"></span><br><span class="line">let sum = x + y;</span><br></pre></td></tr></table></figure>
<p>如果运行这些代码，将得到类似这样的错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: the trait bound `i8: std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is</span><br><span class="line">not satisfied</span><br><span class="line"> --&gt;</span><br><span class="line">  |</span><br><span class="line">5 |     let sum = x + y;</span><br><span class="line">  |                 ^ no implementation for `i8 + std::option::Option&lt;i8&gt;`</span><br><span class="line">  |</span><br></pre></td></tr></table></figure>
<p>很好！事实上，错误信息意味着 Rust 不知道该如何将 Option<i8> 与 i8 相加，因为它们的类型不同。当在 Rust 中拥有一个像 i8 这样类型的值时，编译器确保它总是有一个有效的值，我们可以放心使用而无需做空值检查。只有当使用 Option<i8>（或者任何用到的类型）的时候才需要担心可能没有值，而编译器会确保我们在使用值之前处理了为空的情况。</p>
<p>换句话说，在对 Option<T> 进行 T 的运算之前必须将其转换为 T。通常这能帮助我们捕获到空值最常见的问题之一：期望某值不为空但实际上为空的情况。</p>
<p>不再担心会错误的使用一个空值，会让你对代码更加有信心。为了拥有一个可能为空的值，你必须要显式的将其放入对应类型的 Option<T> 中。接着，当使用这个值时，必须明确的处理值为空的情况。只要一个值不是 Option<T> 类型，你就 可以 安全的认定它的值不为空。这是 Rust 的一个经过深思熟虑的设计决策，来限制空值的泛滥以增加 Rust 代码的安全性。</p>
<p>那么当有一个 Option<T> 的值时，如何从 Some 成员中取出 T 的值来使用它呢？Option<T> 枚举拥有大量用于各种情况的方法：你可以查看它的文档。熟悉 Option<T> 的方法将对你的 Rust 之旅非常有用。</p>
<p>总的来说，为了使用 Option<T> 值，需要编写处理每个成员的代码。你想要一些代码只当拥有 Some(T) 值时运行，允许这些代码使用其中的 T。也希望一些代码在值为 None 时运行，这些代码并没有一个可用的 T 值。match 表达式就是这么一个处理枚举的控制流结构：它会根据枚举的成员运行不同的代码，这些代码可以使用匹配到的值中的数据。</p>
<p>这里先简单看一下 match 的大致模样，在模式匹配中，我们会详细讲解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; &#123;</span><br><span class="line">    match x &#123;</span><br><span class="line">        None =&gt; None,</span><br><span class="line">        Some(i) =&gt; Some(i + 1),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let five = Some(5);</span><br><span class="line">let six = plus_one(five);</span><br><span class="line">let none = plus_one(None);</span><br></pre></td></tr></table></figure>
<p>plus_one 通过 match 来处理不同 Option 的情况。</p>
<h1 id="3-match-控制流结构"><a href="#3-match-控制流结构" class="headerlink" title="3.match 控制流结构"></a>3.match 控制流结构</h1><p>Rust 有一个叫做 match 的极为强大的控制流运算符，它允许我们将一个值与一系列的模式相比较，并根据相匹配的模式执行相应代码。模式可由字面值、变量、通配符和许多其他内容构成；match 的力量来源于模式的表现力以及编译器检查，它确保了所有可能的情况都得到处理。</p>
<p>可以把 match 表达式想象成某种硬币分类器：硬币滑入有着不同大小孔洞的轨道，每一个硬币都会掉入符合它大小的孔洞。同样地，值也会通过 match 的每一个模式，并且在遇到第一个 “符合” 的模式时，值会进入相关联的代码块并在执行中被使用。</p>
<p>因为刚刚提到了硬币，让我们用它们来作为一个使用 match 的例子！我们可以编写一个函数来获取一个未知的硬币，并以一种类似验钞机的方式，确定它是何种硬币并返回它的美分值，如示例 11-3 中所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enum Coin &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn value_in_cents(coin: Coin) -&gt; u8 &#123;</span><br><span class="line">    match coin &#123;</span><br><span class="line">        Coin::Penny =&gt; 1,</span><br><span class="line">        Coin::Nickel =&gt; 5,</span><br><span class="line">        Coin::Dime =&gt; 10,</span><br><span class="line">        Coin::Quarter =&gt; 25,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 11-3：一个枚举和一个以枚举成员作为模式的 match 表达式<br>拆开 value_in_cents 函数中的 match 来看。首先，我们列出 match 关键字后跟一个表达式，在这个例子中是 coin 的值。这看起来非常像 if 所使用的条件表达式，不过这里有一个非常大的区别：对于 if，表达式必须返回一个布尔值，而这里它可以是任何类型的。例子中的 coin 的类型是示例 11-3 中定义的 Coin 枚举。</p>
<p>接下来是 match 的分支。一个分支有两个部分：一个模式和一些代码。第一个分支的模式是值 Coin::Penny 而之后的 &#x3D;&gt; 运算符将模式和将要运行的代码分开。这里的代码就仅仅是值 1。每一个分支之间使用逗号分隔。</p>
<p>当 match 表达式执行时，它将结果值按顺序与每一个分支的模式相比较。如果模式匹配了这个值，这个模式相关联的代码将被执行。如果模式并不匹配这个值，将继续执行下一个分支，非常类似一个硬币分类器。可以拥有任意多的分支：示例 11-3 中的 match 有四个分支。</p>
<p>每个分支相关联的代码是一个表达式，而表达式的结果值将作为整个 match 表达式的返回值。</p>
<p>如果分支代码较短的话通常不使用大括号，正如示例 11-3 中的每个分支都只是返回一个值。如果想要在分支中运行多行代码，可以使用大括号，而分支后的逗号是可选的。例如，如下代码在每次使用Coin::Penny 调用时都会打印出 “Lucky penny!”，同时仍然返回代码块最后的值，1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn value_in_cents(coin: Coin) -&gt; u8 &#123;</span><br><span class="line">    match coin &#123;</span><br><span class="line">        Coin::Penny =&gt; &#123;</span><br><span class="line">            println!(&quot;Lucky penny!&quot;);</span><br><span class="line">            1</span><br><span class="line">        &#125;</span><br><span class="line">        Coin::Nickel =&gt; 5,</span><br><span class="line">        Coin::Dime =&gt; 10,</span><br><span class="line">        Coin::Quarter =&gt; 25,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-绑定值的模式"><a href="#3-2-绑定值的模式" class="headerlink" title="3.2 绑定值的模式"></a>3.2 绑定值的模式</h2><p>匹配分支的另一个有用的功能是可以绑定匹配的模式的部分值。这也就是如何从枚举成员中提取值的。</p>
<p>作为一个例子，让我们修改枚举的一个成员来存放数据。1999 年到 2008 年间，美国在 25 美分的硬币的一侧为 50 个州的每一个都印刷了不同的设计。其他的硬币都没有这种区分州的设计，所以只有这些 25 美分硬币有特殊的价值。可以将这些信息加入我们的 enum，通过改变 Quarter 成员来包含一个 State 值，示例 11-4 中完成了这些修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#[derive(Debug)] // 这样可以立刻看到州的名称</span><br><span class="line">enum UsState &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">    // --snip--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Coin &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter(UsState),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 11-4：Quarter 成员也存放了一个 UsState 值的 Coin 枚举</p>
<p>想象一下我们的一个朋友尝试收集所有 50 个州的 25 美分硬币。在根据硬币类型分类零钱的同时，也可以报告出每个 25 美分硬币所对应的州名称，这样如果我们的朋友没有的话，他可以将其加入收藏。</p>
<p>在这些代码的匹配表达式中，我们在匹配 Coin::Quarter 成员的分支的模式中增加了一个叫做 state 的变量。当匹配到 Coin::Quarter 时，变量 state 将会绑定 25 美分硬币所对应州的值。接着在那个分支的代码中使用 state，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn value_in_cents(coin: Coin) -&gt; u8 &#123;</span><br><span class="line">    match coin &#123;</span><br><span class="line">        Coin::Penny =&gt; 1,</span><br><span class="line">        Coin::Nickel =&gt; 5,</span><br><span class="line">        Coin::Dime =&gt; 10,</span><br><span class="line">        Coin::Quarter(state) =&gt; &#123;</span><br><span class="line">            println!(&quot;State quarter from &#123;state:?&#125;!&quot;);</span><br><span class="line">            25</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果调用 value_in_cents(Coin::Quarter(UsState::Alaska))，coin 将是 Coin::Quarter(UsState::Alaska)。当将值与每个分支相比较时，没有分支会匹配，直到遇到 Coin::Quarter(state)。这时，state 绑定的将会是值 UsState::Alaska。接着就可以在 println! 表达式中使用这个绑定了，像这样就可以获取 Coin 枚举的 Quarter 成员中内部的州的值。</p>
<h2 id="3-3-匹配-Option"><a href="#3-3-匹配-Option" class="headerlink" title="3.3 匹配 Option"></a>3.3 匹配 Option<T></h2><p>我们在之前的部分中使用 Option<T> 时，是为了从 Some 中取出其内部的 T 值；我们还可以像处理 Coin 枚举那样使用 match 处理 Option<T>！只不过这回比较的不再是硬币，而是 Option<T> 的成员，但 match 表达式的工作方式保持不变。</p>
<p>比如我们想要编写一个函数，它获取一个 Option<i32> ，如果其中含有一个值，将其加一。如果其中没有值，函数应该返回 None 值，而不尝试执行任何操作。</p>
<p>得益于 match，编写这个函数非常简单，它将看起来像示例 6-5 中这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; &#123;</span><br><span class="line">    match x &#123;</span><br><span class="line">        None =&gt; None,</span><br><span class="line">        Some(i) =&gt; Some(i + 1),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let five = Some(5);</span><br><span class="line">let six = plus_one(five);</span><br><span class="line">let none = plus_one(None);</span><br></pre></td></tr></table></figure>
<p>示例 6-5：一个在 Option<i32> 上使用 match 表达式的函数</p>
<h3 id="3-3-1-匹配-Some-T"><a href="#3-3-1-匹配-Some-T" class="headerlink" title="3.3.1 匹配 Some(T)"></a>3.3.1 匹配 Some(T)</h3><p>让我们更仔细地检查 plus_one 的第一行操作。当调用 plus_one(five) 时，plus_one 函数体中的 x 将会是值 Some(5)。接着将其与每个分支比较。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">None =&gt; None,</span><br></pre></td></tr></table></figure>
<p>值 Some(5) 并不匹配模式 None，所以继续进行下一个分支。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Some(i) =&gt; Some(i + 1),</span><br></pre></td></tr></table></figure>
<p>Some(5) 与 Some(i) 匹配吗？当然匹配！它们是相同的成员。i 绑定了 Some 中包含的值，所以 i 的值是 5。接着匹配分支的代码被执行，所以我们将 i 的值加一并返回一个含有值 6 的新 Some。</p>
<p>接着考虑下示例 6-5 中 plus_one 的第二个调用，这里 x 是 None。我们进入 match 并与第一个分支相比较。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">None =&gt; None,</span><br></pre></td></tr></table></figure>
<p>匹配上了！这里没有值来加一，所以程序结束并返回 &#x3D;&gt; 右侧的值 None，因为第一个分支就匹配到了，其他的分支将不再比较。</p>
<p>将 match 与枚举相结合在很多场景中都是有用的。你会在 Rust 代码中看到很多这样的模式：match 一个枚举，绑定其中的值到一个变量，接着根据其值执行代码。这在一开始有点复杂，不过一旦习惯了，你会希望所有语言都拥有它！这一直是用户的最爱。</p>
<h3 id="3-3-2-匹配是穷尽的"><a href="#3-3-2-匹配是穷尽的" class="headerlink" title="3.3.2 匹配是穷尽的"></a>3.3.2 匹配是穷尽的</h3><p>match 还有另一方面需要讨论：这些分支必须覆盖了所有的可能性。考虑一下 plus_one 函数的这个版本，它有一个 bug 并不能编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; &#123;</span><br><span class="line">    match x &#123;</span><br><span class="line">        Some(i) =&gt; Some(i + 1),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们没有处理 None 的情况，所以这些代码会造成一个 bug。幸运的是，这是一个 Rust 知道如何处理的 bug。如果尝试编译这段代码，会得到这个错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling enums v0.1.0 (file:///projects/enums)</span><br><span class="line">error[E0004]: non-exhaustive patterns: `None` not covered</span><br><span class="line"> --&gt; src/main.rs:3:15</span><br><span class="line">  |</span><br><span class="line">3 |         match x &#123;</span><br><span class="line">  |               ^ pattern `None` not covered</span><br><span class="line">  |</span><br><span class="line">note: `Option&lt;i32&gt;` defined here</span><br><span class="line"> --&gt; /rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/option.rs:572:1</span><br><span class="line"> ::: /rustc/9b00956e56009bab2aa15d7bff10916599e3d6d6/library/core/src/option.rs:576:5</span><br><span class="line">  |</span><br><span class="line">  = note: not covered</span><br><span class="line">  = note: the matched value is of type `Option&lt;i32&gt;`</span><br><span class="line">help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown</span><br><span class="line">  |</span><br><span class="line">4 ~             Some(i) =&gt; Some(i + 1),</span><br><span class="line">5 ~             None =&gt; todo!(),</span><br><span class="line">  |</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0004`.</span><br><span class="line">error: could not compile `enums` (bin &quot;enums&quot;) due to 1 previous error</span><br></pre></td></tr></table></figure>
<p>Rust 知道我们没有覆盖所有可能的情况甚至知道哪些模式被忘记了！Rust 中的匹配是 穷尽的（exhaustive）：必须穷举到最后的可能性来使代码有效。特别的在这个 Option<T> 的例子中，Rust 防止我们忘记明确的处理 None 的情况，这让我们免于假设拥有一个实际上为空的值，从而使之前提到的价值亿万的错误不可能发生。</p>
<h3 id="3-3-3通配模式和-占位符"><a href="#3-3-3通配模式和-占位符" class="headerlink" title="3.3.3通配模式和 _ 占位符"></a>3.3.3通配模式和 _ 占位符</h3><p>让我们看一个例子，我们希望对一些特定的值采取特殊操作，而对其他的值采取默认操作。想象我们正在玩一个游戏，如果你掷出骰子的值为 3，角色不会移动，而是会得到一顶新奇的帽子。如果你掷出了 7，你的角色将失去新奇的帽子。对于其他的数值，你的角色会在棋盘上移动相应的格子。这是一个实现了上述逻辑的 match，骰子的结果是硬编码而不是一个随机值，其他的逻辑部分使用了没有函数体的函数来表示，实现它们超出了本例的范围：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let dice_roll = 9;</span><br><span class="line">match dice_roll &#123;</span><br><span class="line">    3 =&gt; add_fancy_hat(),</span><br><span class="line">    7 =&gt; remove_fancy_hat(),</span><br><span class="line">    other =&gt; move_player(other),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn add_fancy_hat() &#123;&#125;</span><br><span class="line">fn remove_fancy_hat() &#123;&#125;</span><br><span class="line">fn move_player(num_spaces: u8) &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于前两个分支，匹配模式是字面值 3 和 7，最后一个分支则涵盖了所有其他可能的值，模式是我们命名为 other 的一个变量。other 分支的代码通过将其传递给 move_player 函数来使用这个变量。</p>
<p>即使我们没有列出 u8 所有可能的值，这段代码依然能够编译，因为最后一个模式将匹配所有未被特殊列出的值。这种通配模式满足了 match 必须被穷尽的要求。请注意，我们必须将通配分支放在最后，因为模式是按顺序匹配的。如果我们在通配分支后添加其他分支，Rust 将会警告我们，因为此后的分支永远不会被匹配到。</p>
<p>Rust 还提供了一个模式，当我们不想使用通配模式获取的值时，请使用 _ ，这是一个特殊的模式，可以匹配任意值而不绑定到该值。这告诉 Rust 我们不会使用这个值，所以 Rust 也不会警告我们存在未使用的变量。</p>
<p>让我们改变游戏规则：现在，当你掷出的值不是 3 或 7 的时候，你必须再次掷出。这种情况下我们不需要使用这个值，所以我们改动代码使用 _ 来替代变量 other ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let dice_roll = 9;</span><br><span class="line">match dice_roll &#123;</span><br><span class="line">    3 =&gt; add_fancy_hat(),</span><br><span class="line">    7 =&gt; remove_fancy_hat(),</span><br><span class="line">    _ =&gt; reroll(),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn add_fancy_hat() &#123;&#125;</span><br><span class="line">fn remove_fancy_hat() &#123;&#125;</span><br><span class="line">fn reroll() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子也满足穷举性要求，因为我们在最后一个分支中明确地忽略了其他的值。我们没有忘记处理任何东西。</p>
<p>最后，让我们再次改变游戏规则，如果你掷出 3 或 7 以外的值，你的回合将无事发生。我们可以使用单元值（在“元组类型”一节中提到的空元组）作为 _ 分支的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let dice_roll = 9;</span><br><span class="line">match dice_roll &#123;</span><br><span class="line">    3 =&gt; add_fancy_hat(),</span><br><span class="line">    7 =&gt; remove_fancy_hat(),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn add_fancy_hat() &#123;&#125;</span><br><span class="line">fn remove_fancy_hat() &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这里，我们明确告诉 Rust 我们不会使用与前面模式不匹配的值，并且这种情况下我们不想运行任何代码。</p>
<h1 id="4-if-let-简洁控制流"><a href="#4-if-let-简洁控制流" class="headerlink" title="4. if let 简洁控制流"></a>4. if let 简洁控制流</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let v = Some(3u8);</span><br><span class="line">match v &#123;</span><br><span class="line">    Some(3) =&gt; println!(&quot;three&quot;),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只想要对 Some(3) 模式进行匹配, 不想处理任何其他 Some<u8> 值或 None 值。但是为了满足 match 表达式（穷尽性）的要求，写代码时必须在处理完这唯一的成员后加上 _ &#x3D;&gt; ()，这样会增加不少无用的代码。</p>
<p>俗话说“杀鸡焉用牛刀”，我们完全可以用 if let 的方式来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if let Some(3) = v &#123;</span><br><span class="line">    println!(&quot;three&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这两种匹配对于新手来说，可能有些难以抉择，但是只要记住一点就好：当你只要匹配一个条件，且忽略其他条件时就用 if let ，否则都用 match。</p>
<h1 id="5-用-Result-处理可恢复的错误"><a href="#5-用-Result-处理可恢复的错误" class="headerlink" title="5.用 Result 处理可恢复的错误"></a>5.用 Result 处理可恢复的错误</h1><p>大部分错误并没有严重到需要程序完全停止执行。有时候，一个函数失败，仅仅就是因为一个容易理解和响应的原因。例如，如果因为打开一个并不存在的文件而失败，此时我们可能想要创建这个文件，而不是终止进程。<br>Result 枚举，它定义有如下两个成员，Ok 和 Err：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Result&lt;T, E&gt; &#123;</span><br><span class="line">    Ok(T),</span><br><span class="line">    Err(E),</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>T 和 E 是泛型类型参数；第十章会详细介绍泛型。现在你需要知道的就是 T 代表成功时返回的 Ok 成员中的数据的类型，而 E 代表失败时返回的 Err 成员中的错误的类型。因为 Result 有这些泛型类型参数，我们可以将 Result 类型和标准库中为其定义的函数用于很多不同的场景，这些情况中需要返回的成功值和失败值可能会各不相同。</p>
<p>让我们调用一个返回 Result 的函数，因为它可能会失败：如示例 9-3 所示打开一个文件：</p>
<p>文件名：src&#x2F;main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use std::fs::File;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let greeting_file_result = File::open(&quot;hello.txt&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 9-3：打开文件</p>
<p>File::open 的返回值是 Result&lt;T, E&gt;。泛型参数 T 会被 File::open 的实现放入成功返回值的类型 std::fs::File，这是一个文件句柄。错误返回值使用的 E 的类型是 std::io::Error。这些返回类型意味着 File::open 调用可能成功并返回一个可以读写的文件句柄。这个函数调用也可能会失败：例如，也许文件不存在，或者可能没有权限访问这个文件。File::open 函数需要一个方法在告诉我们成功与否的同时返回文件句柄或者错误信息。这些信息正好是 Result 枚举所代表的。</p>
<p>当 File::open 成功时，greeting_file_result 变量将会是一个包含文件句柄的 Ok 实例。当失败时，greeting_file_result 变量将会是一个包含了更多关于发生了何种错误的信息的 Err 实例。</p>
<p>我们需要在示例 9-3 的代码中增加根据 File::open 返回值进行不同处理的逻辑。示例 9-4 展示了一个使用基本工具处理 Result 的例子： match 表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">use std::fs::File;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let greeting_file_result = File::open(&quot;hello.txt&quot;);</span><br><span class="line"></span><br><span class="line">    let greeting_file = match greeting_file_result &#123;</span><br><span class="line">        Ok(file) =&gt; file,</span><br><span class="line">        Err(error) =&gt; panic!(&quot;Problem opening the file: &#123;error:?&#125;&quot;),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 9-4：使用 match 表达式处理可能会返回的 Result 成员<br>注意与 Option 枚举一样，Result 枚举和其成员也被导入到了 prelude 中，所以就不需要在 match 分支中的 Ok 和 Err 之前指定 Result::。</p>
<p>这里我们告诉 Rust 当结果是 Ok 时，返回 Ok 成员中的 file 值，然后将这个文件句柄赋值给变量 greeting_file。match 之后，我们可以利用这个文件句柄来进行读写。</p>
<p>match 的另一个分支处理从 File::open 得到 Err 值的情况。在这种情况下，我们选择调用 panic! 宏。如果当前目录没有一个叫做 hello.txt 的文件，当运行这段代码时会看到如下来自 panic! 宏的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling error-handling v0.1.0 (file:///projects/error-handling)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s</span><br><span class="line">     Running `target/debug/error-handling`</span><br><span class="line">thread &#x27;main&#x27; panicked at src/main.rs:8:23:</span><br><span class="line">Problem opening the file: Os &#123; code: 2, kind: NotFound, message: &quot;No such file or directory&quot; &#125;</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一如既往，此输出准确地告诉了我们到底出了什么错。</p>
<h2 id="5-1-匹配不同的错误"><a href="#5-1-匹配不同的错误" class="headerlink" title="5.1 匹配不同的错误"></a>5.1 匹配不同的错误</h2><p>示例 9-4 中的代码不管 File::open 是因为什么原因失败都会 panic!。我们真正希望的是对不同的错误原因采取不同的行为：如果 File::open 因为文件不存在而失败，我们希望创建这个文件并返回新文件的句柄。如果 File::open 因为任何其他原因失败，例如没有打开文件的权限，我们仍然希望像示例 9-4 那样 panic!。让我们看看示例 9-5，其中 match 增加了另一个分支：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">use std::fs::File;</span><br><span class="line">use std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let greeting_file_result = File::open(&quot;hello.txt&quot;);</span><br><span class="line"></span><br><span class="line">    let greeting_file = match greeting_file_result &#123;</span><br><span class="line">        Ok(file) =&gt; file,</span><br><span class="line">        Err(error) =&gt; match error.kind() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) &#123;</span><br><span class="line">                Ok(fc) =&gt; fc,</span><br><span class="line">                Err(e) =&gt; panic!(&quot;Problem creating the file: &#123;e:?&#125;&quot;),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; &#123;</span><br><span class="line">                panic!(&quot;Problem opening the file: &#123;other_error:?&#125;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 9-5：使用不同的方式处理不同类型的错误<br>File::open 返回的 Err 成员中的值类型 io::Error，它是一个标准库中提供的结构体。这个结构体有一个返回 io::ErrorKind 值的 kind 方法可供调用。io::ErrorKind 是一个标准库提供的枚举，它的成员对应 io 操作可能导致的不同错误类型。我们感兴趣的成员是 ErrorKind::NotFound，它代表尝试打开的文件并不存在。这样，match 就匹配完 greeting_file_result 了，不过对于 error.kind() 还有一个内层 match。</p>
<p>我们希望在内层 match 中检查的条件是 error.kind() 的返回值是否为 ErrorKind的 NotFound 成员。如果是，则尝试通过 File::create 创建文件。然而因为 File::create 也可能会失败，还需要增加一个内层 match 语句。当文件不能被创建，会打印出一个不同的错误信息。外层 match 的最后一个分支保持不变，这样对任何除了文件不存在的错误会使程序 panic。</p>
<table>
    <td bgcolor=#F0F8FF>[package]
        不同于使用 match 和 Result<T, E>

<pre><code>    这里有好多 match！match 确实很强大，不过也非常的原始。我们会介绍闭包（closure），它会和定义在 Result&lt;T, E&gt; 中的很多方法一起使用。在处理代码中的 Result&lt;T, E&gt; 值时，相比于使用 match ，使用这些方法会更加简洁。

    例如，这是另一个编写与示例 9-5 逻辑相同但是使用闭包和 unwrap_or_else 方法的例子：

    use std::fs::File;
    use std::io::ErrorKind;

    fn main() &#123;
        let greeting_file = File::open(&quot;hello.txt&quot;).unwrap_or_else(|error| &#123;
            if error.kind() == ErrorKind::NotFound &#123;
                File::create(&quot;hello.txt&quot;).unwrap_or_else(|error| &#123;
                    panic!(&quot;Problem creating the file: &#123;:?&#125;&quot;, error);
                &#125;)
            &#125; else &#123;
                panic!(&quot;Problem opening the file: &#123;:?&#125;&quot;, error);
            &#125;
        &#125;);
    &#125;
&lt;/td&gt;
</code></pre>
</table>


<h1 id="6-Option转Result"><a href="#6-Option转Result" class="headerlink" title="6. Option转Result"></a>6. Option转Result</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let opt:Option&lt;i32&gt; = Some(42);</span><br><span class="line">    let result:Result&lt;i32, &amp;str&gt; = opt.ok_or(&quot;error&quot;);</span><br><span class="line">    assert_eq!(result, Ok(42));</span><br><span class="line"></span><br><span class="line">    let none:Option&lt;i32&gt; = None;</span><br><span class="line">    let result:Result&lt;i32, &amp;str&gt; = none.ok_or(&quot;error&quot;);</span><br><span class="line">    assert_eq!(result, Err(&quot;error&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-Result转Option"><a href="#7-Result转Option" class="headerlink" title="7. Result转Option"></a>7. Result转Option</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let res:Result&lt;i32, &amp;str&gt; = Ok(42);</span><br><span class="line">    let opt:Option&lt;i32&gt; = res.ok();</span><br><span class="line">    assert_eq!(opt, Some(42));</span><br><span class="line"></span><br><span class="line">    let res:Result&lt;i32, &amp;str&gt; = Err(&quot;error&quot;);</span><br><span class="line">    let opt:Option&lt;i32&gt; = res.ok();</span><br><span class="line">    assert_eq!(opt, None);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-判别式（Discriminants）"><a href="#8-判别式（Discriminants）" class="headerlink" title="8.判别式（Discriminants）"></a>8.判别式（Discriminants）</h1><p>是一种在枚举类型（enum）中用来区分不同变体（variant）的数据结构。每个变体都有一个唯一的整数值，这个整数值被称为判别式值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    enum Fieldless &#123;</span><br><span class="line">        Tuple(),</span><br><span class="line">        Struct &#123;&#125;,</span><br><span class="line">        Unit,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    assert_eq!(0, Fieldless::Tuple() as isize);</span><br><span class="line"></span><br><span class="line">    enum UnitOnlyEnum &#123;</span><br><span class="line">        Foo = 0,</span><br><span class="line">        Bar = 1,</span><br><span class="line">        Baz = 2,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    enum UnitOnlyEnum2 &#123;</span><br><span class="line">        Foo,</span><br><span class="line">        Bar,</span><br><span class="line">        Baz,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert_eq!(UnitOnlyEnum::Foo as isize, 0);</span><br><span class="line">    assert_eq!(UnitOnlyEnum2::Foo as isize, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-enum-mem-枚举内存"><a href="#9-enum-mem-枚举内存" class="headerlink" title="9. enum mem 枚举内存"></a>9. enum mem 枚举内存</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">use std::mem::size_of;</span><br><span class="line">#[derive(Debug)]</span><br><span class="line">enum MyEnum &#123;</span><br><span class="line">    A,</span><br><span class="line">    B(i32),</span><br><span class="line">    C &#123;x:f64, y:f64&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    println!(&quot;Size of MyEnum:&#123;&#125;&quot;, size_of::&lt;MyEnum&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Size of MyEnum:24</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/09/17/learnRust10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Byte的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/09/17/learnRust10/" itemprop="url">Rust入门-基础 第十节 字符串练习题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-09-17T17:09:43+08:00">
                2024-09-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>🌟 We can’t use str type in normal ways, but we can use &amp;str.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Fix error without adding new line</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s: str = &quot;hello, world&quot;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s:&amp;str = &quot;hello, world&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>🌟🌟 We can only use str by boxing it, &amp; can be used to convert Box<str> to &amp;str<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Fix the error with at least two solutions</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s: Box&lt;str&gt; = &quot;hello, world&quot;.into();</span><br><span class="line">    greetings(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn greetings(s: &amp;str) &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s: Box&lt;str&gt; = &quot;hello, world&quot;.into();</span><br><span class="line">    greetings(&amp;s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn greetings(s: &amp;str) &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s: Box&lt;str&gt; = &quot;hello, world&quot;.into();</span><br><span class="line">    greetings(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn greetings(s: Box&lt;str&gt;) &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s: Box&lt;&amp;str&gt; = &quot;hello, world&quot;.into();</span><br><span class="line">    greetings(*s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn greetings(s: &amp;str) &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>String<br>String type is defined in std and stored as a vector of bytes (Vec), but guaranteed to always be a valid UTF-8 sequence. String is heap allocated, growable and not null terminated.<br>3. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Fill the blank</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = __;</span><br><span class="line">    s.push_str(&quot;hello, world&quot;);</span><br><span class="line">    s.push(&#x27;!&#x27;);</span><br><span class="line"></span><br><span class="line">    assert_eq!(s, &quot;hello, world!&quot;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Fill the blank</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;value&quot;);</span><br><span class="line">    s.push_str(&quot;hello, world&quot;);</span><br><span class="line">    s.push(&#x27;!&#x27;);</span><br><span class="line"></span><br><span class="line">    assert_eq!(s, &quot;hello, world!&quot;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>🌟🌟🌟</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Fix all errors without adding newline</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;hello&quot;);</span><br><span class="line">    s.push(&#x27;,&#x27;);</span><br><span class="line">    s.push(&quot; world&quot;);</span><br><span class="line">    s += &quot;!&quot;.to_string();</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Fix all errors without adding newline</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello&quot;);</span><br><span class="line">    s.push(&#x27;,&#x27;);</span><br><span class="line">    s.push_str(&quot; world&quot;);</span><br><span class="line">    s += &quot;!&quot;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>🌟🌟 replace can be used to replace substring</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Fill the blank</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;I like dogs&quot;);</span><br><span class="line">    // Allocate new memory and store the modified string there</span><br><span class="line">    let s1 = s.__(&quot;dogs&quot;, &quot;cats&quot;);</span><br><span class="line"></span><br><span class="line">    assert_eq!(s1, &quot;I like cats&quot;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Fill the blank</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;I like dogs&quot;);</span><br><span class="line">    // Allocate new memory and store the modified string there</span><br><span class="line">    let s1 = s.replace(&quot;dogs&quot;, &quot;cats&quot;);</span><br><span class="line"></span><br><span class="line">    assert_eq!(s1, &quot;I like cats&quot;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>More String methods can be found under String module.</p>
<ol start="6">
<li>🌟🌟 You can only concat a String with &amp;str, and String’s ownership can be moved to another variable. <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Fix errors without removing any line</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(&quot;hello,&quot;);</span><br><span class="line">    let s2 = String::from(&quot;world!&quot;);</span><br><span class="line">    let s3 = s1 + s2; </span><br><span class="line">    assert_eq!(s3, &quot;hello,world!&quot;);</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
6.1<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(&quot;hello,&quot;);</span><br><span class="line">    let s2 = String::from(&quot;world!&quot;);</span><br><span class="line">    let s3 = format!(&quot;&#123;&#125;&#123;&#125;&quot;, s1, s2);</span><br><span class="line">    assert_eq!(s3, &quot;hello,world!&quot;);</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
6.2<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(&quot;hello,&quot;);</span><br><span class="line">    let s2 = String::from(&quot;world!&quot;);</span><br><span class="line">    let s3 = s1.clone() + &amp;s2; </span><br><span class="line">    //let s4 = s1.clone();</span><br><span class="line">    assert_eq!(s3, &quot;hello,world!&quot;);</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>Opposite to the seldom using of str, &amp;str and String are used everywhere!<br>7. 🌟🌟 &amp;str can be converted to String in two ways</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Fix error with at least two solutions</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = &quot;hello, world&quot;;</span><br><span class="line">    greetings(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn greetings(s: String) &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7.1 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Fix error with at least two solutions</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = &quot;hello, world&quot;;</span><br><span class="line">    greetings(s.to_string());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn greetings(s: String) &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7.2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Fix error with at least two solutions</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = &quot;hello, world&quot;;</span><br><span class="line">    greetings(String::from(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn greetings(s: String) &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><p>🌟🌟 We can use String::from or to_string to convert a &amp;str to String</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Use two approaches to fix the error and without adding a new line</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = &quot;hello, world&quot;.to_string();</span><br><span class="line">    let s1: &amp;str = s;</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8.1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Use two approaches to fix the error and without adding a new line</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = &quot;hello, world&quot;.to_string();</span><br><span class="line">    let s1: &amp;str = &amp;s;</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8.2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Use two approaches to fix the error and without adding a new line</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = &quot;hello, world&quot;;</span><br><span class="line">    let s1: &amp;str = s;</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8.3</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Use two approaches to fix the error and without adding a new line</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = &quot;hello, world&quot;.to_string();</span><br><span class="line">    let s1 = s;</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // You can use escapes to write bytes by their hexadecimal values</span><br><span class="line">    // Fill the blank below to show &quot;I&#x27;m writing Rust&quot;</span><br><span class="line">    let byte_escape = &quot;I&#x27;m writing Ru\x73__!&quot;;</span><br><span class="line">    println!(&quot;What are you doing\x3F (\\x3F means ?) &#123;&#125;&quot;, byte_escape);</span><br><span class="line"></span><br><span class="line">    // ...Or Unicode code points.</span><br><span class="line">    let unicode_codepoint = &quot;\u&#123;211D&#125;&quot;;</span><br><span class="line">    let character_name = &quot;\&quot;DOUBLE-STRUCK CAPITAL R\&quot;&quot;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;Unicode character &#123;&#125; (U+211D) is called &#123;&#125;&quot;,</span><br><span class="line">                unicode_codepoint, character_name );</span><br><span class="line"></span><br><span class="line">    let long_string = &quot;String literals</span><br><span class="line">                        can span multiple lines.</span><br><span class="line">                        The linebreak and indentation here \</span><br><span class="line">                         can be escaped too!&quot;;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, long_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>9.1 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // You can use escapes to write bytes by their hexadecimal values</span><br><span class="line">    // fill the blank below to show &quot;I&#x27;m writing Rust&quot;</span><br><span class="line">    let byte_escape = &quot;I&#x27;m writing Ru\x73\x74!&quot;;</span><br><span class="line">    println!(&quot;What are you doing\x3F (\\x3F means ?) &#123;&#125;&quot;, byte_escape);</span><br><span class="line"></span><br><span class="line">    // ...or Unicode code points.</span><br><span class="line">    let unicode_codepoint = &quot;\u&#123;211D&#125;&quot;;</span><br><span class="line">    let character_name = &quot;\&quot;DOUBLE-STRUCK CAPITAL R\&quot;&quot;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;Unicode character &#123;&#125; (U+211D) is called &#123;&#125;&quot;,</span><br><span class="line">                unicode_codepoint, character_name );</span><br><span class="line"></span><br><span class="line">   let long_string = &quot;String literals</span><br><span class="line">                        can span multiple lines.</span><br><span class="line">                        The linebreak and indentation here \</span><br><span class="line">                         can be escaped too!&quot;;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, long_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>🌟🌟🌟 Sometimes there are just too many characters that need to be escaped or it’s just much more convenient to write a string out as-is. This is where raw string literals come into play.</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/* Fill in the blank and fix the errors */</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let raw_str = r&quot;Escapes don&#x27;t work here: \x3F \u&#123;211D&#125;&quot;;</span><br><span class="line">    // Modify above line to make it work</span><br><span class="line">    assert_eq!(raw_str, &quot;Escapes don&#x27;t work here: ? ℝ&quot;);</span><br><span class="line"></span><br><span class="line">    // If you need quotes in a raw string, add a pair of #s</span><br><span class="line">    let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, quotes);</span><br><span class="line"></span><br><span class="line">    // If you need &quot;# in your string, just use more #s in the delimiter.</span><br><span class="line">    // You can use up to 65535 #s.</span><br><span class="line">    let delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, delimiter);</span><br><span class="line"></span><br><span class="line">    // Fill the blank</span><br><span class="line">    let long_delimiter = __;</span><br><span class="line">    assert_eq!(long_delimiter, &quot;Hello, \&quot;##\&quot;&quot;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>10.1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* Fill in the blank and fix the errors */</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let raw_str = &quot;Escapes don&#x27;t work here: \x3F \u&#123;211D&#125;&quot;;</span><br><span class="line">    // Modify above line to make it work</span><br><span class="line">    assert_eq!(raw_str, &quot;Escapes don&#x27;t work here: ? ℝ&quot;);</span><br><span class="line"></span><br><span class="line">    //println!(&quot;&#123;&#125;&quot;, raw_str);</span><br><span class="line">    // If you need quotes in a raw string, add a pair of #s</span><br><span class="line">    let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, quotes);</span><br><span class="line"></span><br><span class="line">    // If you need &quot;# in your string, just use more #s in the delimiter.</span><br><span class="line">    // You can use up to 65535 #s.</span><br><span class="line">    let delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, delimiter);</span><br><span class="line"></span><br><span class="line">    // // Fill the blank</span><br><span class="line">    let long_delimiter = r###&quot;Hello, &quot;##&quot;&quot;###;</span><br><span class="line">    assert_eq!(long_delimiter, &quot;Hello, \&quot;##\&quot;&quot;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Byte string<br>Want a string that’s not UTF-8? (Remember, str and String must be valid UTF-8). Or maybe you want an array of bytes that’s mostly text? Byte strings to the rescue!</p>
<figure class="highlight plaintext"><figcaption><span>std::str;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    // Note that this is not actually a `&amp;str`</span><br><span class="line">    let bytestring: &amp;[u8; 21] = b&quot;this is a byte string&quot;;</span><br><span class="line"></span><br><span class="line">    // Byte arrays don&#x27;t have the `Display` trait, so printing them is a bit limited</span><br><span class="line">    println!(&quot;A byte string: &#123;:?&#125;&quot;, bytestring);</span><br><span class="line"></span><br><span class="line">    // Byte strings can have byte escapes...</span><br><span class="line">    let escaped = b&quot;\x52\x75\x73\x74 as bytes&quot;;</span><br><span class="line">    // ...But no unicode escapes</span><br><span class="line">    // let escaped = b&quot;\u&#123;211D&#125; Is not allowed&quot;;</span><br><span class="line">    println!(&quot;Some escaped bytes: &#123;:?&#125;&quot;, escaped);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Raw byte strings work just like raw strings</span><br><span class="line">    let raw_bytestring = br&quot;\u&#123;211D&#125; is not escaped here&quot;;</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, raw_bytestring);</span><br><span class="line"></span><br><span class="line">    // Converting a byte array to `str` can fail</span><br><span class="line">    if let Ok(my_str) = str::from_utf8(raw_bytestring) &#123;</span><br><span class="line">        println!(&quot;And the same as text: &#x27;&#123;&#125;&#x27;&quot;, my_str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let _quotes = br#&quot;You can also use &quot;fancier&quot; formatting, \</span><br><span class="line">                    like with normal raw strings&quot;#;</span><br><span class="line"></span><br><span class="line">    // Byte strings don&#x27;t have to be UTF-8</span><br><span class="line">    let shift_jis = b&quot;\x82\xe6\x82\xa8\x82\xb1\x82\xbb&quot;; // &quot;ようこそ&quot; In SHIFT-JIS</span><br><span class="line"></span><br><span class="line">    // But then they can&#x27;t always be converted to `str`</span><br><span class="line">    match str::from_utf8(shift_jis) &#123;</span><br><span class="line">        Ok(my_str) =&gt; println!(&quot;Conversion successful: &#x27;&#123;&#125;&#x27;&quot;, my_str),</span><br><span class="line">        Err(e) =&gt; println!(&quot;Conversion failed: &#123;:?&#125;&quot;, e),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="11">
<li><p>🌟🌟🌟 You can’t use index to access a char in a string, but you can use slice &amp;s1[start..end].</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(&quot;hi,中国&quot;);</span><br><span class="line">    let h = s1[0]; // Modify this line to fix the error, tips: `h` only takes 1 byte in UTF8 format</span><br><span class="line">    assert_eq!(h, &quot;h&quot;);</span><br><span class="line"></span><br><span class="line">    let h1 = &amp;s1[3..5]; // Modify this line to fix the error, tips: `中`  takes 3 bytes in UTF8 format</span><br><span class="line">    assert_eq!(h1, &quot;中&quot;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>11.1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(&quot;hi,中国&quot;);</span><br><span class="line">    let h = &amp;s1[0..1]; // Modify this line to fix the error, tips: `h` only takes 1 byte in UTF8 format</span><br><span class="line">    assert_eq!(h, &quot;h&quot;);</span><br><span class="line"></span><br><span class="line">    let h1 = &amp;s1[3..6]; // Modify this line to fix the error, tips: `中`  takes 3 bytes in UTF8 format</span><br><span class="line">    assert_eq!(h1, &quot;中&quot;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // Fill the blank to print each char in &quot;你好，世界&quot;</span><br><span class="line">    for c in &quot;你好，世界&quot;.__ &#123;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>12.1 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // Fill the blank to print each char in &quot;你好，世界&quot;</span><br><span class="line">    for c in &quot;你好，世界&quot;.chars() &#123;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>utf8_slice<br>You can use utf8_slice to slice UTF8 string, it can index chars instead of bytes.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use utf8_slice;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = &quot;The 🚀 goes to the 🌑!&quot;;</span><br><span class="line"></span><br><span class="line">    let rocket = utf8_slice::slice(s, 4, 5);</span><br><span class="line">    // Will equal &quot;🚀&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/09/01/learnRust9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Byte的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/09/01/learnRust9/" itemprop="url">Rust入门-基础 第九节 字符串</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-09-01T22:07:14+08:00">
                2024-09-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1.字符串"></a>1.字符串</h1><p>字符串字面量的类型是 &amp;str， 例如 let s: &amp;str &#x3D; “hello, world” 中的 “hello, world” 的类型就是 &amp;str</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;hello world!&quot;);</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s);</span><br><span class="line"></span><br><span class="line">    let s = &quot;Hello world!&quot;;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-数组切片"><a href="#2-数组切片" class="headerlink" title="2.数组切片"></a>2.数组切片</h1><p>slice 允许你引用集合中一段连续的元素序列,而不是引用整个集合<br>slice 是一种引用，所以它没有所有权</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a:[i32;5]   = [1,2,3,4,5];</span><br><span class="line">    </span><br><span class="line">    let s:&amp;[i32]    = &amp;a[1..3];</span><br><span class="line"></span><br><span class="line">    assert_eq!(s, &amp;[2,3]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-什么是字符串？"><a href="#3-什么是字符串？" class="headerlink" title="3.什么是字符串？"></a>3.什么是字符串？</h1><ul>
<li>字符串是由字符组成的连续集合</li>
<li>Rust中的字符是Unicode类型，因此每个字符占据4个字节内存空间，但是在字符串中不一样，字符串是UTF-8编码，也就是字符串中的字符所占的字节数是变化的（1-4）</li>
</ul>
<p>对于”hello 中国”这样的一个字符串来说，UTF8编码为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h   e   l   l   o   中  国</span><br><span class="line">[104 101 108 108 111 32 228,184,173 229,155,189]</span><br></pre></td></tr></table></figure>

<p>str</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s:&amp;str = &quot;Hello, world!&quot;;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>str类型，是Rust语言提供的一个基础类型,其本质是一个字节数组[u8]<br>str 或 [8] 类型的值存放在内存某处：可能是堆，可能是栈 还可能硬编码进可执行程序。</p>
<h1 id="4-字符串字面值"><a href="#4-字符串字面值" class="headerlink" title="4.字符串字面值"></a>4.字符串字面值</h1><p>字符串字面值来说，我们在编译时就知道其内容，最终字面值文本被直接硬编码进可执行文件<br>字符串字面量 “Hello World” 就是 st类型 它被硬编码进可执行程序的数据部分<br>既然我们已经存储了这个字符串，就需要一种方法来访问它：这就是切片引用&amp;str的意义所在</p>
<ul>
<li>&amp;str是一种不可变引用，所以它没有所有权</li>
<li>str类型是硬编码进可执行文件，也无法被修改</li>
</ul>
<h1 id="4-1-str-vs-String"><a href="#4-1-str-vs-String" class="headerlink" title="4.1 &amp;str vs String"></a>4.1 &amp;str vs String</h1><ul>
<li>&amp;str：这是一个字符串切片，它是固定大小的，并且不能改变</li>
<li>String 这是一个可增长，可改变的，拥有所有权的， UTF-8</li>
<li></li>
<li>编码的字符串类型，它通常用于需要改变或者增长字符串的情况。</li>
</ul>
<h1 id="4-2-将utf8数组转成字符串"><a href="#4-2-将utf8数组转成字符串" class="headerlink" title="4.2 将utf8数组转成字符串"></a>4.2 将utf8数组转成字符串</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use core::str;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let b = [104,101,108,108,111,32,228,184,173,229,155,189];</span><br><span class="line">    let s = str::from_utf8(&amp;b).unwrap();</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-3-将字符串转成utf8数组"><a href="#4-3-将字符串转成utf8数组" class="headerlink" title="4.3 将字符串转成utf8数组"></a>4.3 将字符串转成utf8数组</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = &quot;hello 中国&quot;.as_bytes();</span><br><span class="line">    dbg!(&quot;&#123;&#125;&quot;, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-4-String-str"><a href="#4-4-String-str" class="headerlink" title="4.4 String -&gt; &amp;str"></a>4.4 String -&gt; &amp;str</h1><p>从String 类型转变为 &amp;str 是非常便捷的，而且无损的（性能无损，不会造成重写malloc或者数据移动）<br>另外，由于Rust实现了自动解引用，那么&amp;String在必要的时候可以自动转换为&amp;str，因此在很多函数中，如果接收参数是字符串的引用，通常会采用&amp;str作为入参，以获取更好的数据兼容性。</p>
<p>字符串是UTF-8编码，因此需要保证索引的字节刚好落在字符的边界</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;hello,world!&quot;);</span><br><span class="line">    say_hello(&amp;s);</span><br><span class="line">    say_hello(&amp;s[..]);</span><br><span class="line">    say_hello(s.as_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn say_hello(s:&amp;str) &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-5-字符串数组Vec-String"><a href="#4-5-字符串数组Vec-String" class="headerlink" title="4.5 字符串数组Vec -&gt; String"></a>4.5 字符串数组Vec<u8> -&gt; String</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let b = vec![104,101,108,108,111,32,228,184,173,229,155,189];</span><br><span class="line">    let s = String::from_utf8(b).unwrap();</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-6-str-String"><a href="#4-6-str-String" class="headerlink" title="4.6 &amp;str -&gt; String"></a>4.6 &amp;str -&gt; String</h1><p>从一个&amp;str获得一个String却是低效的，因为要重新malloc数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;hello 世界&quot;);</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-操作字符串"><a href="#5-操作字符串" class="headerlink" title="5. 操作字符串"></a>5. 操作字符串</h1><p>由于 String 是可变字符串，下面介绍Rust字符串的修改，添加，删除等常用方法</p>
<h1 id="5-1-追加-Push"><a href="#5-1-追加-Push" class="headerlink" title="5.1 追加(Push)"></a>5.1 追加(Push)</h1><ul>
<li>使用push() 方法追加字符char</li>
<li>使用push_str()方法追加字符串字面量</li>
<li>两个方法都是在原有的字符串上追加，并不会返回新的字符串</li>
<li>字符串追加操作要修改原来的字符串，则该字符串必须是可变的，即字符串变量必须由mut关键字修饰</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;Hello &quot;);</span><br><span class="line"></span><br><span class="line">    s.push_str(&quot;rust&quot;);</span><br><span class="line">    println!(&quot;追加字符串 push_str() =&gt; &#123;&#125;&quot;, s);</span><br><span class="line"></span><br><span class="line">    s.push(&#x27;!&#x27;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;追加字符 push() =&gt; &#123;&#125;&quot;, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-2-插入-Insert"><a href="#5-2-插入-Insert" class="headerlink" title="5.2 插入(Insert)"></a>5.2 插入(Insert)</h1><ul>
<li>使用insert()方法插入单个字符char</li>
<li>使用insert_str()方法插入字符串字面量</li>
<li>这俩方法需要传入两个参数，第一个参数是字符（串）插入位置的索引，索引从0开始计数；第二个参数是要插入的字符(串)<ul>
<li>如果越界则会发生错误</li>
<li>如果参数所给的位置不是合法的字符边界，也会发生错误</li>
</ul>
</li>
<li>由于字符串插入操作要修改原来的字符串，则该字符串必须是可变的，即字符串变量必须由mut关键字修饰</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;Hello rust！中文&quot;);</span><br><span class="line"></span><br><span class="line">    s.insert(5,&#x27;,&#x27;);</span><br><span class="line">    println!(&quot;插入字符 insert() =&gt; &#123;&#125;&quot;, s);</span><br><span class="line"></span><br><span class="line">    //报错</span><br><span class="line">    //s.insert(13, &#x27;,&#x27;);</span><br><span class="line"></span><br><span class="line">    s.insert_str(6, &quot;I like&quot;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;插入字符串 insert_str() =&gt; &#123;&#125;&quot;, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-3-replace"><a href="#5-3-replace" class="headerlink" title="5.3 replace"></a>5.3 replace</h1><ul>
<li>replace()方法接收两个参数，第一个参数是要被替换的字符串，第二个参数是新的字符串</li>
<li>该方法会替换所有匹配到的字符串</li>
<li>该方法是返回的一个新的字符串，而不是操作原来的字符串<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;I like rust.Learning rust is my faviorte!&quot;);</span><br><span class="line">    let new_string_replace = s.replace(&quot;rust&quot;, &quot;Rust&quot;);</span><br><span class="line"></span><br><span class="line">    dbg!(new_string_replace);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="5-4-replacen"><a href="#5-4-replacen" class="headerlink" title="5.4 replacen"></a>5.4 replacen</h1><ul>
<li>方法接收三个参数。前两个参数与replace()方法一样，第三个参数则表示替换的个数</li>
<li>该方法是返回一个新的字符串，而不是操作原来的字符串<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;I like rust.Learning rust is my faviorte!&quot;);</span><br><span class="line">    let new_string_replace = s.replacen(&quot;rust&quot;, &quot;Rust&quot;, 1);</span><br><span class="line"></span><br><span class="line">    dbg!(new_string_replace);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="5-5-replace-range"><a href="#5-5-replace-range" class="headerlink" title="5.5 replace_range"></a>5.5 replace_range</h1><ul>
<li>replace_range 接收两个参数，第一个参数是要替换字符串的范围(Range),第二个参数是新的字符串</li>
<li>该方法是直接操作原来的字符串，不会返回新的字符串。该方法需要使用mut关键字修饰。</li>
<li>如果range的范围大于&#x2F;小于新字符串长度会怎样？<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;I like rust!&quot;);</span><br><span class="line">    s.replace_range(7..8, &quot;R&quot;);</span><br><span class="line">    dbg!(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;I like rust!&quot;);</span><br><span class="line">    s.replace_range(7..=10, &quot;Rust1&quot;);</span><br><span class="line">    dbg!(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;I like rust!&quot;);</span><br><span class="line">    s.replace_range(6..7, &quot;Rust&quot;);</span><br><span class="line">    dbg!(s);</span><br><span class="line">&#125;</span><br><span class="line">   Compiling world_hello v0.1.0 (D:\rust\world_hello)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.23s</span><br><span class="line">     Running `target\debug\world_hello.exe`</span><br><span class="line">[src/main.rs:4:5] s = &quot;I likeRustrust!&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;I like rust!&quot;);</span><br><span class="line">    s.replace_range(6..=10, &quot;R&quot;);</span><br><span class="line">    dbg!(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   Compiling world_hello v0.1.0 (D:\rust\world_hello)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.21s</span><br><span class="line">     Running `target\debug\world_hello.exe`</span><br><span class="line">[src/main.rs:4:5] s = &quot;I likeR!&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="5-6-pop"><a href="#5-6-pop" class="headerlink" title="5.6 pop"></a>5.6 pop</h1><ul>
<li>删除并返回字符串的最后一个字符</li>
<li>其返回值是一个Option类型，如果字符串为空，则返回None</li>
<li>该方法是直接操作原来的字符串<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;中文!&quot;);</span><br><span class="line"></span><br><span class="line">    let p1 = s.pop();</span><br><span class="line">    let p2 = s.pop();</span><br><span class="line">    dbg!(p1);</span><br><span class="line">    dbg!(p2);</span><br><span class="line">    dbg!(&amp;s);</span><br><span class="line"></span><br><span class="line">    let p3  = s.pop();</span><br><span class="line">    let p4  = s.pop();</span><br><span class="line">    dbg!(p3);</span><br><span class="line">    dbg!(p4);</span><br><span class="line">    //dbg!(&amp;string_pop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="5-7-remove"><a href="#5-7-remove" class="headerlink" title="5.7 remove"></a>5.7 remove</h1><ul>
<li>该方法是直接操作原来的字符串</li>
<li>其返回值是删除位置的字符串</li>
<li>只接收一个参数，表示该字符起始索引位置</li>
<li>方法是按照字节来处理字符串的，如果参数所给的位置不是合法的字符边界，则会发生错误</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;测试remove方法&quot;);</span><br><span class="line">    println!(</span><br><span class="line">        &quot;string_remove 占 &#123;&#125; 个字节&quot;,</span><br><span class="line">        std::mem::size_of_val(s.as_str())</span><br><span class="line">    );</span><br><span class="line">    s.remove(0);</span><br><span class="line"></span><br><span class="line">    dbg!(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-8-truncate"><a href="#5-8-truncate" class="headerlink" title="5.8 truncate"></a>5.8 truncate</h1><ul>
<li>删除字符串中从指定位置开始到结尾的全部字符</li>
<li>方法是按照字节来处理字符串的，如果参数所给的位置不是合法的字符边界，则会发生错误</li>
<li>该方法是直接操作原来的字符串<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;测试truncate&quot;);</span><br><span class="line">    s.truncate(3);</span><br><span class="line">    dbg!(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="5-9-clear"><a href="#5-9-clear" class="headerlink" title="5.9 clear"></a>5.9 clear</h1><ul>
<li>清空字符串</li>
<li>该方法是直接操作原来的字符串<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;string clear&quot;);</span><br><span class="line"></span><br><span class="line">    s.clear();</span><br><span class="line"></span><br><span class="line">    dbg!(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="5-10-使用-或者-连接字符串"><a href="#5-10-使用-或者-连接字符串" class="headerlink" title="5.10 使用+或者+&#x3D;连接字符串"></a>5.10 使用+或者+&#x3D;连接字符串</h1><ul>
<li>这里add()方法的第二个参数必须为字符串的切片引用(Slice)类型</li>
<li>+ 这里是返回一个新的字符串，所以变量声明可以不需要mut关键字修饰<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;hello &quot;);</span><br><span class="line">    let string_rust = String::from(&quot;rust&quot;);</span><br><span class="line"></span><br><span class="line">    let result = s + &amp;string_rust;//string_rust会自动解引用为&amp;str</span><br><span class="line">    let mut result1 = result + &quot;!&quot;;</span><br><span class="line"></span><br><span class="line">    result1 += &quot;!!!&quot;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;连接字符串 + =》 &#123;&#125;&quot;, result1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use std::ops::Add;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;hello &quot;);</span><br><span class="line">    let string_rust = String::from(&quot;rust&quot;);</span><br><span class="line"></span><br><span class="line">    let result = s.add(&amp;string_rust);//</span><br><span class="line"></span><br><span class="line">    println!(&quot;连接字符串 + =》 &#123;&#125;&quot;, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-11-使用format-连接字符串"><a href="#5-11-使用format-连接字符串" class="headerlink" title="5.11 使用format! 连接字符串"></a>5.11 使用format! 连接字符串</h1><ul>
<li>format!的用法与print!用法类似<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = &quot;hello&quot;;</span><br><span class="line">    let s2 = String::from(&quot;rust&quot;);</span><br><span class="line">    let s = format!(&quot;&#123;&#125; &#123;&#125;&quot;, s1, s2);</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="6-字符串转义"><a href="#6-字符串转义" class="headerlink" title="6 字符串转义"></a>6 字符串转义</h1><p>我们可以通过转义的方式 \ 输出ASCII和Unicode字符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    //通过 \ + 字符的十六进制表示 转义输出一个字符</span><br><span class="line">    let byte_escape = &quot;I&#x27;m writing \x52\x75\x73\x74&quot;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;What are you doing\x3F (\\x3f means ?) &#123;&#125;&quot;, byte_escape);</span><br><span class="line"></span><br><span class="line">    //\u可以输出一个unicoe字符</span><br><span class="line">    let unicode_codepoint = &quot;\u&#123;211D&#125;&quot;;</span><br><span class="line">    let character_name = &quot;\&quot;DOUBLE-STRUCK CAPITAL R\&quot;&quot;;</span><br><span class="line"></span><br><span class="line">    println!(</span><br><span class="line">        &quot;Unicode character &#123;&#125; (U+211D) is called &#123;&#125;&quot;,</span><br><span class="line">        unicode_codepoint, character_name</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    //换行了也会保持之前的字符串格式</span><br><span class="line">    //使用\忽略换行符</span><br><span class="line">    let long_string = &quot;String literals </span><br><span class="line">                              can span multiple lines.</span><br><span class="line">                              The linebreak and  indentation here -&gt;\</span><br><span class="line">                              &lt;- can be escaped too!&quot;;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, long_string);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-原样输出"><a href="#7-原样输出" class="headerlink" title="7 原样输出"></a>7 原样输出</h1><p>当然，在某些情况下，可能你会希望保持字符串的原样，不要转义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, &quot;hello \x52\x75\x73\x74&quot;);</span><br><span class="line"></span><br><span class="line">    //通过 \ + 字符的十六进制表示 转义输出一个字符</span><br><span class="line">    let raw_str = r&quot;Escapes don&#x27;t work here:\x3F \u&#123;211D&#125;&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, raw_str);  </span><br><span class="line"></span><br><span class="line">    //如果字符串包含双引号，可以在开头和结尾加 #</span><br><span class="line">    let quates = r#&quot;And then I said:&quot;There is no escape!&quot;&quot;#;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, quates); </span><br><span class="line"></span><br><span class="line">    //如果还是有歧义 可以接续添加 没有限制</span><br><span class="line"></span><br><span class="line">    let longer_delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, longer_delimiter); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/25/learnRust8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Byte的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/25/learnRust8/" itemprop="url">Rust入门-基础 第八节 数组与切片</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-08-25T18:33:44+08:00">
                2024-08-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-数组切片介绍"><a href="#1-数组切片介绍" class="headerlink" title="1.数组切片介绍"></a>1.数组切片介绍</h1><ul>
<li>类型 [T;N] 表示N个值的数组,每个值的类型为T。数组的大小是在编译期就已确定的常量，并且是类型的一部分，不能追加新元素或者缩小数组。</li>
<li>类型 &amp;[T] 和 &amp;mut[T] 可称为T的共享切片和T的可变切片，它们是对一系列元素的引用，这些元素是某个其他值（比如数组或向量）的一部分。可以将切片视为指向其第一个元素的指针，以及从该点开始允许访问的元素数量的计数。可变切片 &amp;mut[T] 允许读取元素和修改元素，但不能共享；共享切片&amp;[T]允许在多个读取者之间共享访问权限,但不允许修改元素。</li>
</ul>
<p>类型中任意一种类型的值v，表达式v.len()都会给出v中的元素数，而 v[i]引用的是v的第i个元素。v的第一个元素是v[0]，最后一个元素是v[v.len()-1]。Rust 总是会检查i是否在这个范围内，如果没在，则此表达式会出现panic。v的长度可能为0，在这种情况下，任何对其进行索引的尝试都会出现 panic。i的类型必须是usize，不能使用任何其他整型作为索引。</p>
<ul>
<li>数组的定义其实航是为分配一段连续的相同数据类型的内存块。</li>
<li>数组是静态的。这意味着一旦定义和初始化，则永远不可更改它的长度。</li>
<li>数组的元系有着相同的数据类型，每一个元素都独占者改据类型大小的内存块，也就是说。数组的内存大小等于数组的长度乘以数组的数据类型。</li>
<li>数组中的每一个元素都按照顺序依次存储，这个顺序号既代表着元素的存储位置，也是数组元素的唯一标识。我们把这个标识称之为数组下标。注意，数姐下标从 0 开始。</li>
<li>填充数组中的每一个元素的过程称为数组初始化。也就是说数组初始化就是为数组中的每一个元素赋值。</li>
<li>可以更新或修改数组元素的值，但不能删除数组元素。如果要删除功能，你可以将它的值赋值为 0 或其它表示删除的值。</li>
</ul>
<p>这里再啰嗦一句，我们这里说的数组是 Rust 的基本类型，是固定长度的，这点与其他编程语言不同，其它编程语言的数组往往是可变长度的，与 Rust 中的动态数组 Vector 类似，希望读者大大牢记此点。</p>
<h1 id="2-创建数组"><a href="#2-创建数组" class="headerlink" title="2.创建数组"></a>2.创建数组</h1><p>在 Rust 中，数组是这样定义的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a = [1, 2, 3, 4, 5];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组语法跟 JavaScript 很像，也跟大多数编程语言很像。由于它的元素类型大小固定，且长度也是固定，因此数组 array 是存储在栈上，性能也会非常优秀。与此对应，动态数组 Vector 是存储在堆上，因此长度可以动态改变。当你不确定是使用数组还是动态数组时，那就应该使用后者，具体见动态数组 Vector。</p>
<p>举个例子，在需要知道一年中各个月份名称的程序中，你很可能希望使用的是数组而不是动态数组。因为月份是固定的，它总是只包含 12 个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,</span><br><span class="line">              &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在一些时候，还需要为数组声明类型，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let a: [i32; 5] = [1, 2, 3, 4, 5];</span><br></pre></td></tr></table></figure>
<p>这里，数组类型是通过方括号语法声明，i32 是元素类型，分号后面的数字 5 是数组长度，数组类型也从侧面说明了数组的元素类型要统一，长度要固定。</p>
<p>还可以使用下面的语法初始化一个某个值重复出现 N 次的数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let a = [3; 5];</span><br></pre></td></tr></table></figure>
<p>a 数组包含 5 个元素，这些元素的初始化值为 3，聪明的读者已经发现，这种语法跟数组类型的声明语法其实是保持一致的：[3; 5] 和 [类型; 长度]。</p>
<p>在元素重复的场景，这种写法要简单的多，否则你就得疯狂敲击键盘：let a &#x3D; [3, 3, 3, 3, 3];，不过老板可能很喜欢你的这种疯狂编程的状态。</p>
<p>访问数组元素<br>因为数组是连续存放元素的，因此可以通过索引的方式来访问存放其中的元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a = [9, 8, 7, 6, 5];</span><br><span class="line"></span><br><span class="line">    let first = a[0]; // 获取a数组第一个元素</span><br><span class="line">    let second = a[1]; // 获取第二个元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与许多语言类似，数组的索引下标是从 0 开始的。此处，first 获取到的值是 9，second 是 8。</p>
<h1 id="3-越界访问"><a href="#3-越界访问" class="headerlink" title="3.越界访问"></a>3.越界访问</h1><p>如果使用超出数组范围的索引访问数组元素，会怎么样？下面是一个接收用户的控制台输入，然后将其作为索引访问数组元素的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">use std::io;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let a = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">    println!(&quot;Please enter an array index.&quot;);</span><br><span class="line"></span><br><span class="line">    let mut index = String::new();</span><br><span class="line">    // 读取控制台的输出</span><br><span class="line">    io::stdin()</span><br><span class="line">        .read_line(&amp;mut index)</span><br><span class="line">        .expect(&quot;Failed to read line&quot;);</span><br><span class="line"></span><br><span class="line">    let index: usize = index</span><br><span class="line">        .trim()</span><br><span class="line">        .parse()</span><br><span class="line">        .expect(&quot;Index entered was not a number&quot;);</span><br><span class="line"></span><br><span class="line">    let element = a[index];</span><br><span class="line"></span><br><span class="line">    println!(</span><br><span class="line">        &quot;The value of the element at index &#123;&#125; is: &#123;&#125;&quot;,</span><br><span class="line">        index, element</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 cargo run 来运行代码，因为数组只有 5 个元素，如果我们试图输入 5 去访问第 6 个元素，则会访问到不存在的数组元素，最终程序会崩溃退出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Please enter an array index.</span><br><span class="line">5</span><br><span class="line">thread &#x27;main&#x27; panicked at &#x27;index out of bounds: the len is 5 but the index is 5&#x27;, src/main.rs:19:19</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br></pre></td></tr></table></figure>
<p>这就是数组访问越界，访问了数组中不存在的元素，导致 Rust 运行时错误。程序因此退出并显示错误消息，未执行最后的 println! 语句。</p>
<p>当你尝试使用索引访问元素时，Rust 将检查你指定的索引是否小于数组长度。如果索引大于或等于数组长度，Rust 会出现 panic。这种检查只能在运行时进行，比如在上面这种情况下，编译器无法在编译期知道用户运行代码时将输入什么值。</p>
<p>这种就是 Rust 的安全特性之一。在很多系统编程语言中，并不会检查数组越界问题，你会访问到无效的内存地址获取到一个风马牛不相及的值，最终导致在程序逻辑上出现大问题，而且这种问题会非常难以检查。</p>
<h1 id="4-数组元素为非基础类型"><a href="#4-数组元素为非基础类型" class="headerlink" title="4.数组元素为非基础类型"></a>4.数组元素为非基础类型</h1><p>学习了上面的知识，很多朋友肯定觉得已经学会了Rust的数组类型，但现实会给我们一记重锤，实际开发中还会碰到一种情况，就是数组元素是非基本类型的，这时候大家一定会这样写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let array = [String::from(&quot;rust is good!&quot;); 8];</span><br><span class="line"></span><br><span class="line">println!(&quot;&#123;:#?&#125;&quot;, array);</span><br></pre></td></tr></table></figure>
<p>然后你会惊喜的得到编译错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: the trait bound `String: std::marker::Copy` is not satisfied</span><br><span class="line"> --&gt; src/main.rs:7:18</span><br><span class="line">  |</span><br><span class="line">7 |     let array = [String::from(&quot;rust is good!&quot;); 8];</span><br><span class="line">  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `String`</span><br><span class="line">  |</span><br><span class="line">  = note: the `Copy` trait is required because this value will be copied for each element of the array</span><br></pre></td></tr></table></figure>
<p>有些还没有看过特征的小伙伴，有可能不太明白这个报错，不过这个目前可以不提，我们就拿之前所学的所有权知识，就可以思考明白，前面几个例子都是Rust的基本类型，而<strong>基本类型在Rust中赋值是以Copy的形式</strong>，这时候你就懂了吧，let array&#x3D;[3;5]底层就是不断的Copy出来的，但很可惜复杂类型都没有深拷贝，只能一个个创建。</p>
<p>接着就有小伙伴会这样写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let array = [String::from(&quot;rust is good!&quot;),String::from(&quot;rust is good!&quot;),String::from(&quot;rust is good!&quot;)];</span><br><span class="line"></span><br><span class="line">println!(&quot;&#123;:#?&#125;&quot;, array);</span><br></pre></td></tr></table></figure>
<p>作为一个追求极致完美的Rust开发者，怎么能容忍上面这么难看的代码存在！</p>
<p><strong>正确的写法</strong>，应该调用std::array::from_fn</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let array: [String; 8] = std::array::from_fn(|_i| String::from(&quot;rust is good!&quot;));</span><br><span class="line"></span><br><span class="line">println!(&quot;&#123;:#?&#125;&quot;, array);</span><br></pre></td></tr></table></figure>

<h1 id="5-数组切片"><a href="#5-数组切片" class="headerlink" title="5.数组切片"></a>5.数组切片</h1><p>在之前的章节，我们有讲到 切片 这个概念，它允许你引用集合中的部分连续片段，而不是整个集合，对于数组也是，数组切片允许我们引用数组的一部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a: [i32; 5] = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">let slice: &amp;[i32] = &amp;a[1..3];</span><br><span class="line"></span><br><span class="line">assert_eq!(slice, &amp;[2, 3]);</span><br></pre></td></tr></table></figure>
<p>上面的数组切片 slice 的类型是&amp;[i32]，与之对比，数组的类型是[i32;5]，简单总结下切片的特点：</p>
<ul>
<li>切片的长度可以与数组不同，并不是固定的，而是取决于你使用时指定的起始和结束位置</li>
<li>创建切片的代价非常小，因为切片只是针对底层数组的一个引用</li>
<li>切片类型[T]拥有不固定的大小，而切片引用类型&amp;[T]则具有固定的大小，因为 Rust 很多时候都需要固定大小数据类型，因此&amp;[T]更有用,&amp;str字符串切片也同理</li>
</ul>
<h1 id="6-数组实例"><a href="#6-数组实例" class="headerlink" title="6.数组实例"></a>6.数组实例</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn arr() &#123;</span><br><span class="line">    let arr = [10,20,30,40];</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, arr);</span><br><span class="line">    arr.iter().for_each(|value:&amp;i32|println!(&quot;&#123;:?&#125;&quot;, value));</span><br><span class="line">    for value in arr.iter() &#123;</span><br><span class="line">        println!(&quot;&#123;:?&#125;&quot;, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    arr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    //arr();</span><br><span class="line">    let arr = [10,20,30,40];</span><br><span class="line">    let mut arr_mut = [10,20,30,40];</span><br><span class="line">    println!(&quot;before : &#123;:?&#125;&quot;, arr_mut);</span><br><span class="line">    arr_mut[0] = 0;</span><br><span class="line">    println!(&quot;after : &#123;:?&#125;&quot;, arr_mut);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fn update(mut arr:[i32;3]) &#123;</span><br><span class="line">    println!(&quot;update before : &#123;:?&#125;&quot;, arr);</span><br><span class="line">    for i in 0..3 &#123;</span><br><span class="line">        arr[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;update after : &#123;:?&#125;&quot;, arr);</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    //arr();</span><br><span class="line">    let arr = [10,20,30];</span><br><span class="line">    println!(&quot;main before : &#123;:?&#125;&quot;, arr);</span><br><span class="line">    update(arr);</span><br><span class="line">    println!(&quot;main after : &#123;:?&#125;&quot;, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fn update_mut(arr:&amp;mut [i32;3]) &#123;</span><br><span class="line">    println!(&quot;update before : &#123;:?&#125;&quot;, arr);</span><br><span class="line">    for i in 0..3 &#123;</span><br><span class="line">        arr[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;update after : &#123;:?&#125;&quot;, arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    //arr();</span><br><span class="line">    let mut arr = [10,20,30];</span><br><span class="line">    println!(&quot;main before : &#123;:?&#125;&quot;, arr);</span><br><span class="line">    update_mut(&amp;mut arr);</span><br><span class="line">    println!(&quot;main after : &#123;:?&#125;&quot;, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  // 编译器自动推导出one的类型</span><br><span class="line">  let one             = [1, 2, 3];</span><br><span class="line">  // 显式类型标注</span><br><span class="line">  let two: [u8; 3]    = [1, 2, 3];</span><br><span class="line">  let blank1          = [0; 3];</span><br><span class="line">  let blank2: [u8; 3] = [0; 3];</span><br><span class="line"></span><br><span class="line">  // arrays是一个二维数组，其中每一个元素都是一个数组，元素类型是[u8; 3]</span><br><span class="line">  let arrays: [[u8; 3]; 4]  = [one, two, blank1, blank2];</span><br><span class="line"></span><br><span class="line">  // 借用arrays的元素用作循环中</span><br><span class="line">  for a in &amp;arrays &#123;</span><br><span class="line">    print!(&quot;&#123;:?&#125;: &quot;, a);</span><br><span class="line">    // 将a变成一个迭代器，用于循环</span><br><span class="line">    // 你也可以直接用for n in a &#123;&#125;来进行循环</span><br><span class="line">    for n in a.iter() &#123;</span><br><span class="line">      print!(&quot;\t&#123;&#125; + 10 = &#123;&#125;&quot;, n, n+10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let mut sum = 0;</span><br><span class="line">    // 0..a.len,是一个 Rust 的语法糖，其实就等于一个数组，元素是从0,1,2一直增加到到a.len-1</span><br><span class="line">    for i in 0..a.len() &#123;</span><br><span class="line">      sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;\t(&#123;:?&#125; = &#123;&#125;)&quot;, a, sum);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做个总结，数组虽然很简单，但是其实还是存在几个要注意的点：</p>
<ul>
<li>数组类型容易跟数组切片混淆，[T;n]描述了一个数组的类型，而[T]描述了切片的类型， 因为切片是运行期的数据结构，它的长度无法在编译期得知，因此不能用[T;n]的形式去描述<br>[u8; 3]和[u8; 4]是不同的类型，数组的长度也是类型的一部分</li>
<li>在实际开发中，使用最多的是数组切片[T]，我们往往通过引用的方式去使用&amp;[T]，因为后者有固定的类型大小</li>
</ul>
<h1 id="7-切片-Slice"><a href="#7-切片-Slice" class="headerlink" title="7.切片(Slice)"></a>7.切片(Slice)</h1><p>Slice类型通常翻译为切片，它表示从某个包含多个元素的容器中取得局部数据，这个过程称为切片操作。不同语言对切片的支持有所不同，比如有些语言只允许取得连续的局部元素，而有些语言可以取得离散元素，甚至有些语言可以对hash结构进行切片操作。<br>Rust也支持Slice操作，Rust中的切片操作只允许获取一段连续的局部数据切片操作获取到的数据称为切片效据。<br>Rust常见的数据类型中，有三种类型已支持Slice操作:String类型、Array类型和Vec类型</p>
<p>这个slice变量的类型是&amp;[i32], 通过存储第一个集合元素的引用和一个集合总长度。你可以对其他所有的集合使用这类slice。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = [1,2,3,4,5];</span><br><span class="line">let slice = &amp;a[1..3];</span><br><span class="line">let mut_lice = &amp;mut a[1..3];</span><br></pre></td></tr></table></figure>

<h1 id="7-1-切片常用函数"><a href="#7-1-切片常用函数" class="headerlink" title="7.1 切片常用函数"></a>7.1 切片常用函数</h1><p>*len():取slice元索个数<br>*is_empty():判断slice是否为空<br>*contains():判断是否包含某个元素<br>*repeat():重复slice指定次数<br>*reverse():反转slice<br>*join():将各元素压平(flatten)并通过指定的分隔符连接起来<br>*swarp():交换两个索引处的元素，如s.swap(1,3)<br>*windows():以指定大小的窗口进行滚动选代<br>*starts_wlth():判断slice是否以某个slice开头</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fn slice_show() &#123;</span><br><span class="line">    let arr = [1,2,3,4,5,6,7,8,9,10];</span><br><span class="line">    for i in arr.windows(3) &#123;</span><br><span class="line">        println!(&quot;windows is : &#123;:?&#125;&quot;, i); </span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, arr.starts_with(&amp;[10]));</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, arr.starts_with(&amp;[1]));</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, arr.starts_with(&amp;[1,2,3]));</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, arr.starts_with(&amp;[1,2,3,5]));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    slice_show();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-练习题"><a href="#8-练习题" class="headerlink" title="8.练习题"></a>8.练习题</h1><p>1. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // 使用合适的类型填空</span><br><span class="line">    let arr: __ = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">    // 修改以下代码，让它顺利运行</span><br><span class="line">    assert!(arr.len() == 4);</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    // 使用合适的类型填空</span><br><span class="line">    let arr:[i32;5] = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">    // 修改以下代码，让它顺利运行</span><br><span class="line">    assert!(arr.len() == 4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // 很多时候，我们可以忽略数组的部分类型，也可以忽略全部类型，让编译器帮助我们推导</span><br><span class="line">    let arr0 = [1, 2, 3];</span><br><span class="line">    let arr: [_; 3] = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];</span><br><span class="line">    </span><br><span class="line">    // 填空</span><br><span class="line">    // 数组分配在栈上， `std::mem::size_of_val` 函数会返回整个数组占用的内存空间</span><br><span class="line">    // 数组中的每个 char 元素占用 4 字节的内存空间，因为在 Rust 中， char 是 Unicode 字符</span><br><span class="line">    assert!(std::mem::size_of_val(&amp;arr) == __);</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    // 很多时候，我们可以忽略数组的部分类型，也可以忽略全部类型，让编译器帮助我们推导</span><br><span class="line">    let arr0 = [1, 2, 3];</span><br><span class="line">    let arr: [_; 3] = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];</span><br><span class="line">    </span><br><span class="line">    // 填空</span><br><span class="line">    // 数组分配在栈上， `std::mem::size_of_val` 函数会返回整个数组占用的内存空间</span><br><span class="line">    // 数组中的每个 char 元素占用 4 字节的内存空间，因为在 Rust 中， char 是 Unicode 字符</span><br><span class="line">    assert!(std::mem::size_of_val(&amp;arr) == 12);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // 填空</span><br><span class="line">    let list: [i32; 100] = __ ;</span><br><span class="line"></span><br><span class="line">    assert!(list[0] == 1);</span><br><span class="line">    assert!(list.len() == 100);</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    // 填空</span><br><span class="line">    let list: [i32; 100] = [1;100] ;</span><br><span class="line"></span><br><span class="line">    assert!(list[0] == 1);</span><br><span class="line">    assert!(list.len() == 100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // 修复错误</span><br><span class="line">    let _arr = [1, 2, &#x27;3&#x27;];</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    // 修复错误</span><br><span class="line">    let _arr = [1, 2, 3];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];</span><br><span class="line">    </span><br><span class="line">    let ele = arr[1]; // 只修改此行来让代码工作</span><br><span class="line"></span><br><span class="line">    assert!(ele == &#x27;a&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];</span><br><span class="line">    </span><br><span class="line">    let ele = arr[0]; // 只修改此行来让代码工作</span><br><span class="line"></span><br><span class="line">    assert!(ele == &#x27;a&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 修复代码中的错误</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let names = [String::from(&quot;Sunfei&quot;), &quot;Sunface&quot;.to_string()];</span><br><span class="line">    </span><br><span class="line">    // `get` 返回 `Option&lt;T&gt;` 类型，因此它的使用非常安全</span><br><span class="line">    let name0 = names.get(0).unwrap();</span><br><span class="line"></span><br><span class="line">    // 但是下标索引就存在越界的风险了</span><br><span class="line">    let _name1 = &amp;names[2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修复代码中的错误</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let names = [String::from(&quot;Sunfei&quot;), &quot;Sunface&quot;.to_string()];</span><br><span class="line">    </span><br><span class="line">    // `get` 返回 `Option&lt;T&gt;` 类型，因此它的使用非常安全</span><br><span class="line">    let name0 = names.get(0).unwrap();</span><br><span class="line"></span><br><span class="line">    // 但是下标索引就存在越界的风险了</span><br><span class="line">    let _name1 = &amp;names[1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/22/learnRust7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Byte的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/22/learnRust7/" itemprop="url">Rust入门-基础 第七节 引用与借用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-08-22T22:57:27+08:00">
                2024-08-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上节中提到，如果仅仅支持通过转移所有权的方式获取一个值，那会让程序变得复杂。 Rust 能否像其它编程语言一样，使用某个变量的指针或者引用呢？答案是可以。</p>
<p>Rust 通过 借用(Borrowing) 这个概念来达成上述的目的，获取变量的引用，称之为借用(borrowing)。正如现实生活中，如果一个人拥有某样东西，你可以从他那里借来，当使用完毕后，也必须要物归原主。</p>
<ul>
<li><strong>不可变引用(Immutable Reference)</strong>:通过不可变引用,可以读取数据,但不能修改数据.一个变量可以有多个不可变引用,但不能与可变引用共存.</li>
<li><strong>可变引用(Mutable Reference)</strong>:通过可变引用,可以读取和修改数据.一个变量在某一时刻只能有一个可变引用,且不能与不可变引用共存.</li>
</ul>
<p><strong>move&amp;borrowing&amp;referencing</strong></p>
<ul>
<li>move堆数据所有权</li>
<li>borrowing 函数</li>
<li>referencing 变量</li>
</ul>
<h1 id="1-引用与解引用"><a href="#1-引用与解引用" class="headerlink" title="1.引用与解引用"></a>1.引用与解引用</h1><p>常规引用是一个指针类型，指向了对象存储的内存地址。在下面代码中，我们创建一个 i32 值的引用 y，然后使用解引用运算符来解出 y 所使用的值:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = 5;</span><br><span class="line">    let y = &amp;x;</span><br><span class="line"></span><br><span class="line">    assert_eq!(5, x);</span><br><span class="line">    assert_eq!(5, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量 x 存放了一个 i32 值 5。y 是 x 的一个引用。可以断言 x 等于 5。然而，如果希望对 y 的值做出断言，必须使用 *y 来解出引用所指向的值（也就是解引用）。一旦解引用了 y，就可以访问 y 所指向的整型值并可以与 5 做比较。</p>
<p>相反如果尝试编写 assert_eq!(5, y);，则会得到如下编译错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   Compiling world_hello v0.1.0 (D:\rust\world_hello)</span><br><span class="line">error[E0277]: can&#x27;t compare `&#123;integer&#125;` with `&amp;&#123;integer&#125;`</span><br><span class="line"> --&gt; src/main.rs:6:5</span><br><span class="line">  |</span><br><span class="line">6 |     assert_eq!(5, y);</span><br><span class="line">  |     ^^^^^^^^^^^^^^^^ no implementation for `&#123;integer&#125; == &amp;&#123;integer&#125;`</span><br><span class="line">  |</span><br><span class="line">  = help: the trait `PartialEq&lt;&amp;&#123;integer&#125;&gt;` is not implemented for `&#123;integer&#125;`</span><br><span class="line">  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)</span><br><span class="line">help: consider dereferencing here</span><br><span class="line"> --&gt; C:\Users\Administrator\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\macros\mod.rs:40:35</span><br><span class="line">  |</span><br><span class="line">40|                 if !(*left_val == **right_val) &#123;</span><br><span class="line">  |                                   +</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0277`.</span><br></pre></td></tr></table></figure>
<p>不允许比较整数与引用，因为它们是不同的类型。必须使用解引用运算符解出引用所指向的值。</p>
<p>不可变引用<br>下面的代码，我们用 s1 的引用作为参数传递给 calculate_length 函数，而不是把 s1 的所有权转移给该函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    let len = calculate_length(&amp;s1);</span><br><span class="line"></span><br><span class="line">    println!(&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn calculate_length(s: &amp;String) -&gt; usize &#123;</span><br><span class="line">    s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能注意到两点：</p>
<ol>
<li>无需像上章一样：先通过函数参数传入所有权，然后再通过函数返回来传出所有权，代码更加简洁</li>
<li>calculate_length 的参数 s 类型从 String 变为 &amp;String<br>这里，&amp; 符号即是引用，它们允许你使用值，但是不获取所有权，如图所示：<br><img src="/../images/Borrowing.png"><br>通过 &amp;s1 语法，我们创建了一个指向 s1 的引用，但是并不拥有它。因为并不拥有这个值，当引用离开作用域后，其指向的值也不会被丢弃。</li>
</ol>
<p>同理，函数 calculate_length 使用 &amp; 来表明参数 s 的类型是一个引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn calculate_length(s: &amp;String) -&gt; usize &#123; // s 是对 String 的引用</span><br><span class="line">    s.len()</span><br><span class="line">&#125; // 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，</span><br><span class="line">  // 所以什么也不会发生</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>人总是贪心的，可以拉女孩小手了，就想着抱抱柔软的身子（读者中的某老司机表示，这个流程完全不对），因此光借用已经满足不了我们了，如果尝试修改借用的变量呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    change(&amp;s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn change(some_string: &amp;String) &#123;</span><br><span class="line">    some_string.push_str(&quot;, world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很不幸，妹子你没抱到，哦口误，你修改错了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference</span><br><span class="line"> --&gt; src/main.rs:8:5</span><br><span class="line">  |</span><br><span class="line">8 |     some_string.push_str(&quot;, world&quot;);</span><br><span class="line">  |     ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable</span><br><span class="line">  |</span><br><span class="line">help: consider changing this to be a mutable reference</span><br><span class="line">  |</span><br><span class="line">7 | fn change(some_string: &amp;mut String) &#123;</span><br><span class="line">  |                         +++</span><br><span class="line"></span><br><span class="line">error: aborting due to 1 previous error</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0596`.</span><br></pre></td></tr></table></figure>
<p>正如变量默认不可变一样，引用指向的值默认也是不可变的，没事，来一起看看如何解决这个问题。</p>
<h1 id="2-可变引用"><a href="#2-可变引用" class="headerlink" title="2.可变引用"></a>2.可变引用</h1><p>只需要一个小调整，即可修复上面代码的错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    change(&amp;mut s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn change(some_string: &amp;mut String) &#123;</span><br><span class="line">    some_string.push_str(&quot;, world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，声明 s 是可变类型，其次创建一个可变的引用 &amp;mut s 和接受可变引用参数 some_string: &amp;mut String 的函数。<br><strong>可变引用同时只能存在一个</strong><br>不过可变引用并不是随心所欲、想用就用的，它有一个很大的限制： 同一作用域，特定数据只能有一个可变引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let mut s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">let r1 = &amp;mut s;</span><br><span class="line">let r2 = &amp;mut s;</span><br><span class="line"></span><br><span class="line">println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);</span><br></pre></td></tr></table></figure>
<p>以上代码会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">error[E0499]: cannot borrow `s` as mutable more than once at a time</span><br><span class="line"> --&gt; src/main.rs:5:14</span><br><span class="line">  |</span><br><span class="line">4 |     let r1 = &amp;mut s;</span><br><span class="line">  |              ------ first mutable borrow occurs here</span><br><span class="line">5 |     let r2 = &amp;mut s;</span><br><span class="line">  |              ^^^^^^ second mutable borrow occurs here</span><br><span class="line">6 |     </span><br><span class="line">7 |     println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);</span><br><span class="line">  |                        -- first borrow later used here</span><br><span class="line"></span><br><span class="line">error: aborting due to 1 previous error</span><br></pre></td></tr></table></figure>
<p>这段代码出错的原因在于，第一个可变借用 r1 必须要持续到最后一次使用的位置 println!，在 r1 创建和最后一次使用之间，我们又尝试创建第二个可变借用 r2。</p>
<p>对于新手来说，这个特性绝对是一大拦路虎，也是新人们谈之色变的编译器 borrow checker 特性之一，不过各行各业都一样，限制往往是出于安全的考虑，Rust 也一样。</p>
<p>这种限制的好处就是使 Rust 在编译期就避免数据竞争，数据竞争可由以下行为造成：</p>
<ul>
<li>两个或更多的指针同时访问同一数据</li>
<li>至少有一个指针被用来写入数据</li>
<li>没有同步数据访问的机制<br>数据竞争会导致未定义行为，这种行为很可能超出我们的预期，难以在运行时追踪，并且难以诊断和修复。而 Rust 避免了这种情况的发生，因为它甚至不会编译存在数据竞争的代码！</li>
</ul>
<p>很多时候，大括号可以帮我们解决一些编译不通过的问题，通过手动限制变量的作用域：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let mut s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    let r1 = &amp;mut s;</span><br><span class="line"></span><br><span class="line">&#125; // r1 在这里离开了作用域，所以我们完全可以创建一个新的引用</span><br><span class="line"></span><br><span class="line">let r2 = &amp;mut s;</span><br></pre></td></tr></table></figure>
<p><strong>可变引用与不可变引用不能同时存在</strong><br>下面的代码会导致一个错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let mut s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">let r1 = &amp;s; // 没问题</span><br><span class="line">let r2 = &amp;s; // 没问题</span><br><span class="line">let r3 = &amp;mut s; // 大问题</span><br><span class="line"></span><br><span class="line">println!(&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;, r1, r2, r3);</span><br></pre></td></tr></table></figure>
<p>错误如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable</span><br><span class="line"> --&gt; src/main.rs:6:14</span><br><span class="line">  |</span><br><span class="line">4 |     let r1 = &amp;s; // 没问题</span><br><span class="line">  |              -- immutable borrow occurs here</span><br><span class="line">5 |     let r2 = &amp;s; // 没问题</span><br><span class="line">6 |     let r3 = &amp;mut s; // 大问题</span><br><span class="line">  |              ^^^^^^ mutable borrow occurs here</span><br><span class="line">7 |     </span><br><span class="line">8 |     println!(&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;, r1, r2, r3);</span><br><span class="line">  |                                -- immutable borrow later used here</span><br><span class="line"></span><br><span class="line">error: aborting due to 1 previous error</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0502`.</span><br></pre></td></tr></table></figure>
<p>其实这个也很好理解，正在借用不可变引用的用户，肯定不希望他借用的东西，被另外一个人莫名其妙改变了。多个不可变借用被允许是因为没有人会去试图修改数据，每个人都只读这一份数据而不做修改，因此不用担心数据被污染。</p>
<table>
    <tr>
        <td bgcolor=#F0F8FF>
            注意，引用的作用域 s 从创建开始，一直持续到它最后一次使用的地方，这个跟变量的作用域有所不同，变量的作用域从创建持续到某一个花括号 }
        </td>
    </tr>
</table>

<p>Rust 的编译器一直在优化，早期的时候，引用的作用域跟变量作用域是一致的，这对日常使用带来了很大的困扰，你必须非常小心的去安排可变、不可变变量的借用，免得无法通过编译，例如以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">   let mut s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    let r1 = &amp;s;</span><br><span class="line">    let r2 = &amp;s;</span><br><span class="line">    println!(&quot;&#123;&#125; and &#123;&#125;&quot;, r1, r2);</span><br><span class="line">    // 新编译器中，r1,r2作用域在这里结束</span><br><span class="line"></span><br><span class="line">    let r3 = &amp;mut s;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, r3);</span><br><span class="line">&#125; // 老编译器中，r1、r2、r3作用域在这里结束</span><br><span class="line">  // 新编译器中，r3作用域在这里结束</span><br></pre></td></tr></table></figure>
<p>在老版本的编译器中（Rust 1.31 前），将会报错，因为 r1 和 r2 的作用域在花括号 } 处结束，那么 r3 的借用就会触发 <strong>无法同时借用可变和不可变</strong>的规则。<br>但是在新的编译器中，该代码将顺利通过，因为 引用作用域的结束位置从花括号变成最后一次使用的位置，因此 r1 借用和 r2 借用在 println! 后，就结束了，此时 r3 可以顺利借用到可变引用。</p>
<h1 id="3-NULL"><a href="#3-NULL" class="headerlink" title="3.NULL"></a>3.NULL</h1><p>对于这种编译器优化行为，Rust 专门起了一个名字 —— Non-Lexical Lifetimes(NLL)，专门用于找到某个引用在作用域(})结束前就不再被使用的代码位置。</p>
<p>虽然这种借用错误有的时候会让我们很郁闷，但是你只要想想这是 Rust 提前帮你发现了潜在的 BUG，其实就开心了，虽然减慢了开发速度，但是从长期来看，大幅减少了后续开发和运维成本。</p>
<h1 id="4-悬垂引用-Dangling-References"><a href="#4-悬垂引用-Dangling-References" class="headerlink" title="4.悬垂引用(Dangling References)"></a>4.悬垂引用(Dangling References)</h1><p>悬垂引用也叫做悬垂指针，意思为指针指向某个值后，这个值被释放掉了，而指针仍然存在，其指向的内存可能不存在任何值或已被其它变量重新使用。在 Rust 中编译器可以确保引用永远也不会变成悬垂状态：当你获取数据的引用后，编译器可以确保数据不会在引用结束前被释放，要想释放数据，必须先停止其引用的使用。</p>
<p>让我们尝试创建一个悬垂引用，Rust 会抛出一个编译时错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let reference_to_nothing = dangle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn dangle() -&gt; &amp;String &#123;</span><br><span class="line">    let s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    &amp;s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> --&gt; src/main.rs:5:16</span><br><span class="line">  |</span><br><span class="line">5 | fn dangle() -&gt; &amp;String &#123;</span><br><span class="line">  |                ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">  = help: this function&#x27;s return type contains a borrowed value, but there is no value for it to be borrowed from</span><br><span class="line">help: consider using the `&#x27;static` lifetime, but this is uncommon unless you&#x27;re returning a borrowed value from a `const` or a `static`</span><br><span class="line">  |</span><br><span class="line">5 | fn dangle() -&gt; &amp;&#x27;static String &#123;</span><br><span class="line">  |                 +++++++</span><br><span class="line">help: instead, you are more likely to want to return an owned value</span><br><span class="line">  |</span><br><span class="line">5 - fn dangle() -&gt; &amp;String &#123;</span><br><span class="line">5 + fn dangle() -&gt; String &#123;</span><br><span class="line">  |</span><br><span class="line"></span><br><span class="line">warning: unused variable: `reference_to_nothing`</span><br><span class="line"> --&gt; src/main.rs:2:9</span><br><span class="line">  |</span><br><span class="line">2 |     let reference_to_nothing = dangle();</span><br><span class="line">  |         ^^^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_reference_to_nothing`</span><br><span class="line">  |</span><br><span class="line">  = note: `#[warn(unused_variables)]` on by default</span><br><span class="line"></span><br><span class="line">error[E0515]: cannot return reference to local variable `s`</span><br><span class="line"> --&gt; src/main.rs:8:5</span><br><span class="line">  |</span><br><span class="line">8 |     &amp;s</span><br><span class="line">  |     ^^ returns a reference to data owned by the current function</span><br><span class="line"></span><br><span class="line">error: aborting due to 2 previous errors; 1 warning emitted</span><br><span class="line"></span><br><span class="line">Some errors have detailed explanations: E0106, E0515.</span><br><span class="line">For more information about an error, try `rustc --explain E0106`.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>错误信息引用了一个我们还未介绍的功能：<strong>生命周期(lifetimes)</strong>。不过，即使你不理解生命周期，也可以通过错误信息知道这段代码错误的关键信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this function&#x27;s return type contains a borrowed value, but there is no value for it to be borrowed from.</span><br><span class="line">该函数返回了一个借用的值，但是已经找不到它所借用值的来源</span><br></pre></td></tr></table></figure>
<p>仔细看看 dangle 代码的每一步到底发生了什么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn dangle() -&gt; &amp;String &#123; // dangle 返回一个字符串的引用</span><br><span class="line"></span><br><span class="line">    let s = String::from(&quot;hello&quot;); // s 是一个新字符串</span><br><span class="line"></span><br><span class="line">    &amp;s // 返回字符串 s 的引用</span><br><span class="line">&#125; // 这里 s 离开作用域并被丢弃。其内存被释放。</span><br><span class="line">  // 危险！</span><br></pre></td></tr></table></figure>
<p>因为 s 是在 dangle 函数内创建的，当 dangle 的代码执行完毕后，s 将被释放，但是此时我们又尝试去返回它的引用。这意味着这个引用会指向一个无效的 String，这可不对！</p>
<p>其中一个很好的解决方法是直接返回 String：<br>fn no_dangle() -&gt; String {<br>    let s &#x3D; String::from(“hello”);</p>
<pre><code>s
</code></pre>
<p>}<br>这样就没有任何错误了，最终 String 的 <strong>所有权被转移给外面的调用者。</strong></p>
<h1 id="5-切片-slice"><a href="#5-切片-slice" class="headerlink" title="5.切片(slice)"></a>5.切片(slice)</h1><ul>
<li>字符串切片</li>
<li>数组切片</li>
</ul>
<p>切片并不是 Rust 独有的概念，在 Go 语言中就非常流行，它允许你引用集合中部分连续的元素序列，而不是引用整个集合。</p>
<p>对于字符串而言，切片就是对 String 类型中某一部分的引用，它看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let s = String::from(&quot;hello world&quot;);</span><br><span class="line"></span><br><span class="line">let hello = &amp;s[0..5];</span><br><span class="line">let world = &amp;s[6..11];</span><br></pre></td></tr></table></figure>
<p>hello 没有引用整个 String s，而是引用了 s 的一部分内容，通过 [0..5] 的方式来指定。</p>
<p>这就是创建切片的语法，使用方括号包括的一个序列：[开始索引..终止索引]，其中开始索引是切片中第一个元素的索引位置，而终止索引是最后一个元素后面的索引位置，也就是这是一个 右半开区间。在切片数据结构内部会保存开始的位置和切片的长度，其中长度是通过 终止索引 - 开始索引 的方式计算得来的。</p>
<p>对于 let world &#x3D; &amp;s[6..11]; 来说，world 是一个切片，该切片的指针指向 s 的第 7 个字节(索引从 0 开始, 6 是第 7 个字节)，且该切片的长度是 5 个字节。<br><img src="/../images/slice.png"><br>在使用 Rust 的 .. range 序列语法时，如果你想从索引 0 开始，可以使用如下的方式，这两个是等效的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">let slice = &amp;s[0..2];</span><br><span class="line">let slice = &amp;s[..2];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同样的，如果你的切片想要包含 String 的最后一个字节，则可以这样使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">let len = s.len();</span><br><span class="line"></span><br><span class="line">let slice = &amp;s[4..len];</span><br><span class="line">let slice = &amp;s[4..];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你也可以截取完整的 String 切片：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">let len = s.len();</span><br><span class="line"></span><br><span class="line">let slice = &amp;s[0..len];</span><br><span class="line">let slice = &amp;s[..];</span><br></pre></td></tr></table></figure>

<table>
    <tr>
        <td bgcolor=#F0F8FF>
            在对字符串使用切片语法时需要格外小心，切片的索引必须落在字符之间的边界位置，也就是 UTF-8 字符的边界，例如中文在 UTF-8 中占用三个字节，下面的代码就会崩溃：

<pre><code>        let s = &quot;中国人&quot;;
        let a = &amp;s[0..2];
        println!(&quot;&#123;&#125;&quot;,a);
        因为我们只取 s 字符串的前两个字节，但是本例中每个汉字占用三个字节，因此没有落在边界处，也就是连 中 字都取不完整，此时程序会直接崩溃退出，如果改成 &amp;s[0..3]，则可以正常通过编译。 因此，当你需要对字符串做切片索引操作时，需要格外小心这一点, 关于该如何操作 UTF-8 字符串
    &lt;/td&gt;
&lt;/tr&gt;
</code></pre>
</table>
字符串切片的类型标识是 &str，因此我们可以这样声明一个函数，输入 String 类型，返回它的切片: fn first_word(s: &String) -> &str 。
有了切片就可以写出这样的代码：

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello world&quot;);</span><br><span class="line"></span><br><span class="line">    let word = first_word(&amp;s);</span><br><span class="line"></span><br><span class="line">    s.clear(); // error!</span><br><span class="line"></span><br><span class="line">    println!(&quot;the first word is: &#123;&#125;&quot;, word);</span><br><span class="line">&#125;</span><br><span class="line">fn first_word(s: &amp;String) -&gt; &amp;str &#123;</span><br><span class="line">    &amp;s[..1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器报错如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable</span><br><span class="line"> --&gt; src/main.rs:6:5</span><br><span class="line">  |</span><br><span class="line">4 |     let word = first_word(&amp;s);</span><br><span class="line">  |                           -- immutable borrow occurs here</span><br><span class="line">5 |</span><br><span class="line">6 |     s.clear(); // error!</span><br><span class="line">  |     ^^^^^^^^^ mutable borrow occurs here</span><br><span class="line">7 |</span><br><span class="line">8 |     println!(&quot;the first word is: &#123;&#125;&quot;, word);</span><br><span class="line">  |                                       ---- immutable borrow later used here</span><br><span class="line"></span><br><span class="line">error: aborting due to 1 previous error</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0502`.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>回忆一下借用的规则：当我们已经有了可变借用时，就无法再拥有不可变的借用。因为 clear 需要清空改变 String，因此它需要一个可变借用（利用 VSCode 可以看到该方法的声明是 pub fn clear(&amp;mut self) ，参数是对自身的可变借用 ）；而之后的 println! 又使用了不可变借用，也就是在 s.clear() 处可变借用与不可变借用试图同时生效，因此编译无法通过。</p>
<p>从上述代码可以看出，Rust 不仅让我们的 API 更加容易使用，而且也在编译期就消除了大量错误！</p>
<h2 id="5-1其它切片"><a href="#5-1其它切片" class="headerlink" title="5.1其它切片"></a>5.1其它切片</h2><p>因为切片是对集合的部分引用，因此不仅仅字符串有切片，其它集合类型也有，例如数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">let slice = &amp;a[1..3];</span><br><span class="line"></span><br><span class="line">assert_eq!(slice, &amp;[2, 3]);</span><br></pre></td></tr></table></figure>
<p>该数组切片的类型是 &amp;[i32]，数组切片和字符串切片的工作方式是一样的，例如持有一个引用指向原始数组的某个元素和长度。</p>
<h1 id="6-生命周期"><a href="#6-生命周期" class="headerlink" title="6.生命周期"></a>6.生命周期</h1><blockquote>
<blockquote>
<p>dangling referencing<br>生命周期是Rust用来保证引用有效性的机制.生命周期注解允许编译器推断引用的有效范围,确保在引用仍然有效时使用它们.</p>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn test_dangling_pointer() &#123;</span><br><span class="line">    let a = get_a();</span><br><span class="line"></span><br><span class="line">    fn get_a() -&gt; &amp;String &#123;</span><br><span class="line">        &amp;&quot;a&quot;.to_string()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-借用规则总结"><a href="#7-借用规则总结" class="headerlink" title="7.借用规则总结"></a>7.借用规则总结</h1><p>总的来说，借用规则如下：</p>
<ul>
<li>同一时刻，你只能拥有要么一个可变引用, 要么任意多个不可变引用</li>
<li>引用必须总是有效的</li>
</ul>
<h1 id="8-课后习题"><a href="#8-课后习题" class="headerlink" title="8.课后习题"></a>8.课后习题</h1><p>1. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">   let x = 5;</span><br><span class="line">   // 填写空白处</span><br><span class="line">   let p = __;</span><br><span class="line"></span><br><span class="line">   println!(&quot;x 的内存地址是 &#123;:p&#125;&quot;, p); // output: 0x16fa3ac84</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let x = 5;</span><br><span class="line">    // 填写空白处</span><br><span class="line">    let p = &amp;x;</span><br><span class="line"> </span><br><span class="line">    println!(&quot;x 的内存地址是 &#123;:p&#125;&quot;, p); // output: 0x16fa3ac84</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>2. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = 5;</span><br><span class="line">    let y = &amp;x;</span><br><span class="line"></span><br><span class="line">    // 只能修改以下行</span><br><span class="line">    assert_eq!(5, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let x = 5;</span><br><span class="line">    let y = &amp;x;</span><br><span class="line"></span><br><span class="line">    // 只能修改以下行</span><br><span class="line">    assert_eq!(5, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 修复错误</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    borrow_object(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn borrow_object(s: &amp;String) &#123;&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    borrow_object(&amp;s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn borrow_object(s: &amp;String) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>4. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 修复错误</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    push_str(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn push_str(s: &amp;mut String) &#123;</span><br><span class="line">    s.push_str(&quot;world&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    push_str(&amp;mut s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn push_str(s: &amp;mut String) &#123;</span><br><span class="line">    s.push_str(&quot;world&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ref<br>ref 与 &amp; 类似，可以用来获取一个值的引用，但是它们的用法有所不同。<br>5. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    // 填写空白处，让代码工作</span><br><span class="line">    let p = __;</span><br><span class="line">    </span><br><span class="line">    p.push_str(&quot;world&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    // 填写空白处，让代码工作</span><br><span class="line">    let p = &amp;mut s;</span><br><span class="line">    </span><br><span class="line">    p.push_str(&quot;world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let c = &#x27;中&#x27;;</span><br><span class="line"></span><br><span class="line">    let r1 = &amp;c;</span><br><span class="line">    // 填写空白处，但是不要修改其它行的代码</span><br><span class="line">    let __ r2 = c;</span><br><span class="line"></span><br><span class="line">    assert_eq!(*r1, *r2);</span><br><span class="line">    </span><br><span class="line">    // 判断两个内存地址的字符串是否相等</span><br><span class="line">    assert_eq!(get_addr(r1),get_addr(r2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取传入引用的内存地址的字符串形式</span><br><span class="line">fn get_addr(r: &amp;char) -&gt; String &#123;</span><br><span class="line">    format!(&quot;&#123;:p&#125;&quot;, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let c = &#x27;中&#x27;;</span><br><span class="line"></span><br><span class="line">    let r1 = &amp;c;</span><br><span class="line">    // 填写空白处，但是不要修改其它行的代码</span><br><span class="line">    let ref r2 = c;</span><br><span class="line"></span><br><span class="line">    assert_eq!(*r1, *r2);</span><br><span class="line">    </span><br><span class="line">    // 判断两个内存地址的字符串是否相等</span><br><span class="line">    assert_eq!(get_addr(r1),get_addr(r2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取传入引用的内存地址的字符串形式</span><br><span class="line">fn get_addr(r: &amp;char) -&gt; String &#123;</span><br><span class="line">    format!(&quot;&#123;:p&#125;&quot;, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>借用规则<br>7. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 移除代码某个部分，让它工作</span><br><span class="line">// 你不能移除整行的代码！</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    let r1 = &amp;mut s;</span><br><span class="line">    let r2 = &amp;mut s;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    let r1 =  &amp;s;</span><br><span class="line">    let r2 =  &amp;s;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可变性<br>8.  🌟 错误: 从不可变对象借用可变</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    // 通过修改下面一行代码来修复错误</span><br><span class="line">    let  s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    borrow_object(&amp;mut s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn borrow_object(s: &amp;mut String) &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    // 通过修改下面一行代码来修复错误</span><br><span class="line">    let  mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    borrow_object(&amp;mut s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn borrow_object(s: &amp;mut String) &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li><p>🌟🌟 Ok: 从可变对象借用不可变 不用修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 下面的代码没有任何错误</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    borrow_object(&amp;s);</span><br><span class="line">    </span><br><span class="line">    s.push_str(&quot;world&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn borrow_object(s: &amp;String) &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>NLL</p>
</li>
<li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 注释掉一行代码让它工作</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    let r1 = &amp;mut s;</span><br><span class="line">    r1.push_str(&quot;world&quot;);</span><br><span class="line">    let r2 = &amp;mut s;</span><br><span class="line">    r2.push_str(&quot;!&quot;);</span><br><span class="line">    </span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,r1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    let r1 = &amp;mut s;</span><br><span class="line">    r1.push_str(&quot;world&quot;);</span><br><span class="line">    let r2 = &amp;mut s;</span><br><span class="line">    r2.push_str(&quot;!&quot;);</span><br><span class="line">    </span><br><span class="line">    //println!(&quot;&#123;&#125;&quot;,r1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    let r1 = &amp;mut s;</span><br><span class="line">    let r2 = &amp;mut s;</span><br><span class="line"></span><br><span class="line">    // 在下面增加一行代码人为制造编译错误：cannot borrow `s` as mutable more than once at a time</span><br><span class="line">    // 你不能同时使用 r1 和 r2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    let r1 = &amp;mut s;</span><br><span class="line">    let r2 = &amp;mut s;</span><br><span class="line"></span><br><span class="line">    //print!(&quot;&#123;&#125; &#123;&#125;&quot;, r1, r2);</span><br><span class="line">    // r1.push_str(&quot;world&quot;);</span><br><span class="line">    print!(&quot;&#123;&#125; &#123;&#125; &quot;, r1, s);</span><br><span class="line">    // 在下面增加一行代码人为制造编译错误：cannot borrow `s` as mutable more than once at a time</span><br><span class="line">    // 你不能同时使用 r1 和 r2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fn test_lifetime() &#123;</span><br><span class="line">    let large = longest(&quot;a&quot;, &quot;ab&quot;);</span><br><span class="line">    println!(&quot;large one is &#123;large&#125;&quot;);</span><br><span class="line"></span><br><span class="line">    fn longest(x:&amp;str, y:&amp;str) -&gt; &amp;str &#123;</span><br><span class="line">        if x.len() &gt; y.len() &#123;</span><br><span class="line">            x</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            y</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    test_lifetime();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn test_lifetime() &#123;</span><br><span class="line">    let large = longest(&quot;a&quot;, &quot;ab&quot;);</span><br><span class="line">    println!(&quot;large one is &#123;large&#125;&quot;);</span><br><span class="line"></span><br><span class="line">    fn longest&lt;&#x27;a&gt;(x:&amp;&#x27;a str, y:&amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123;</span><br><span class="line">        if x.len() &gt; y.len() &#123;</span><br><span class="line">            x</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            y</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    test_lifetime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/21/learnRust6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Byte的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/21/learnRust6/" itemprop="url">Rust入门-基础 第六节 所有权</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-08-21T01:13:46+08:00">
                2024-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<blockquote>
<p>零开销内存回收的一种高效实现方式<br>Rust是一种系统编程语言,其设计目的是确保内存安全并防止数据竞争,而不依赖垃圾回收器。这种内存安全性只要通过所有权系统来实现。</p>
</blockquote>
</blockquote>
<h1 id="1内存回收"><a href="#1内存回收" class="headerlink" title="1内存回收"></a>1内存回收</h1><blockquote>
<blockquote>
<p>硬件内存大小受限，数据泄露 隐私安全</p>
</blockquote>
</blockquote>
<h2 id="1-1-主流编程语言的内存回收机制对比"><a href="#1-1-主流编程语言的内存回收机制对比" class="headerlink" title="1.1 主流编程语言的内存回收机制对比"></a>1.1 主流编程语言的内存回收机制对比</h2><p>所有的程序都必须和计算机内存打交道，如何从内存中申请空间来存放程序的运行内容，如何在不需要的时候释放这些空间，成了重中之重，也是所有编程语言设计的难点之一。在计算机语言不断演变过程中，出现了三种流派：</p>
<ul>
<li><strong>垃圾回收机制(GC)</strong>，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go</li>
<li><strong>手动管理内存的分配和释放</strong>, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++</li>
<li><strong>通过所有权来管理内存</strong>，编译器在编译时会根据一系列规则进行检查<br>其中 Rust 选择了第三种，最妙的是，这种检查只发生在编译期，因此对于程序运行期，不会有任何性能上的损失。</li>
</ul>
<p>由于所有权是一个新概念，因此读者需要花费一些时间来掌握它，一旦掌握，海阔天空任你飞跃，在本章，我们将通过 字符串 来引导讲解所有权的相关知识。</p>
<p>一段不安全的代码<br>先来看看一段来自 C 语言的糟糕代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int* foo() &#123;</span><br><span class="line">    int a;          // 变量a的作用域开始</span><br><span class="line">    a = 100;</span><br><span class="line">    char *c = &quot;xyz&quot;;   // 变量c的作用域开始</span><br><span class="line">    return &amp;a;</span><br><span class="line">&#125;                   // 变量a和c的作用域结束</span><br></pre></td></tr></table></figure>
<p>这段代码虽然可以编译通过，但是其实非常糟糕，变量 a 和 c 都是局部变量，函数结束后将局部变量 a 的地址返回，但局部变量 a 存在栈中，在离开作用域后，a 所申请的栈上内存都会被系统回收，从而造成了 悬空指针(Dangling Pointer) 的问题。这是一个非常典型的内存安全问题，虽然编译可以通过，但是运行的时候会出现错误, 很多编程语言都存在。</p>
<p>再来看变量 c，c 的值是常量字符串，存储于常量区，可能这个函数我们只调用了一次，也可能我们不再会使用这个字符串，但 “xyz” 只有当整个程序结束后系统才能回收这片内存。</p>
<h2 id="1-1-1-C-C"><a href="#1-1-1-C-C" class="headerlink" title="1.1.1 C&#x2F;C++"></a>1.1.1 C&#x2F;C++</h2><ul>
<li>特点<ul>
<li>程序员通过malloc和free 或者 new delete 手动分配和释放内存</li>
<li>没有内置的垃圾回收机制</li>
</ul>
</li>
<li>优点<ul>
<li>高效灵活 适用于对性能要求极高的系统级编程</li>
</ul>
</li>
<li>缺点<ul>
<li>容易出现内存泄漏 悬垂指针和缓冲区溢出等问题 需要非常小心的处理   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 释放分配的内存</span><br><span class="line">free(ptr);ptr = NULL;//将指针设置为NULL 避免悬空指针</span><br><span class="line">// 动态分配一个数组的内存</span><br><span class="line">int n = 5;int *arr = (int *)malloc(n * sizeof(int));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="1-1-2-JavaScript"><a href="#1-1-2-JavaScript" class="headerlink" title="1.1.2 JavaScript"></a>1.1.2 JavaScript</h2><ul>
<li>内存管理方式：垃圾回收</li>
<li>特点<ul>
<li>浏览器和Node.js环境中均使用垃圾回收器(如V8引擎的垃圾回收器)</li>
<li>采用标记-清除(Mark-and-Sweep) 标记-压缩（Mark-and-Compact）分代回收等算法</li>
</ul>
</li>
<li>优点：<ul>
<li>自动内存管理 适合快速开发和运行在多平台上的应用</li>
</ul>
</li>
<li>缺点：<ul>
<li>垃圾回收机制在某些情况下可能导致性能问题 如UI线程停顿</li>
</ul>
</li>
</ul>
<p>所以内存安全问题，一直都是程序员非常头疼的问题，好在, 在 Rust 中这些问题即将成为历史，因为 Rust 在编译的时候就可以帮助我们发现内存不安全的问题，那 Rust 如何做到这一点呢？</p>
<p>在正式进入主题前，先来一个预热知识。</p>
<h2 id="1-2-栈-Stack-与堆-Heap"><a href="#1-2-栈-Stack-与堆-Heap" class="headerlink" title="1.2 栈(Stack)与堆(Heap)"></a>1.2 栈(Stack)与堆(Heap)</h2><p>栈和堆是编程语言最核心的数据结构，但是在很多语言中，你并不需要深入了解栈与堆。 但对于 Rust 这样的系统编程语言，值是位于栈上还是堆上非常重要, 因为这会影响程序的行为和性能。</p>
<p>栈和堆的核心目标就是为程序在运行时提供可供使用的内存空间。</p>
<h3 id="1-2-1-栈"><a href="#1-2-1-栈" class="headerlink" title="1.2.1 栈"></a>1.2.1 栈</h3><p>栈按照顺序存储值并以相反顺序取出值，这也被称作后进先出。想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，再从顶部拿走。不能从中间也不能从底部增加或拿走盘子！</p>
<p>增加数据叫做进栈，移出数据则叫做出栈。</p>
<p>因为上述的实现方式，栈中的所有数据都必须占用已知且固定大小的内存空间，假设数据大小是未知的，那么在取出数据时，你将无法取到你想要的数据。</p>
<h3 id="1-2-2-堆"><a href="#1-2-2-堆" class="headerlink" title="1.2.2 堆"></a>1.2.2 堆</h3><p>与栈不同，对于大小未知或者可能变化的数据，我们需要将它存储在堆上。</p>
<p>当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的指针, 该过程被称为在堆上分配内存，有时简称为 “分配”(allocating)。</p>
<p>接着，该指针会被推入栈中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的指针，来获取数据在堆上的实际内存位置，进而访问该数据。</p>
<p>由上可知，堆是一种缺乏组织的数据结构。想象一下去餐馆就座吃饭: 进入餐馆，告知服务员有几个人，然后服务员找到一个够大的空桌子（堆上分配的内存空间）并领你们过去。如果有人来迟了，他们也可以通过桌号（栈上的指针）来找到你们坐在哪。</p>
<h3 id="1-2-3-性能区别"><a href="#1-2-3-性能区别" class="headerlink" title="1.2.3 性能区别"></a>1.2.3 性能区别</h3><p>在栈上分配内存比在堆上分配内存要快，因为入栈时操作系统无需进行函数调用（或更慢的系统调用）来分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备，如果当前进程分配的内存页不足时，还需要进行系统调用来申请更多内存。 因此，处理器在栈上分配数据会比在堆上分配数据更加高效。</p>
<h3 id="1-2-4-所有权与堆栈"><a href="#1-2-4-所有权与堆栈" class="headerlink" title="1.2.4 所有权与堆栈"></a>1.2.4 所有权与堆栈</h3><p>当你的代码调用一个函数时，传递给函数的参数（包括可能指向堆上数据的指针和函数的局部变量）依次被压入栈中，当函数调用结束时，这些值将被从栈中按照相反的顺序依次移除。</p>
<p>因为堆上的数据缺乏组织，因此跟踪这些数据何时分配和释放是非常重要的，否则堆上的数据将产生内存泄漏 —— 这些数据将永远无法被回收。这就是 Rust 所有权系统为我们提供的强大保障。</p>
<p>对于其他很多编程语言，你确实无需理解堆栈的原理，但是在 Rust 中，明白堆栈的原理，对于我们理解所有权的工作原理会有很大的帮助。</p>
<h1 id="2-所有权原则"><a href="#2-所有权原则" class="headerlink" title="2.所有权原则"></a>2.所有权原则</h1><p>理解了堆栈，接下来看一下关于所有权的规则，首先请谨记以下规则：</p>
<table>
    <tr>
        <td bgcolor=#F0F8FF>
        1. Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
        2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
        3. 当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)
        </td>
    </tr>
</table>

<h1 id="3-变量作用域"><a href="#3-变量作用域" class="headerlink" title="3.变量作用域"></a>3.变量作用域</h1><p>作用域是一个变量在程序中有效的范围, 假如有这样一个变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let s = &quot;hello&quot;;</span><br></pre></td></tr></table></figure>

<p>变量 s 绑定到了一个字符串字面值，该字符串字面值是硬编码到程序代码中的。s 变量从声明的点开始直到当前作用域的结束都是有效的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;                      // s 在这里无效，它尚未声明</span><br><span class="line">    let s = &quot;hello&quot;;   // 从此处起，s 是有效的</span><br><span class="line"></span><br><span class="line">    // 使用 s</span><br><span class="line">&#125;                      // 此作用域已结束，s不再有效</span><br></pre></td></tr></table></figure>
<p>简而言之，s 从创建开始就有效，然后有效期持续到它离开作用域为止，可以看出，就作用域来说，Rust 语言跟其他编程语言没有区别。</p>
<p>简单介绍 String 类型<br>之前提到过，本章会用 String 作为例子，因此这里会进行一下简单的介绍，具体的 String 学习请参见 String 类型。</p>
<p>我们已经见过字符串字面值 let s &#x3D;”hello”，s 是被硬编码进程序里的字符串值（类型为 &amp;str ）。字符串字面值是很方便的，但是它并不适用于所有场景。原因有二：</p>
<p><strong>字符串字面值是不可变的</strong>，因为被硬编码到程序代码中<br>并非所有字符串的值都能在编写代码时得知<br>例如，字符串是需要程序运行时，通过用户动态输入然后存储在内存中的，这种情况，字符串字面值就完全无用武之地。 为此，Rust 为我们提供动态字符串类型: String, 该类型被分配到堆上，因此可以动态伸缩，也就能存储在编译时大小未知的文本。</p>
<p>可以使用下面的方法基于字符串字面量来创建 String 类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let s = String::from(&quot;hello&quot;);</span><br></pre></td></tr></table></figure>
<p>:: 是一种调用操作符，这里表示调用 String 模块中的 from 方法，由于 String 类型存储在堆上，因此它是动态的，你可以这样修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let mut s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">s.push_str(&quot;, world!&quot;); // push_str() 在字符串后追加字面值</span><br><span class="line"></span><br><span class="line">println!(&quot;&#123;&#125;&quot;, s); // 将打印 `hello, world!`</span><br></pre></td></tr></table></figure>
<p>言归正传，了解 String 后，一起来看看关于所有权的交互。</p>
<h1 id="4-变量绑定背后的数据交互"><a href="#4-变量绑定背后的数据交互" class="headerlink" title="4.变量绑定背后的数据交互"></a>4.变量绑定背后的数据交互</h1><h2 id="4-1转移所有权"><a href="#4-1转移所有权" class="headerlink" title="4.1转移所有权"></a>4.1转移所有权</h2><p>先来看一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let x = 5;</span><br><span class="line">let y = x;</span><br></pre></td></tr></table></figure>
<p>这段代码并没有发生所有权的转移，原因很简单： 代码首先将 5 绑定到变量 x，接着<strong>拷贝</strong> x 的值赋给 y，最终 x 和 y 都等于 5，因为整数是 Rust 基本数据类型，是固定大小的简单值，因此这两个值都是通过<strong>自动拷贝</strong>的方式来赋值的，都被存在栈中，完全无需在堆上分配内存。</p>
<p>整个过程中的赋值都是通过值拷贝的方式完成(发生在栈中)，因此并不需要所有权转移。</p>
<p>可能有同学会有疑问：这种拷贝不消耗性能吗？实际上，这种栈上的数据足够简单，而且拷贝非常非常快，只需要复制一个整数大小（i32，4 个字节）的内存即可，因此在这种情况下，拷贝的速度远比在堆上创建内存来得快的多。实际上，上一章我们讲到的 Rust 基本类型都是通过自动拷贝的方式来赋值的，就像上面代码一样。</p>
<p>然后再来看一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let s1 = String::from(&quot;hello&quot;);</span><br><span class="line">let s2 = s1;</span><br></pre></td></tr></table></figure>
<p>此时，可能某个大聪明( 善意昵称 )已经想到了：嗯，上面一样，把 s1 的内容拷贝一份赋值给 s2，实际上，并不是这样。之前也提到了，对于基本类型（存储在栈上），Rust 会自动拷贝，但是 String 不是基本类型，而且是存储在堆上的，因此不能自动拷贝。</p>
<p>实际上， String 类型是一个复杂类型，由存储在栈中的<strong>堆指针、字符串长度、字符串容量</strong>共同组成，其中<strong>堆指针</strong>是最重要的，它指向了真实存储字符串内容的堆内存，至于长度和容量，如果你有 Go 语言的经验，这里就很好理解：容量是堆内存分配空间的大小，长度是目前已经使用的大小。</p>
<p>总之 String 类型指向了一个堆上的空间，这里存储着它的真实数据，下面对上面代码中的 let s2 &#x3D; s1 分成两种情况讨论：</p>
<p>拷贝 String 和存储在堆上的字节数组 如果该语句是拷贝所有数据(深拷贝)，那么无论是 String 本身还是底层的堆上数据，都会被全部拷贝，这对于性能而言会造成非常大的影响</p>
<p>只拷贝 String 本身 这样的拷贝非常快，因为在 64 位机器上就拷贝了 8字节的指针、8字节的长度、8字节的容量，总计 24 字节，但是带来了新的问题，还记得我们之前提到的所有权规则吧？其中有一条就是：<strong>一个值只允许有一个所有者</strong>，而现在这个值（堆上的真实字符串数据）有了两个所有者：s1 和 s2。</p>
<p>好吧，就假定一个值可以拥有两个所有者，会发生什么呢？</p>
<p>当变量离开作用域后，Rust 会自动调用 drop 函数并清理变量的堆内存。不过由于两个 String 变量指向了同一位置。这就有了一个问题：当 s1 和 s2 离开作用域，它们都会尝试释放相同的内存。这是一个叫做 <strong>二次释放\（double free\）</strong> 的错误，也是之前提到过的内存安全性 BUG 之一。两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。</p>
<p>因此，Rust 这样解决问题：<strong>当 s1 被赋予 s2 后，Rust 认为 s1 不再有效，因此也无需在 s1 离开作用域后 drop 任何东西，这就是把所有权从 s1 转移给了 s2，s1 在被赋予 s2 后就马上失效了。</strong></p>
<p>再来看看，在所有权转移后再来使用旧的所有者，会发生什么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let s1 = String::from(&quot;hello&quot;);</span><br><span class="line">let s2 = s1;</span><br><span class="line"></span><br><span class="line">println!(&quot;&#123;&#125;, world!&quot;, s1);</span><br></pre></td></tr></table></figure>
<p>由于 Rust 禁止你使用无效的引用，你会看到以下的错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">error[E0382]: borrow of moved value: `s1`</span><br><span class="line"> --&gt; src/main.rs:5:28</span><br><span class="line">  |</span><br><span class="line">2 |     let s1 = String::from(&quot;hello&quot;);</span><br><span class="line">  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait</span><br><span class="line">3 |     let s2 = s1;</span><br><span class="line">  |              -- value moved here</span><br><span class="line">4 |</span><br><span class="line">5 |     println!(&quot;&#123;&#125;, world!&quot;, s1);</span><br><span class="line">  |                            ^^ value borrowed here after move</span><br><span class="line">  |</span><br><span class="line">  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)</span><br><span class="line">help: consider cloning the value if the performance cost is acceptable</span><br><span class="line">  |</span><br><span class="line">3 |     let s2 = s1.clone();</span><br><span class="line">  |                ++++++++</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0382`.</span><br></pre></td></tr></table></figure>
<p>现在再回头看看之前的规则，相信大家已经有了更深刻的理解：</p>
<table>
    <tr>
        <td bgcolor=#F0F8FF>
        1.Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
        2.一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
        3.当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)
        </td>
    </tr>
</table>
如果你在其他语言中听说过术语 **浅拷贝\(shallow copy\)** 和 **深拷贝\(deep copy\)**，那么拷贝指针、长度和容量而不拷贝数据听起来就像浅拷贝，但是又因为 Rust 同时使第一个变量 s1 无效了，因此这个操作被称为 **移动**(move)，而不是浅拷贝。上面的例子可以解读为 s1 被移动到了 s2 中。那么具体发生了什么，用一张图简单说明：

<p><img src="/../images/moveOp.png"></p>
<p>这样就解决了我们之前的问题，s1 不再指向任何数据，只有 s2 是有效的，当 s2 离开作用域，它就会释放内存。 相信此刻，你应该明白了，为什么 Rust 称呼 let a &#x3D; b 为变量绑定了吧？</p>
<p>再来看一段代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x: &amp;str = &quot;hello, world&quot;;</span><br><span class="line">    let y = x;</span><br><span class="line">    println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码，大家觉得会否报错？如果参考之前的 String 所有权转移的例子，那这段代码也应该报错才是，但是实际上呢？</p>
<p>这段代码和之前的 String 有一个本质上的区别：在 String 的例子中 s1 持有了通过String::from(“hello”) 创建的值的所有权，而这个例子中，x 只是引用了存储在二进制中的字符串 “hello, world”，并没有持有所有权。</p>
<p>因此 let y &#x3D; x 中，仅仅是对该引用进行了拷贝，此时 y 和 x 都引用了同一个字符串。如果还不理解也没关系，当学习了下一章节 “引用与借用” 后，大家自然而言就会理解。</p>
<h2 id="4-2克隆-深拷贝"><a href="#4-2克隆-深拷贝" class="headerlink" title="4.2克隆(深拷贝)"></a>4.2克隆(深拷贝)</h2><p>首先，Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何自动的复制都不是深拷贝，可以被认为对运行时性能影响较小。</p>
<p>如果我们确实需要深度复制 String 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 clone 的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let s1 = String::from(&quot;hello&quot;);</span><br><span class="line">let s2 = s1.clone();</span><br><span class="line"></span><br><span class="line">println!(&quot;s1 = &#123;&#125;, s2 = &#123;&#125;&quot;, s1, s2);</span><br></pre></td></tr></table></figure>
<p>这段代码能够正常运行，说明 s2 确实完整的复制了 s1 的数据。</p>
<p>如果代码性能无关紧要，例如初始化程序时或者在某段时间只会执行寥寥数次时，你可以使用 clone 来简化编程。但是对于执行较为频繁的代码(热点路径)，使用 clone 会极大的降低程序性能，需要小心使用！</p>
<h2 id="4-3拷贝-浅拷贝"><a href="#4-3拷贝-浅拷贝" class="headerlink" title="4.3拷贝(浅拷贝)"></a>4.3拷贝(浅拷贝)</h2><p>浅拷贝只发生在栈上，因此性能很高，在日常编程中，浅拷贝无处不在。</p>
<p>再回到之前看过的例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let x = 5;</span><br><span class="line">let y = x;</span><br><span class="line"></span><br><span class="line">println!(&quot;x = &#123;&#125;, y = &#123;&#125;&quot;, x, y);</span><br></pre></td></tr></table></figure>
<p>但这段代码似乎与我们刚刚学到的内容相矛盾：没有调用 clone，不过依然实现了类似深拷贝的效果 —— 没有报所有权的错误。</p>
<p>原因是像整型这样的基本类型在编译时是已知大小的，会被存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 y 后使 x 无效（x、y 都仍然有效）。换句话说，这里没有深浅拷贝的区别，因此这里调用 clone 并不会与通常的浅拷贝有什么不同，我们可以不用管它（可以理解成在栈上做了深拷贝）。</p>
<p>Rust 有一个叫做 Copy 的特征，可以用在类似整型这样在栈中存储的类型。如果一个类型拥有 Copy 特征，一个旧的变量在被赋值给其他变量后仍然可用，也就是赋值的过程即是拷贝的过程。</p>
<p>那么什么类型是可 Copy 的呢？可以查看给定类型的文档来确认，这里可以给出一个通用的规则： <strong>任何基本类型的组合可以 Copy ，不需要分配内存或某种形式资源的类型是可以 Copy 的。如下是一些 Copy 的类型</strong>：</p>
<ul>
<li>所有整数类型，比如 u32</li>
<li>布尔类型，bool，它的值是 true 和 false</li>
<li>所有浮点数类型，比如 f64</li>
<li>字符类型，char</li>
<li>元组，当且仅当其包含的类型也都是 Copy 的时候。比如，(i32, i32) 是 Copy 的，但 (i32, String) 就不是</li>
<li>不可变引用 &amp;T ，例如转移所有权中的最后一个例子，但是注意: <strong>可变引用 &amp;mut T 是不可以 Copy的</strong></li>
</ul>
<h1 id="5-函数传值与返回"><a href="#5-函数传值与返回" class="headerlink" title="5.函数传值与返回"></a>5.函数传值与返回</h1><p>将值传递给函数，一样会发生 移动 或者 复制，就跟 let 语句一样，下面的代码展示了所有权、作用域的规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;hello&quot;);  // s 进入作用域</span><br><span class="line"></span><br><span class="line">    takes_ownership(s);             // s 的值移动到函数里 ...</span><br><span class="line">                                    // ... 所以到这里不再有效</span><br><span class="line"></span><br><span class="line">    let x = 5;                      // x 进入作用域</span><br><span class="line"></span><br><span class="line">    makes_copy(x);                  // x 应该移动函数里，</span><br><span class="line">                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x</span><br><span class="line"></span><br><span class="line">&#125; // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，</span><br><span class="line">  // 所以不会有特殊操作</span><br><span class="line"></span><br><span class="line">fn takes_ownership(some_string: String) &#123; // some_string 进入作用域</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, some_string);</span><br><span class="line">&#125; // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放</span><br><span class="line"></span><br><span class="line">fn makes_copy(some_integer: i32) &#123; // some_integer 进入作用域</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, some_integer);</span><br><span class="line">&#125; // 这里，some_integer 移出作用域。不会有特殊操作</span><br></pre></td></tr></table></figure>
<p>你可以尝试在 takes_ownership 之后，再使用 s，看看如何报错？例如添加一行 println!(“在move进函数后继续使用s: {}”,s);。</p>
<p>同样的，函数返回值也有所有权，例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = gives_ownership();         // gives_ownership 将返回值</span><br><span class="line">                                        // 移给 s1</span><br><span class="line"></span><br><span class="line">    let s2 = String::from(&quot;hello&quot;);     // s2 进入作用域</span><br><span class="line"></span><br><span class="line">    let s3 = takes_and_gives_back(s2);  // s2 被移动到</span><br><span class="line">                                        // takes_and_gives_back 中,</span><br><span class="line">                                        // 它也将返回值移给 s3</span><br><span class="line">&#125; // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span><br><span class="line">  // 所以什么也不会发生。s1 移出作用域并被丢弃</span><br><span class="line"></span><br><span class="line">fn gives_ownership() -&gt; String &#123;             // gives_ownership 将返回值移动给</span><br><span class="line">                                             // 调用它的函数</span><br><span class="line"></span><br><span class="line">    let some_string = String::from(&quot;hello&quot;); // some_string 进入作用域.</span><br><span class="line"></span><br><span class="line">    some_string                              // 返回 some_string 并移出给调用的函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// takes_and_gives_back 将传入字符串并返回该值</span><br><span class="line">fn takes_and_gives_back(a_string: String) -&gt; String &#123; // a_string 进入作用域</span><br><span class="line"></span><br><span class="line">    a_string  // 返回 a_string 并移出给调用的函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有权很强大，避免了内存的不安全性，但是也带来了一个新麻烦： 总是把一个值传来传去来使用它。 传入一个函数，很可能还要从该函数传出去，结果就是语言表达变得非常啰嗦，幸运的是，Rust 提供了新功能解决这个问题。</p>
<h1 id="6-练习题"><a href="#6-练习题" class="headerlink" title="6.练习题"></a>6.练习题</h1><h2 id="6-1"><a href="#6-1" class="headerlink" title="6.1"></a>6.1</h2> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // 使用尽可能多的方法来通过编译</span><br><span class="line">    let x = String::from(&quot;hello, world&quot;);</span><br><span class="line">    let y = x;</span><br><span class="line">    println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // 使用尽可能多的方法来通过编译</span><br><span class="line">    let x = String::from(&quot;hello, world&quot;);</span><br><span class="line">    let y = x.clone();</span><br><span class="line">    println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = &quot;hello, world&quot;;</span><br><span class="line">    let y = x;</span><br><span class="line">    println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = &amp;String::from(&quot;hello, world&quot;);</span><br><span class="line">    let y = x;</span><br><span class="line">    println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = String::from(&quot;hello, world&quot;);</span><br><span class="line">    let y = x.as_str();</span><br><span class="line">    println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-2"><a href="#6-2" class="headerlink" title="6.2"></a>6.2</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Don&#x27;t modify code in main!</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(&quot;hello, world&quot;);</span><br><span class="line">    let s2 = take_ownership(s1);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Only modify the code below!</span><br><span class="line">fn take_ownership(s: String) -&gt; String &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s);</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 不要修改 main 中的代码</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(&quot;hello, world&quot;);</span><br><span class="line">    let s2 = take_ownership(s1);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 只能修改下面的代码!</span><br><span class="line">fn take_ownership(s: String) -&gt;String&#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s);</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-3"><a href="#6-3" class="headerlink" title="6.3"></a>6.3</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = give_ownership();</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 只能修改下面的代码!</span><br><span class="line">fn give_ownership() -&gt; String &#123;</span><br><span class="line">    let s = String::from(&quot;hello, world&quot;);</span><br><span class="line">    // convert String to Vec</span><br><span class="line">    // 将 String 转换成 Vec 类型</span><br><span class="line">    let _s = s.into_bytes();</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = give_ownership();</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 只能修改下面的代码!</span><br><span class="line">fn give_ownership() -&gt; String &#123;</span><br><span class="line">    let s = String::from(&quot;hello, world&quot;);</span><br><span class="line">    // convert String to Vec</span><br><span class="line">    // 将 String 转换成 Vec 类型</span><br><span class="line">    let _s = s.as_bytes();</span><br><span class="line">    </span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-4"><a href="#6-4" class="headerlink" title="6.4"></a>6.4</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 修复错误，不要删除任何代码行</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;hello, world&quot;);</span><br><span class="line"></span><br><span class="line">    print_str(s);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn print_str(s: String)  &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 修复错误，不要删除任何代码行</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;hello, world&quot;);</span><br><span class="line"></span><br><span class="line">    print_str(s.clone());</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn print_str(s: String)  &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-5"><a href="#6-5" class="headerlink" title="6.5"></a>6.5</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 不要使用 clone，使用 copy 的方式替代</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let x = (1, 2, (), &quot;hello&quot;.to_string());</span><br><span class="line">    let y = x.clone();</span><br><span class="line">    println!(&quot;&#123;:?&#125;, &#123;:?&#125;&quot;, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = (1, 2, (), &quot;hello&quot;);</span><br><span class="line">    let y = x;</span><br><span class="line">    println!(&quot;&#123;:?&#125;, &#123;:?&#125;&quot;, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-6"><a href="#6-6" class="headerlink" title="6.6"></a>6.6</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;hello, &quot;);</span><br><span class="line">    </span><br><span class="line">    // 只修改下面这行代码 !</span><br><span class="line">    let s1 = s;</span><br><span class="line"></span><br><span class="line">    s1.push_str(&quot;world&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;hello, &quot;);</span><br><span class="line">    </span><br><span class="line">    // 只修改下面这行代码 !</span><br><span class="line">    let mut s1 = s;</span><br><span class="line"></span><br><span class="line">    s1.push_str(&quot;world&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-7"><a href="#6-7" class="headerlink" title="6.7"></a>6.7</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = Box::new(5);</span><br><span class="line">    </span><br><span class="line">    let ...      // 完成该行代码，不要修改其它行！</span><br><span class="line">    </span><br><span class="line">    *y = 4;</span><br><span class="line">    </span><br><span class="line">    assert_eq!(*x, 5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = Box::new(5);</span><br><span class="line">    </span><br><span class="line">    let mut y = Box::new(4);      // 完成该行代码，不要修改其它行！</span><br><span class="line">    </span><br><span class="line">    *y = 4;</span><br><span class="line">    </span><br><span class="line">    assert_eq!(*x, 5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-8"><a href="#6-8" class="headerlink" title="6.8"></a>6.8</h1><p>部分 move<br>当解构一个变量时，可以同时使用 move 和引用模式绑定的方式。当这么做时，部分 move 就会发生：变量中一部分的所有权被转移给其它变量，而另一部分我们获取了它的引用。</p>
<p>在这种情况下，原变量将无法再被使用，但是它没有转移所有权的那一部分依然可以使用，也就是之前被引用的那部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    #[derive(Debug)]</span><br><span class="line">    struct Person &#123;</span><br><span class="line">        name: String,</span><br><span class="line">        age: Box&lt;u8&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let person = Person &#123;</span><br><span class="line">        name: String::from(&quot;Alice&quot;),</span><br><span class="line">        age: Box::new(20),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 通过这种解构式模式匹配，person.name 的所有权被转移给新的变量 `name`</span><br><span class="line">    // 但是，这里 `age` 变量却是对 person.age 的引用, 这里 ref 的使用相当于: let age = &amp;person.age </span><br><span class="line">    let Person &#123; name, ref age &#125; = person;</span><br><span class="line"></span><br><span class="line">    println!(&quot;The person&#x27;s age is &#123;&#125;&quot;, age);</span><br><span class="line"></span><br><span class="line">    println!(&quot;The person&#x27;s name is &#123;&#125;&quot;, name);</span><br><span class="line"></span><br><span class="line">    // Error! 原因是 person 的一部分已经被转移了所有权，因此我们无法再使用它</span><br><span class="line">    //println!(&quot;The person struct is &#123;:?&#125;&quot;, person);</span><br><span class="line"></span><br><span class="line">    // 虽然 `person` 作为一个整体无法再被使用，但是 `person.age` 依然可以使用</span><br><span class="line">    println!(&quot;The person&#x27;s age from person struct is &#123;&#125;&quot;, person.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">   let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;));</span><br><span class="line"></span><br><span class="line">   let _s = t.0;</span><br><span class="line"></span><br><span class="line">   // 仅修改下面这行代码，且不要使用 `_s`</span><br><span class="line">   println!(&quot;&#123;:?&#125;&quot;, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;));</span><br><span class="line"> </span><br><span class="line">    let _s = t.0;</span><br><span class="line"> </span><br><span class="line">    // 仅修改下面这行代码，且不要使用 `_s`</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, t.1);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-9"><a href="#6-9" class="headerlink" title="6.9"></a>6.9</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">   let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;));</span><br><span class="line"></span><br><span class="line">   // 填空，不要修改其它代码</span><br><span class="line">   let (__, __) = __;</span><br><span class="line"></span><br><span class="line">   println!(&quot;&#123;:?&#125;, &#123;:?&#125;, &#123;:?&#125;&quot;, s1, s2, t); // -&gt; &quot;hello&quot;, &quot;world&quot;, (&quot;hello&quot;, &quot;world&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;));</span><br><span class="line"> </span><br><span class="line">    // 填空，不要修改其它代码</span><br><span class="line">    let (s1, s2) = t.clone();</span><br><span class="line"> </span><br><span class="line">    println!(&quot;&#123;:?&#125;, &#123;:?&#125;, &#123;:?&#125;&quot;, s1, s2, t); // -&gt; &quot;hello&quot;, &quot;world&quot;, (&quot;hello&quot;, &quot;world&quot;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/21/learnRust5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Byte的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/21/learnRust5/" itemprop="url">Rust入门-基础 第五节 基础类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-08-21T00:13:30+08:00">
                2024-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1.基本类型"></a>1.基本类型</h1><p>Rust 每个值都有其确切的数据类型，总的来说可以分为两类：基本类型和复合类型。 基本类型意味着它们往往是一个最小化原子类型，无法解构为其它类型(一般意义上来说)</p>
<ul>
<li>数值类型: 有符号整数 (i8, i16, i32, i64, isize)、 无符号整数 (u8, u16, u32, u64, usize) 、浮点数 (f32, f64)、以及有理数、复数</li>
<li>isize usize 与机器字(32位或64位)一样大的有符号整数和无符号整数</li>
<li>复合类型（Compound types）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）</li>
<li>字符串：字符串字面量和字符串切片 &amp;str</li>
<li>布尔类型： true和false</li>
<li>字符类型: 表示单个 Unicode 字符，存储为 4 个字节</li>
<li>单元类型: 即 () ，其唯一的值也是 ()</li>
<li>struct S 具名字段型结构体 S {x:120,y:209.0}</li>
<li>struct T(i32,char); 元组型结构体</li>
<li>struct E 单元型结构体,无字段</li>
<li>enum 枚举 或代数或数据类型</li>
<li>Box<Attend> 指向堆中值的拥有型指针</li>
<li>&amp;i32 &amp;mut i32 共享引用和可变引用:非拥有型指针 其生命周期不能超出引用目标</li>
<li>string UTF8 字符串 动态分配大小</li>
<li>&amp;str 对str的引用：指向UTF-8文本的非拥有型指针</li>
<li>[f64;4] [u8;256] 数组 固定长度 其元素类型都相同</li>
<li>Vec<f64> 向量 可变长度 其元素类型都相同</li>
<li>&amp;[u8] *mut [u8] 对切片(数组或向量某一部分)的引用 包含指针和长度</li>
<li>Option&lt;&amp;str&gt; 可选值:或者为 None(无值) 或者为 Some(v) (有值 其值位v)   Some(“Dr.”) None</li>
<li>Result 可能失败的操作结果:或者为成功值Ok(v) 或者为错误值Err(e)        Ok(4096) Err(Error::last_os_error())</li>
<li>&amp;dyn Any &amp;mut dyn Read 特型对象 是对任何实现了一组给定方法的值的引用  </li>
<li>fn(&amp;str) -&gt; bool 函数指针 str::is_empty</li>
<li>闭包类型没有显示书写形式 闭包 |a,b| a*a + b * b</li>
<li>x..&#x3D;y 序列 1..&#x3D;4</li>
</ul>
<h1 id="1-1整数类型"><a href="#1-1整数类型" class="headerlink" title="1.1整数类型"></a>1.1整数类型</h1><p>整数是没有小数部分的数字。之前使用过的 i32 类型，表示有符号的 32 位整数（ i 是英文单词 integer 的首字母，与之相反的是 u，代表无符号 unsigned 类型）。下表显示了 Rust 中的内置的整数类型</p>
<table>
<thead>
<tr>
<th align="center">长度</th>
<th align="center">有符号类型</th>
<th align="center">无符号类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">8 位</td>
<td align="center">i8</td>
<td align="center">u8</td>
</tr>
<tr>
<td align="center">16 位</td>
<td align="center">i16</td>
<td align="center">u16</td>
</tr>
<tr>
<td align="center">32 位</td>
<td align="center">i32</td>
<td align="center">u32</td>
</tr>
<tr>
<td align="center">64 位</td>
<td align="center">i64</td>
<td align="center">u64</td>
</tr>
<tr>
<td align="center">128 位</td>
<td align="center">i128</td>
<td align="center">u128</td>
</tr>
<tr>
<td align="center">视架构而定</td>
<td align="center">isize</td>
<td align="center">usize</td>
</tr>
</tbody></table>
<p>类型定义的形式统一为：有无符号 + 类型大小(位数)。无符号数表示数字只能取正数和0，而有符号则表示数字可以取正数、负数还有0。就像在纸上写数字一样：当要强调符号时，数字前面可以带上正号或负号；然而，当很明显确定数字为正数时，就不需要加上正号了。有符号数字以补码形式存储。</p>
<p>每个有符号类型规定的数字范围是 -(2n - 1) ~ 2n - 1 - 1，其中 n 是该定义形式的位长度。因此 i8 可存储数字范围是 -(27) ~ 27 - 1，即 -128 ~ 127。无符号类型可以存储的数字范围是 0 ~ 2n - 1，所以 u8 能够存储的数字为 0 ~ 28 - 1，即 0 ~ 255。</p>
<p>此外，isize 和 usize 类型取决于程序运行的计算机 CPU 类型： 若 CPU 是 32 位的，则这两个类型是 32 位的，同理，若 CPU 是 64 位，那么它们则是 64 位。</p>
<p>整形字面量可以用下表的形式书写：</p>
<table>
<thead>
<tr>
<th align="center">数字字面量</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">十进制</td>
<td align="center">98_222</td>
</tr>
<tr>
<td align="center">十六进制</td>
<td align="center">0xff</td>
</tr>
<tr>
<td align="center">八进制</td>
<td align="center">0o77</td>
</tr>
<tr>
<td align="center">二进制</td>
<td align="center">0b1111_0000</td>
</tr>
<tr>
<td align="center">字节 (仅限于 u8)</td>
<td align="center">b’A’</td>
</tr>
</tbody></table>
<h2 id="1-2-整形实例"><a href="#1-2-整形实例" class="headerlink" title="1.2 整形实例"></a>1.2 整形实例</h2><p> Rust 整型默认使用 i32，例如 let i &#x3D; 1，那 i 就是 i32 类型，因此你可以首选它，同时该类型也往往是性能最好的。isize 和 usize 的主要应用场景是用作集合的索引。</p>
<h1 id="1-3-整型溢出"><a href="#1-3-整型溢出" class="headerlink" title="1.3 整型溢出"></a>1.3 整型溢出</h1><p>假设有一个 u8 ，它可以存放从 0 到 255 的值。那么当你将其修改为范围之外的值，比如 256，则会发生整型溢出。关于这一行为 Rust 有一些有趣的规则：当在 debug 模式编译时，Rust 会检查整型溢出，若存在这些问题，则使程序在编译时 panic(崩溃,Rust 使用这个术语来表明程序因错误而退出)。</p>
<p>在当使用 –release 参数进行 release 模式构建时，Rust 不检测溢出。相反，当检测到整型溢出时，Rust 会按照补码循环溢出（two’s complement wrapping）的规则处理。简而言之，大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在 u8 的情况下，256 变成 0，257 变成 1，依此类推。程序不会 panic，但是该变量的值可能不是你期望的值。依赖这种默认行为的代码都应该被认为是错误的代码。</p>
<p>要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：</p>
<ul>
<li>使用 wrapping_* 方法在所有模式下都按照补码循环溢出规则处理，例如 wrapping_add</li>
<li>如果使用 checked_* 方法时发生溢出，则返回 None 值</li>
<li>使用 overflowing_* 方法返回该值和一个指示是否存在溢出的布尔值</li>
<li>使用 saturating_* 方法，可以限定计算后的结果不超过目标类型的最大值或低于最小值，例如:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assert_eq!(100u8.saturating_add(1), 101);</span><br><span class="line">assert_eq!(u8::MAX.saturating_add(127), u8::MAX);</span><br></pre></td></tr></table></figure>
<p>下面是一个演示wrapping_*方法的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a : u8 = 255;</span><br><span class="line">    let b = a.wrapping_add(20);</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, b);  // 19</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-浮点类型"><a href="#2-浮点类型" class="headerlink" title="2.浮点类型"></a>2.浮点类型</h1><p>浮点类型数字 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型： f32 和 f64，分别为 32 位和 64 位大小。默认浮点类型是 f64，在现代的 CPU 中它的速度与 f32 几乎相同，但精度更高。</p>
<p>下面是一个演示浮点数的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = 2.0; // f64</span><br><span class="line"></span><br><span class="line">    let y: f32 = 3.0; // f32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>浮点数根据 IEEE-754 标准实现。f32 类型是单精度浮点型，f64 为双精度。</p>
<h1 id="2-1浮点数陷阱"><a href="#2-1浮点数陷阱" class="headerlink" title="2.1浮点数陷阱"></a>2.1浮点数陷阱</h1><p>浮点数由于底层格式的特殊性，导致了如果在使用浮点数时不够谨慎，就可能造成危险，有两个原因：</p>
<p>浮点数往往是你想要数字的近似表达 浮点数类型是基于二进制实现的，但是我们想要计算的数字往往是基于十进制，例如 0.1 在二进制上并不存在精确的表达形式，但是在十进制上就存在。这种不匹配性导致一定的歧义性，更多的，虽然浮点数能代表真实的数值，但是由于底层格式问题，它往往受限于定长的浮点数精度，如果你想要表达完全精准的真实数字，只有使用无限精度的浮点数才行</p>
<p>浮点数在某些特性上是反直觉的 例如大家都会觉得浮点数可以进行比较，对吧？是的，它们确实可以使用 &gt;，&gt;&#x3D; 等进行比较，但是在某些场景下，这种直觉上的比较特性反而会害了你。因为 f32 ， f64 上的比较运算实现的是 std::cmp::PartialEq 特征(类似其他语言的接口)，但是并没有实现 std::cmp::Eq 特征，但是后者在其它数值类型上都有定义，说了这么多，可能大家还是云里雾里，用一个例子来举例：</p>
<p>Rust 的 HashMap 数据结构，是一个 KV 类型的 Hash Map 实现，它对于 K 没有特定类型的限制，但是要求能用作 K 的类型必须实现了 std::cmp::Eq 特征，因此这意味着你无法使用浮点数作为 HashMap 的 Key，来存储键值对，但是作为对比，Rust 的整数类型、字符串类型、布尔类型都实现了该特征，因此可以作为 HashMap 的 Key。</p>
<p>为了避免上面说的两个陷阱，你需要遵守以下准则：</p>
<p>避免在浮点数上测试相等性<br>当结果在数学上可能存在未定义时，需要格外的小心<br>来看个小例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  // 断言0.1 + 0.2与0.3相等</span><br><span class="line">  assert!(0.1 + 0.2 == 0.3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能以为，这段代码没啥问题吧，实际上它会 panic(程序崩溃，抛出异常)，因为二进制精度问题，导致了 0.1 + 0.2 并不严格等于 0.3，它们可能在小数点 N 位后存在误差。</p>
<p>那如果非要进行比较呢？可以考虑用这种方式 (0.1_f64 + 0.2 - 0.3).abs() &lt; 0.00001 ，具体小于多少，取决于你对精度的需求。</p>
<p>讲到这里，相信大家基本已经明白了，为什么操作浮点数时要格外的小心，但是还不够，下面再来一段代码，直接震撼你的灵魂：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let abc: (f32, f32, f32) = (0.1, 0.2, 0.3);</span><br><span class="line">    let xyz: (f64, f64, f64) = (0.1, 0.2, 0.3);</span><br><span class="line"></span><br><span class="line">    println!(&quot;abc (f32)&quot;);</span><br><span class="line">    println!(&quot;   0.1 + 0.2: &#123;:x&#125;&quot;, (abc.0 + abc.1).to_bits());</span><br><span class="line">    println!(&quot;         0.3: &#123;:x&#125;&quot;, (abc.2).to_bits());</span><br><span class="line">    println!();</span><br><span class="line"></span><br><span class="line">    println!(&quot;xyz (f64)&quot;);</span><br><span class="line">    println!(&quot;   0.1 + 0.2: &#123;:x&#125;&quot;, (xyz.0 + xyz.1).to_bits());</span><br><span class="line">    println!(&quot;         0.3: &#123;:x&#125;&quot;, (xyz.2).to_bits());</span><br><span class="line">    println!();</span><br><span class="line"></span><br><span class="line">    assert!(abc.0 + abc.1 == abc.2);</span><br><span class="line">    assert!(xyz.0 + xyz.1 == xyz.2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行该程序，输出如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">abc (f32)</span><br><span class="line">   0.1 + 0.2: 3e99999a</span><br><span class="line">         0.3: 3e99999a</span><br><span class="line"></span><br><span class="line">xyz (f64)</span><br><span class="line">   0.1 + 0.2: 3fd3333333333334</span><br><span class="line">         0.3: 3fd3333333333333</span><br><span class="line"></span><br><span class="line">thread &#x27;main&#x27; panicked at &#x27;assertion failed: xyz.0 + xyz.1 == xyz.2&#x27;,</span><br><span class="line">➥ch2-add-floats.rs.rs:14:5</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display</span><br><span class="line">➥a backtrace</span><br></pre></td></tr></table></figure>
<p>仔细看，对 f32 类型做加法时，0.1 + 0.2 的结果是 3e99999a，0.3 也是 3e99999a，因此 f32 下的 0.1 + 0.2 &#x3D;&#x3D; 0.3 通过测试，但是到了 f64 类型时，结果就不一样了，因为 f64 精度高很多，因此在小数点非常后面发生了一点微小的变化，0.1 + 0.2 以 4 结尾，但是 0.3 以3结尾，这个细微区别导致 f64 下的测试失败了，并且抛出了异常。</p>
<h1 id="3-NaN"><a href="#3-NaN" class="headerlink" title="3.NaN"></a>3.NaN</h1><p>对于数学上未定义的结果，例如对负数取平方根 -42.1.sqrt() ，会产生一个特殊的结果：Rust 的浮点数类型使用 NaN (not a number)来处理这些情况。</p>
<p>所有跟 NaN 交互的操作，都会返回一个 NaN，而且 NaN 不能用来比较，下面的代码会崩溃：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  let x = (-42.0_f32).sqrt();</span><br><span class="line">  assert_eq!(x, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出于防御性编程的考虑，可以使用 is_nan() 等方法，可以用来判断一个数值是否是 NaN ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = (-42.0_f32).sqrt();</span><br><span class="line">    if x.is_nan() &#123;</span><br><span class="line">        println!(&quot;未定义的数学行为&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-数字运算"><a href="#4-数字运算" class="headerlink" title="4.数字运算"></a>4.数字运算</h1><p>Rust 支持所有数字类型的基本数学运算：加法、减法、乘法、除法和取模运算。下面代码各使用一条 let 语句来说明相应运算的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // 加法</span><br><span class="line">    let sum = 5 + 10;</span><br><span class="line"></span><br><span class="line">    // 减法</span><br><span class="line">    let difference = 95.5 - 4.3;</span><br><span class="line"></span><br><span class="line">    // 乘法</span><br><span class="line">    let product = 4 * 30;</span><br><span class="line"></span><br><span class="line">    // 除法</span><br><span class="line">    let quotient = 56.7 / 32.2;</span><br><span class="line"></span><br><span class="line">    // 求余</span><br><span class="line">    let remainder = 43 % 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些语句中的每个表达式都使用了数学运算符，并且计算结果为一个值，然后绑定到一个变量上。</p>
<p>再来看一个综合性的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  // 编译器会进行自动推导，给予twenty i32的类型</span><br><span class="line">  let twenty = 20;</span><br><span class="line">  // 类型标注</span><br><span class="line">  let twenty_one: i32 = 21;</span><br><span class="line">  // 通过类型后缀的方式进行类型标注：22是i32类型</span><br><span class="line">  let twenty_two = 22i32;</span><br><span class="line"></span><br><span class="line">  // 只有同样类型，才能运算</span><br><span class="line">  let addition = twenty + twenty_one + twenty_two;</span><br><span class="line">  println!(&quot;&#123;&#125; + &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;, twenty, twenty_one, twenty_two, addition);</span><br><span class="line"></span><br><span class="line">  // 对于较长的数字，可以用_进行分割，提升可读性</span><br><span class="line">  let one_million: i64 = 1_000_000;</span><br><span class="line">  println!(&quot;&#123;&#125;&quot;, one_million.pow(2));</span><br><span class="line"></span><br><span class="line">  // 定义一个f32数组，其中42.0会自动被推导为f32类型</span><br><span class="line">  let forty_twos = [</span><br><span class="line">    42.0,</span><br><span class="line">    42f32,</span><br><span class="line">    42.0_f32,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  // 打印数组中第一个值，并控制小数位为2位</span><br><span class="line">  println!(&quot;&#123;:.2&#125;&quot;, forty_twos[0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-位运算"><a href="#5-位运算" class="headerlink" title="5.位运算"></a>5.位运算</h1><p>Rust的位运算基本上和其他语言一样</p>
<p>运算符	说明<br>&amp; 位与	相同位置均为1时则为1，否则为0<br>| 位或	相同位置只要有1时则为1，否则为0<br>^ 异或	相同位置不相同则为1，相同则为0<br>! 位非	把位中的0和1相互取反，即0置为1，1置为0<br>&lt;&lt; 左移	所有位向左移动指定位数，右位补0<br>&gt;&gt; 右移	所有位向右移动指定位数，带符号移动（正数补0，负数补1）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // 二进制为00000010</span><br><span class="line">    let a:i32 = 2;</span><br><span class="line">    // 二进制为00000011</span><br><span class="line">    let b:i32 = 3;</span><br><span class="line"></span><br><span class="line">    println!(&quot;(a &amp; b) value is &#123;&#125;&quot;, a &amp; b);</span><br><span class="line"></span><br><span class="line">    println!(&quot;(a | b) value is &#123;&#125;&quot;, a | b);</span><br><span class="line"></span><br><span class="line">    println!(&quot;(a ^ b) value is &#123;&#125;&quot;, a ^ b);</span><br><span class="line"></span><br><span class="line">    println!(&quot;(!b) value is &#123;&#125; &quot;, !b);</span><br><span class="line"></span><br><span class="line">    println!(&quot;(a &lt;&lt; b) value is &#123;&#125;&quot;, a &lt;&lt; b);</span><br><span class="line"></span><br><span class="line">    println!(&quot;(a &gt;&gt; b) value is &#123;&#125;&quot;, a &gt;&gt; b);</span><br><span class="line"></span><br><span class="line">    let mut a = a;</span><br><span class="line">    // 注意这些计算符除了!之外都可以加上=进行赋值 (因为!=要用来判断不等于)</span><br><span class="line">    a &lt;&lt;= b;</span><br><span class="line">    println!(&quot;(a &lt;&lt; b) value is &#123;&#125;&quot;, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-序列-Range"><a href="#6-序列-Range" class="headerlink" title="6.序列(Range)"></a>6.序列(Range)</h1><p>Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 1..5，生成从 1 到 4 的连续数字，不包含 5 ；1..&#x3D;5，生成从 1 到 5 的连续数字，包含 5，它的用途很简单，常常用于循环中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in 1..=5 &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终程序输出:</p>
<p>1<br>2<br>3<br>4<br>5<br>序列只允许用于数字或字符类型，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。如下是一个使用字符类型序列的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in &#x27;a&#x27;..=&#x27;z&#x27; &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-使用-As-完成类型转换"><a href="#7-使用-As-完成类型转换" class="headerlink" title="7.使用 As 完成类型转换"></a>7.使用 As 完成类型转换</h1><p>Rust 中可以使用 As 来完成一个类型到另一个类型的转换，其最常用于将原始类型转换为其他原始类型，但是它也可以完成诸如将指针转换为地址、地址转换为指针以及将指针转换为其他指针等功能。你可以在这里了解更多相关的知识。</p>
<h1 id="8-有理数和复数"><a href="#8-有理数和复数" class="headerlink" title="8.有理数和复数"></a>8.有理数和复数</h1><p>Rust 的标准库相比其它语言，准入门槛较高，因此有理数和复数并未包含在标准库中：</p>
<p>有理数和复数<br>任意大小的整数和任意精度的浮点数<br>固定精度的十进制小数，常用于货币相关的场景<br>好在社区已经开发出高质量的 Rust 数值库：num。</p>
<p>按照以下步骤来引入 num 库：</p>
<ol>
<li>创建新工程 cargo new complex-num &amp;&amp; cd complex-num</li>
<li>在 Cargo.toml 中的 [dependencies] 下添加一行 num &#x3D; “0.4.0”</li>
<li>将 src&#x2F;main.rs 文件中的 main 函数替换为下面的代码</li>
<li>运行 cargo run<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use num::complex::Complex;</span><br><span class="line"></span><br><span class="line"> fn main() &#123;</span><br><span class="line">   let a = Complex &#123; re: 2.1, im: -1.2 &#125;;</span><br><span class="line">   let b = Complex::new(11.1, 22.2);</span><br><span class="line">   let result = a + b;</span><br><span class="line"></span><br><span class="line">   println!(&quot;&#123;&#125; + &#123;&#125;i&quot;, result.re, result.im)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="9-布尔-bool"><a href="#9-布尔-bool" class="headerlink" title="9.布尔(bool)"></a>9.布尔(bool)</h1><p>Rust 中的布尔类型有两个可能的值：true 和 false，布尔值占用内存的大小为 1 个字节：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let t = true;</span><br><span class="line"></span><br><span class="line">    let f: bool = false; // 使用类型标注,显式指定f的类型</span><br><span class="line"></span><br><span class="line">    if f &#123;</span><br><span class="line">        println!(&quot;这是段毫无意义的代码&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用布尔类型的场景主要在于流程控制，例如上述代码的中的 if 就是其中之一。</p>
<h1 id="10-字符类型-char"><a href="#10-字符类型-char" class="headerlink" title="10.字符类型(char)"></a>10.字符类型(char)</h1><p>字符，对于没有其它编程经验的新手来说可能不太好理解（没有编程经验敢来学 Rust 的绝对是好汉），但是你可以把它理解为英文中的字母，中文中的汉字。</p>
<p>下面的代码展示了几个颇具异域风情的字符：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let c = &#x27;z&#x27;;</span><br><span class="line">    let z = &#x27;ℤ&#x27;;</span><br><span class="line">    let g = &#x27;国&#x27;;</span><br><span class="line">    let heart_eyed_cat = &#x27;😻&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果大家是从有年代感的编程语言过来，可能会大喊一声：这 XX 叫字符？是的，在 Rust 语言中这些都是字符，Rust 的字符不仅仅是 ASCII，所有的 Unicode 值都可以作为 Rust 字符，包括单个的中文、日文、韩文、emoji 表情符号等等，都是合法的字符类型。Unicode 值的范围从 U+0000 ~ U+D7FF 和 U+E000 ~ U+10FFFF。不过“字符”并不是 Unicode 中的一个概念，所以人在直觉上对“字符”的理解和 Rust 的字符概念并不一致。</p>
<p>由于 Unicode 都是 4 个字节编码，因此字符类型也是占用 4 个字节：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = &#x27;中&#x27;;</span><br><span class="line">    println!(&quot;字符&#x27;中&#x27;占用了&#123;&#125;字节的内存大小&quot;,std::mem::size_of_val(&amp;x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出如下:<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling ...</span><br></pre></td></tr></table></figure><br>字符’中’占用了4字节的内存大小</p>
<table>
    <td bgcolor=#F0F8FF>[package]
        注意，我们还没开始讲字符串，但是这里提前说一下，和一些语言不同，Rust 的字符只能用 '' 来表示， "" 是留给字符串的。
    </td>
</table>


<h1 id="9-总结"><a href="#9-总结" class="headerlink" title="9.总结"></a>9.总结</h1><p>之前提到了过 Rust 的数值类型和运算跟其他语言较为相似，但是实际上，除了语法上的不同之外，还是存在一些差异点：</p>
<p>Rust 拥有相当多的数值类型. 因此你需要熟悉这些类型所占用的字节数，这样就知道该类型允许的大小范围以及你选择的类型是否能表达负数<br>类型转换必须是显式的. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数<br>Rust 的数值上可以使用方法. 例如你可以用以下方法来将 13.14 取整：13.14_f32.round()，在这里我们使用了类型后缀，因为编译器需要知道 13.14 的具体类型<br>数值类型的讲解已经基本结束，接下来，来看看字符和布尔类型。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/14/color/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Byte的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/14/color/" itemprop="url">Color</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-08-14T00:58:23+08:00">
                2024-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>#E0FFFF: 亮浅蓝色 (Light Cyan)</li>
<li>#D3E8FF: 淡蓝色 (Pale Blue)</li>
<li>#F0F8FF: 爱丽丝蓝 (Alice Blue)</li>
<li>#CCFFFF: 淡青色 (Pale Cyan)</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/14/learnRust4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Byte的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/14/learnRust4/" itemprop="url">Rust入门-基础 第四节 Rust - 流程控制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-08-14T00:37:21+08:00">
                2024-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="if-表达式"><a href="#if-表达式" class="headerlink" title="if 表达式"></a>if 表达式</h1><p>不像 Ruby 或 JavaScript这样的语言，Rust并不会尝试自动地将非布尔值转换为布尔值。必须总是显式地使用布尔值作为 if 条件<br>但凡你能找到一门编程语言没有 if else，那么一定更要反馈给鲁迅，反正不是我说的:) 总之，只要你拥有其它语言的编程经验，就一定会有以下认知：if else 表达式根据条件执行不同的代码分支：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if condition == true &#123;</span><br><span class="line">    // A...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // B...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码读作：若 condition 的值为 true，则执行 A 代码，否则执行 B 代码。</p>
<p>先看下面代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let condition = true;</span><br><span class="line">    let number = if condition &#123;</span><br><span class="line">        5</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        6</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;The value of number is: &#123;&#125;&quot;, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码有以下几点要注意：</p>
<ul>
<li>if 语句块是表达式，这里我们使用 if 表达式的返回值来给 number 进行赋值：number 的值是 5</li>
<li>用 if 来赋值时，要保证每个分支返回的类型一样(事实上，这种说法不完全准确，见这里)，此处返回的 5 和 6 就是同一个类型，如果返回类型不一致就会报错</li>
<li>代码块的值是其最后一个表达式的值，这里继续不谈**语句(statement)和表达式(expression)**的概念，只要知道这里不应该有分号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let number:i32 = 3;</span><br><span class="line">    if number &lt; 5 &#123;</span><br><span class="line">        println!(&quot;condition was true&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        println!(&quot;condition was false&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="以上代码有以下几点要注意："><a href="#以上代码有以下几点要注意：" class="headerlink" title="以上代码有以下几点要注意："></a>以上代码有以下几点要注意：</h2><ul>
<li>if 语句块是表达式，这里我们使用 if 表达式的返回值来给 number 进行赋值：number 的值是 5</li>
<li>用 if 来赋值时，要保证每个分支返回的类型一样(事实上，这种说法不完全准确，见这里)，此处返回的 5 和 6 就是同一个类型，如果返回类型不一致就会报错</li>
</ul>
<h1 id="使用-else-if-来处理多重条件"><a href="#使用-else-if-来处理多重条件" class="headerlink" title="使用 else if 来处理多重条件"></a>使用 else if 来处理多重条件</h1><p>可以将 else if 与 if、else 组合在一起实现更复杂的条件分支判断：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let n = 6;</span><br><span class="line"></span><br><span class="line">    if n % 4 == 0 &#123;</span><br><span class="line">        println!(&quot;number is divisible by 4&quot;);</span><br><span class="line">    &#125; else if n % 3 == 0 &#123;</span><br><span class="line">        println!(&quot;number is divisible by 3&quot;);</span><br><span class="line">    &#125; else if n % 2 == 0 &#123;</span><br><span class="line">        println!(&quot;number is divisible by 2&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        println!(&quot;number is not divisible by 4, 3, or 2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行时，会按照自上至下的顺序执行每一个分支判断，一旦成功，则跳出 if 语句块，最终本程序会匹配执行 else if n % 3 &#x3D;&#x3D; 0 的分支，输出 “number is divisible by 3”。<br>有一点要注意，就算有多个分支能匹配，也只有第一个匹配的分支会被执行！<br>如果代码中有大量的 else if 会让代码变得极其丑陋，不过不用担心，下一章的 match 专门用以解决多分支模式匹配的问题。</p>
<h1 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h1><p>循环无处不在，上到数钱，下到数年，你能想象的很多场景都存在循环，因此它也是流程控制中最重要的组成部分之一。</p>
<p>在 Rust 语言中有三种循环方式：for、while 和 loop，其中 for 循环是 Rust 循环王冠上的明珠。</p>
<h1 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h1><h2 id="for-循环是-Rust-的大杀器："><a href="#for-循环是-Rust-的大杀器：" class="headerlink" title="for 循环是 Rust 的大杀器："></a>for 循环是 Rust 的大杀器：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    for i in 1..=5 &#123;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码循环输出一个从 1 到 5 的序列，简单粗暴，核心就在于 for 和 in 的联动，语义表达如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for 元素 in 集合 &#123;</span><br><span class="line">  // 使用元素干一些你懂我不懂的事情</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个语法跟 JavaScript 还蛮像，应该挺好理解。</p>
<p>注意，使用 for 时我们往往使用集合的引用形式，除非你不想在后面的代码中继续使用该集合（比如我们这里使用了 container 的引用）。如果不使用引用的话，所有权会被转移（move）到 for 语句块中，后面就无法再使用这个集合了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for item in &amp;container &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
    <tr>
        <td bgcolor=#F0F8FF>对于实现了 copy 特征的数组(例如 [i32; 10] )而言， for item in arr 并不会把 arr 的所有权转移，而是直接对其进行了拷贝，因此循环之后仍然可以使用 arr 。
        </td>
    </tr>
</table>
如果想在循环中，修改该元素，可以使用 mut 关键字：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for item in &amp;mut collection &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">使用方法</th>
<th align="center">等价使用方式</th>
<th align="right">所有权</th>
</tr>
</thead>
<tbody><tr>
<td align="left">for item in collection</td>
<td align="center">for item in IntoIterator::into_iter(collection)</td>
<td align="right">转移所有权</td>
</tr>
<tr>
<td align="left">for item in &amp;collection</td>
<td align="center">for item in collection.iter()</td>
<td align="right">不可变借用</td>
</tr>
<tr>
<td align="left">for item in &amp;mut collection</td>
<td align="center">for item in collection.iter_mut()</td>
<td align="right">可变借用</td>
</tr>
</tbody></table>
<style>
  table {
    font-size: 12px;
  }
</style>
<p>如果想在循环中获取元素的索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a = [4, 3, 2, 1];</span><br><span class="line">    // `.iter()` 方法把 `a` 数组变成一个迭代器</span><br><span class="line">    for (i, v) in a.iter().enumerate() &#123;</span><br><span class="line">        println!(&quot;第&#123;&#125;个元素是&#123;&#125;&quot;, i + 1, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有同学可能会想到，如果我们想用 for 循环控制某个过程执行 10 次，但是又不想单独声明一个变量来控制这个流程，该怎么写？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//有点类似lua的写法</span><br><span class="line">for _ in 0..10 &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以用 _ 来替代 i 用于 for 循环中，在 Rust 中 _ 的含义是忽略该值或者类型的意思，如果不使用 _，那么编译器会给你一个 变量未使用的 的警告。</p>
<h2 id="两种循环方式优劣对比"><a href="#两种循环方式优劣对比" class="headerlink" title="两种循环方式优劣对比"></a>两种循环方式优劣对比</h2><p>以下代码，使用了两种循环方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 第一种</span><br><span class="line">let collection = [1, 2, 3, 4, 5];</span><br><span class="line">for i in 0..collection.len() &#123;</span><br><span class="line">  let item = collection[i];</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第二种</span><br><span class="line">for item in collection &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一种方式是循环索引，然后通过索引下标去访问集合，第二种方式是直接循环集合中的元素，优劣如下：</p>
<ul>
<li>性能：第一种使用方式中 collection[index] 的索引访问，会因为边界检查(Bounds Checking)导致运行时的性能损耗 —— Rust 会检查并确认 index 是否落在集合内，但是第二种直接迭代的方式就不会触发这种检查，因为编译器会在编译时就完成分析并证明这种访问是合法的</li>
<li>安全：第一种方式里对 collection 的索引访问是非连续的，存在一定可能性在两次访问之间，collection 发生了变化，导致脏数据产生。而第二种直接迭代的方式是连续访问，因此不存在这种风险( 由于所有权限制，在访问过程中，数据并不会发生变化)。<br>由于 for 循环无需任何条件限制，也不需要通过索引来访问，因此是最安全也是最常用的，通过与下面的 while 的对比，我们能看到为什么 for 会更加安全。</li>
</ul>
<h1 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h1><p>使用 continue 可以跳过当前当次的循环，开始下次的循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i in 1..4 &#123;</span><br><span class="line">    if i == 2 &#123;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码对 1 到 3 的序列进行迭代，且跳过值为 2 时的循环，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h1 id="break"><a href="#break" class="headerlink" title="break"></a>break</h1><p>使用 break 可以直接跳出当前整个循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i in 1..4 &#123;</span><br><span class="line">    if i == 2 &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码对 1 到 3 的序列进行迭代，在遇到值为 2 时的跳出整个循环，后面的循环不再执行，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<h1 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h1><p>如果你需要一个条件来循环，当该条件为 true 时，继续循环，条件为 false，跳出循环，那么 while 就非常适用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut n = 0;</span><br><span class="line"></span><br><span class="line">    while n &lt;= 5  &#123;</span><br><span class="line">        println!(&quot;&#123;&#125;!&quot;, n);</span><br><span class="line"></span><br><span class="line">        n = n + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;我出来了！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该 while 循环，只有当 n 小于等于 5 时，才执行，否则就立刻跳出循环，因此在上述代码中，它会先从 0 开始，满足条件，进行循环，然后是 1，满足条件，进行循环，最终到 6 的时候，大于 5，不满足条件，跳出 while 循环，执行 我出来了 的打印，然后程序结束：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0!</span><br><span class="line">1!</span><br><span class="line">2!</span><br><span class="line">3!</span><br><span class="line">4!</span><br><span class="line">5!</span><br><span class="line">我出来了！</span><br></pre></td></tr></table></figure>
<p>当然，你也可以用其它方式组合实现，例如 loop（无条件循环，将在下面介绍） + if + break：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut n = 0;</span><br><span class="line"></span><br><span class="line">    loop &#123;</span><br><span class="line">        if n &gt; 5 &#123;</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;, n);</span><br><span class="line">        n+=1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;我出来了！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，在这种循环场景下，while 要简洁的多。</p>
<h1 id="while-vs-for"><a href="#while-vs-for" class="headerlink" title="while vs for"></a>while vs for</h1><p>我们也能用 while 来实现 for 的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a = [10, 20, 30, 40, 50];</span><br><span class="line">    let mut index = 0;</span><br><span class="line"></span><br><span class="line">    while index &lt; 5 &#123;</span><br><span class="line">        println!(&quot;the value is: &#123;&#125;&quot;, a[index]);</span><br><span class="line"></span><br><span class="line">        index = index + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，代码对数组中的元素进行计数。它从索引 0 开始，并接着循环直到遇到数组的最后一个索引（这时，index &lt; 5 不再为真）。运行这段代码会打印出数组中的每一个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">the value is: 10</span><br><span class="line">the value is: 20</span><br><span class="line">the value is: 30</span><br><span class="line">the value is: 40</span><br><span class="line">the value is: 50</span><br></pre></td></tr></table></figure>
<p>数组中的所有五个元素都如期被打印出来。尽管 index 在某一时刻会到达值 5，不过循环在其尝试从数组获取第六个值（会越界）之前就停止了。</p>
<p>但这个过程很容易出错；如果索引长度不正确会导致程序 panic。这也使程序更慢，因为编译器增加了运行时代码来对每次循环的每个元素进行条件检查。</p>
<p>for循环代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a = [10, 20, 30, 40, 50];</span><br><span class="line"></span><br><span class="line">    for element in a.iter() &#123;</span><br><span class="line">        println!(&quot;the value is: &#123;&#125;&quot;, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，for 并不会使用索引去访问数组，因此更安全也更简洁，同时避免 运行时的边界检查，性能更高。</p>
<h1 id="loop-循环"><a href="#loop-循环" class="headerlink" title="loop 循环"></a>loop 循环</h1><p>对于循环而言，loop 循环毋庸置疑，是适用面最高的，它可以适用于所有循环场景（虽然能用，但是在很多场景下， for 和 while 才是最优选择），因为 loop 就是一个简单的无限循环，你可以在内部实现逻辑通过 break 关键字来控制循环何时结束。</p>
<p>使用 loop 循环一定要打起精神，否则你会写出下面的跑满你一个 CPU 核心的疯子代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    loop &#123;</span><br><span class="line">        println!(&quot;again!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该循环会不停的在终端打印输出，直到你使用 Ctrl-C 结束程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">again!</span><br><span class="line">again!</span><br><span class="line">again!</span><br><span class="line">again!</span><br><span class="line">^Cagain!</span><br></pre></td></tr></table></figure>
<p>注意，不要轻易尝试上述代码，如果你电脑配置不行，可能会死机！！！</p>
<p>因此，当使用 loop 时，必不可少的伙伴是 break 关键字，它能让循环在满足某个条件时跳出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut counter = 0;</span><br><span class="line"></span><br><span class="line">    let result = loop &#123;</span><br><span class="line">        counter += 1;</span><br><span class="line"></span><br><span class="line">        if counter == 10 &#123;</span><br><span class="line">            break counter * 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;The result is &#123;&#125;&quot;, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码当 counter 递增到 10 时，就会通过 break 返回一个 counter * 2 的值，最后赋给 result 并打印出来。</p>
<p>这里有几点值得注意：</p>
<ul>
<li>break 可以单独使用，也可以带一个返回值，有些类似 return</li>
<li>loop 是一个表达式，因此可以返回一个值</li>
</ul>
<h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 填空</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let n = 5;</span><br><span class="line"></span><br><span class="line">    if n &lt; 0 &#123;</span><br><span class="line">        println!(&quot;&#123;&#125; is negative&quot;, n);</span><br><span class="line">    &#125; else if n &gt; 0 &#123;</span><br><span class="line">        println!(&quot;&#123;&#125; is positive&quot;, n);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        println!(&quot;&#123;&#125; is zero&quot;, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 修复错误</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let n = 5;</span><br><span class="line"></span><br><span class="line">    let big_n =  </span><br><span class="line">    if n &lt; 10 &amp;&amp; n &gt; -10 &#123;</span><br><span class="line">        println!(&quot; 数字太小，先增加 10 倍再说&quot;);</span><br><span class="line"></span><br><span class="line">         10 * n</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        println!(&quot;数字太大，我们得让它减半&quot;);</span><br><span class="line"></span><br><span class="line">        n / 2 </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125; -&gt; &#123;&#125;&quot;, n, big_n);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    for n in 1..=99 &#123; // 修改此行，让代码工作</span><br><span class="line">        if n == 100 &#123;</span><br><span class="line">            panic!(&quot;NEVER LET THIS RUN&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">//</span><br><span class="line">//fn main() &#123;</span><br><span class="line">    //for n in 1..99 &#123; // 修改此行，让代码工作</span><br><span class="line">        //if n == 100 &#123;</span><br><span class="line">            //panic!(&quot;NEVER LET THIS RUN&quot;)</span><br><span class="line">        //&#125;</span><br><span class="line">    //&#125;</span><br><span class="line">//&#125; </span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 修复错误，不要新增或删除代码行</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let names = [String::from(&quot;liming&quot;),String::from(&quot;hanmeimei&quot;)];</span><br><span class="line">    for name in &amp;names &#123;</span><br><span class="line">        // do something with name...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, names);</span><br><span class="line"></span><br><span class="line">    let numbers = [1, 2, 3];</span><br><span class="line">    // numbers中的元素实现了 Copy，因此无需转移所有权</span><br><span class="line">    for n in numbers &#123;</span><br><span class="line">        // do something with name...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, numbers);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a = [4,3,2,1];</span><br><span class="line"></span><br><span class="line">    // 通过索引和值的方式迭代数组 `a` </span><br><span class="line">    for (i,v) in a.iter().enumerate() &#123;</span><br><span class="line">        println!(&quot;第&#123;&#125;个元素是&#123;&#125;&quot;,i+1,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 填空，让最后一行的  println! 工作 !</span><br><span class="line">fn main() &#123;</span><br><span class="line">    // 一个计数值</span><br><span class="line">    let mut n = 1;</span><br><span class="line"></span><br><span class="line">    // 当条件为真时，不停的循环</span><br><span class="line">    while n &lt; 10 &#123;</span><br><span class="line">        if n % 15 == 0 &#123;</span><br><span class="line">            println!(&quot;fizzbuzz&quot;);</span><br><span class="line">        &#125; else if n % 3 == 0 &#123;</span><br><span class="line">            println!(&quot;fizz&quot;);</span><br><span class="line">        &#125; else if n % 5 == 0 &#123;</span><br><span class="line">            println!(&quot;buzz&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            println!(&quot;&#123;&#125;&quot;, n);</span><br><span class="line">        &#125;</span><br><span class="line">        n = n + 1;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;n 的值是 &#123;&#125;, 循环结束&quot;,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li><p>🌟 使用 break 可以跳出循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 填空，不要修改其它代码</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut n = 0;</span><br><span class="line">    for i in 0..=100 &#123;</span><br><span class="line">       if n == 66 &#123;</span><br><span class="line">           break;</span><br><span class="line">       &#125;</span><br><span class="line">       n += 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert_eq!(n, 66);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>🌟🌟 continue 会结束当次循环并立即开始下一次循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 填空，不要修改其它代码</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut n = 0;</span><br><span class="line">    for i in 0..=100 &#123;</span><br><span class="line">       if n != 66 &#123;</span><br><span class="line">           n+=1;</span><br><span class="line">           continue;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert_eq!(n, 66);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>🌟🌟 loop 一般都需要配合 break 或 continue 一起使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 填空，不要修改其它代码</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut count = 0u32;</span><br><span class="line"></span><br><span class="line">    println!(&quot;Let&#x27;s count until infinity!&quot;);</span><br><span class="line"></span><br><span class="line">    // 无限循环</span><br><span class="line">    loop &#123;</span><br><span class="line">        count += 1;</span><br><span class="line"></span><br><span class="line">        if count == 3 &#123;</span><br><span class="line">            println!(&quot;three&quot;);</span><br><span class="line"></span><br><span class="line">            // 跳过当此循环的剩余代码</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println!(&quot;&#123;&#125;&quot;, count);</span><br><span class="line"></span><br><span class="line">        if count == 5 &#123;</span><br><span class="line">            println!(&quot;OK, that&#x27;s enough&quot;);</span><br><span class="line"></span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert_eq!(count, 5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>🌟🌟 loop 是一个表达式，因此我们可以配合 break 来返回一个值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 填空</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut counter = 0;</span><br><span class="line"></span><br><span class="line">    let result = loop &#123;</span><br><span class="line">        counter += 1;</span><br><span class="line"></span><br><span class="line">        if counter == 10 &#123;</span><br><span class="line">            break counter + 10</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    assert_eq!(result, 20);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>🌟🌟🌟 当有多层循环时，你可以使用 continue 或 break 来控制外层的循环。要实现这一点，外部的循环必须拥有一个标签 ‘label, 然后在 break 或 continue 时指定该标签</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 填空</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut count = 0;</span><br><span class="line">    &#x27;outer: loop &#123;</span><br><span class="line">        &#x27;inner1: loop &#123;</span><br><span class="line">            if count &gt;= 20 &#123;</span><br><span class="line">                // 这只会跳出 inner1 循环</span><br><span class="line">                break &#x27;inner1; // 这里使用 `break` 也是一样的</span><br><span class="line">            &#125;</span><br><span class="line">            count += 2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count += 5;</span><br><span class="line"></span><br><span class="line">        &#x27;inner2: loop &#123;</span><br><span class="line">            if count &gt;= 30 &#123;</span><br><span class="line">                break &#x27;outer;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            continue &#x27;outer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert!(count == 30)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives%7C%7C%20archive">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">One Byte</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
