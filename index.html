<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Byte的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Byte的博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="One Byte">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/"/>





  <title>Byte的博客</title>
  








<meta name="generator" content="Hexo 7.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Byte的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/22/learnRust7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Byte的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/22/learnRust7/" itemprop="url">Rust入门-基础 第七节 引用与借用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-08-22T22:57:27+08:00">
                2024-08-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上节中提到，如果仅仅支持通过转移所有权的方式获取一个值，那会让程序变得复杂。 Rust 能否像其它编程语言一样，使用某个变量的指针或者引用呢？答案是可以。</p>
<p>Rust 通过 借用(Borrowing) 这个概念来达成上述的目的，获取变量的引用，称之为借用(borrowing)。正如现实生活中，如果一个人拥有某样东西，你可以从他那里借来，当使用完毕后，也必须要物归原主。</p>
<ul>
<li><strong>不可变引用(Immutable Reference)</strong>:通过不可变引用,可以读取数据,但不能修改数据.一个变量可以有多个不可变引用,但不能与可变引用共存.</li>
<li><strong>可变引用(Mutable Reference)</strong>:通过可变引用,可以读取和修改数据.一个变量在某一时刻只能有一个可变引用,且不能与不可变引用共存.</li>
</ul>
<p><strong>move&amp;borrowing&amp;referencing</strong></p>
<ul>
<li>move堆数据所有权</li>
<li>borrowing 函数</li>
<li>referencing 变量</li>
</ul>
<h1 id="1-引用与解引用"><a href="#1-引用与解引用" class="headerlink" title="1.引用与解引用"></a>1.引用与解引用</h1><p>常规引用是一个指针类型，指向了对象存储的内存地址。在下面代码中，我们创建一个 i32 值的引用 y，然后使用解引用运算符来解出 y 所使用的值:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = 5;</span><br><span class="line">    let y = &amp;x;</span><br><span class="line"></span><br><span class="line">    assert_eq!(5, x);</span><br><span class="line">    assert_eq!(5, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量 x 存放了一个 i32 值 5。y 是 x 的一个引用。可以断言 x 等于 5。然而，如果希望对 y 的值做出断言，必须使用 *y 来解出引用所指向的值（也就是解引用）。一旦解引用了 y，就可以访问 y 所指向的整型值并可以与 5 做比较。</p>
<p>相反如果尝试编写 assert_eq!(5, y);，则会得到如下编译错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   Compiling world_hello v0.1.0 (D:\rust\world_hello)</span><br><span class="line">error[E0277]: can&#x27;t compare `&#123;integer&#125;` with `&amp;&#123;integer&#125;`</span><br><span class="line"> --&gt; src/main.rs:6:5</span><br><span class="line">  |</span><br><span class="line">6 |     assert_eq!(5, y);</span><br><span class="line">  |     ^^^^^^^^^^^^^^^^ no implementation for `&#123;integer&#125; == &amp;&#123;integer&#125;`</span><br><span class="line">  |</span><br><span class="line">  = help: the trait `PartialEq&lt;&amp;&#123;integer&#125;&gt;` is not implemented for `&#123;integer&#125;`</span><br><span class="line">  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)</span><br><span class="line">help: consider dereferencing here</span><br><span class="line"> --&gt; C:\Users\Administrator\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\macros\mod.rs:40:35</span><br><span class="line">  |</span><br><span class="line">40|                 if !(*left_val == **right_val) &#123;</span><br><span class="line">  |                                   +</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0277`.</span><br></pre></td></tr></table></figure>
<p>不允许比较整数与引用，因为它们是不同的类型。必须使用解引用运算符解出引用所指向的值。</p>
<p>不可变引用<br>下面的代码，我们用 s1 的引用作为参数传递给 calculate_length 函数，而不是把 s1 的所有权转移给该函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    let len = calculate_length(&amp;s1);</span><br><span class="line"></span><br><span class="line">    println!(&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn calculate_length(s: &amp;String) -&gt; usize &#123;</span><br><span class="line">    s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能注意到两点：</p>
<ol>
<li>无需像上章一样：先通过函数参数传入所有权，然后再通过函数返回来传出所有权，代码更加简洁</li>
<li>calculate_length 的参数 s 类型从 String 变为 &amp;String<br>这里，&amp; 符号即是引用，它们允许你使用值，但是不获取所有权，如图所示：<br><img src="/../images/Borrowing.png"><br>通过 &amp;s1 语法，我们创建了一个指向 s1 的引用，但是并不拥有它。因为并不拥有这个值，当引用离开作用域后，其指向的值也不会被丢弃。</li>
</ol>
<p>同理，函数 calculate_length 使用 &amp; 来表明参数 s 的类型是一个引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn calculate_length(s: &amp;String) -&gt; usize &#123; // s 是对 String 的引用</span><br><span class="line">    s.len()</span><br><span class="line">&#125; // 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，</span><br><span class="line">  // 所以什么也不会发生</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>人总是贪心的，可以拉女孩小手了，就想着抱抱柔软的身子（读者中的某老司机表示，这个流程完全不对），因此光借用已经满足不了我们了，如果尝试修改借用的变量呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    change(&amp;s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn change(some_string: &amp;String) &#123;</span><br><span class="line">    some_string.push_str(&quot;, world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很不幸，妹子你没抱到，哦口误，你修改错了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference</span><br><span class="line"> --&gt; src/main.rs:8:5</span><br><span class="line">  |</span><br><span class="line">8 |     some_string.push_str(&quot;, world&quot;);</span><br><span class="line">  |     ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable</span><br><span class="line">  |</span><br><span class="line">help: consider changing this to be a mutable reference</span><br><span class="line">  |</span><br><span class="line">7 | fn change(some_string: &amp;mut String) &#123;</span><br><span class="line">  |                         +++</span><br><span class="line"></span><br><span class="line">error: aborting due to 1 previous error</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0596`.</span><br></pre></td></tr></table></figure>
<p>正如变量默认不可变一样，引用指向的值默认也是不可变的，没事，来一起看看如何解决这个问题。</p>
<h1 id="2-可变引用"><a href="#2-可变引用" class="headerlink" title="2.可变引用"></a>2.可变引用</h1><p>只需要一个小调整，即可修复上面代码的错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    change(&amp;mut s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn change(some_string: &amp;mut String) &#123;</span><br><span class="line">    some_string.push_str(&quot;, world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，声明 s 是可变类型，其次创建一个可变的引用 &amp;mut s 和接受可变引用参数 some_string: &amp;mut String 的函数。<br><strong>可变引用同时只能存在一个</strong><br>不过可变引用并不是随心所欲、想用就用的，它有一个很大的限制： 同一作用域，特定数据只能有一个可变引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let mut s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">let r1 = &amp;mut s;</span><br><span class="line">let r2 = &amp;mut s;</span><br><span class="line"></span><br><span class="line">println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);</span><br></pre></td></tr></table></figure>
<p>以上代码会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">error[E0499]: cannot borrow `s` as mutable more than once at a time</span><br><span class="line"> --&gt; src/main.rs:5:14</span><br><span class="line">  |</span><br><span class="line">4 |     let r1 = &amp;mut s;</span><br><span class="line">  |              ------ first mutable borrow occurs here</span><br><span class="line">5 |     let r2 = &amp;mut s;</span><br><span class="line">  |              ^^^^^^ second mutable borrow occurs here</span><br><span class="line">6 |     </span><br><span class="line">7 |     println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);</span><br><span class="line">  |                        -- first borrow later used here</span><br><span class="line"></span><br><span class="line">error: aborting due to 1 previous error</span><br></pre></td></tr></table></figure>
<p>这段代码出错的原因在于，第一个可变借用 r1 必须要持续到最后一次使用的位置 println!，在 r1 创建和最后一次使用之间，我们又尝试创建第二个可变借用 r2。</p>
<p>对于新手来说，这个特性绝对是一大拦路虎，也是新人们谈之色变的编译器 borrow checker 特性之一，不过各行各业都一样，限制往往是出于安全的考虑，Rust 也一样。</p>
<p>这种限制的好处就是使 Rust 在编译期就避免数据竞争，数据竞争可由以下行为造成：</p>
<ul>
<li>两个或更多的指针同时访问同一数据</li>
<li>至少有一个指针被用来写入数据</li>
<li>没有同步数据访问的机制<br>数据竞争会导致未定义行为，这种行为很可能超出我们的预期，难以在运行时追踪，并且难以诊断和修复。而 Rust 避免了这种情况的发生，因为它甚至不会编译存在数据竞争的代码！</li>
</ul>
<p>很多时候，大括号可以帮我们解决一些编译不通过的问题，通过手动限制变量的作用域：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let mut s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    let r1 = &amp;mut s;</span><br><span class="line"></span><br><span class="line">&#125; // r1 在这里离开了作用域，所以我们完全可以创建一个新的引用</span><br><span class="line"></span><br><span class="line">let r2 = &amp;mut s;</span><br></pre></td></tr></table></figure>
<p><strong>可变引用与不可变引用不能同时存在</strong><br>下面的代码会导致一个错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let mut s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">let r1 = &amp;s; // 没问题</span><br><span class="line">let r2 = &amp;s; // 没问题</span><br><span class="line">let r3 = &amp;mut s; // 大问题</span><br><span class="line"></span><br><span class="line">println!(&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;, r1, r2, r3);</span><br></pre></td></tr></table></figure>
<p>错误如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable</span><br><span class="line"> --&gt; src/main.rs:6:14</span><br><span class="line">  |</span><br><span class="line">4 |     let r1 = &amp;s; // 没问题</span><br><span class="line">  |              -- immutable borrow occurs here</span><br><span class="line">5 |     let r2 = &amp;s; // 没问题</span><br><span class="line">6 |     let r3 = &amp;mut s; // 大问题</span><br><span class="line">  |              ^^^^^^ mutable borrow occurs here</span><br><span class="line">7 |     </span><br><span class="line">8 |     println!(&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;, r1, r2, r3);</span><br><span class="line">  |                                -- immutable borrow later used here</span><br><span class="line"></span><br><span class="line">error: aborting due to 1 previous error</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0502`.</span><br></pre></td></tr></table></figure>
<p>其实这个也很好理解，正在借用不可变引用的用户，肯定不希望他借用的东西，被另外一个人莫名其妙改变了。多个不可变借用被允许是因为没有人会去试图修改数据，每个人都只读这一份数据而不做修改，因此不用担心数据被污染。</p>
<table>
    <tr>
        <td bgcolor=#F0F8FF>
            注意，引用的作用域 s 从创建开始，一直持续到它最后一次使用的地方，这个跟变量的作用域有所不同，变量的作用域从创建持续到某一个花括号 }
        </td>
    </tr>
</table>

<p>Rust 的编译器一直在优化，早期的时候，引用的作用域跟变量作用域是一致的，这对日常使用带来了很大的困扰，你必须非常小心的去安排可变、不可变变量的借用，免得无法通过编译，例如以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">   let mut s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    let r1 = &amp;s;</span><br><span class="line">    let r2 = &amp;s;</span><br><span class="line">    println!(&quot;&#123;&#125; and &#123;&#125;&quot;, r1, r2);</span><br><span class="line">    // 新编译器中，r1,r2作用域在这里结束</span><br><span class="line"></span><br><span class="line">    let r3 = &amp;mut s;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, r3);</span><br><span class="line">&#125; // 老编译器中，r1、r2、r3作用域在这里结束</span><br><span class="line">  // 新编译器中，r3作用域在这里结束</span><br></pre></td></tr></table></figure>
<p>在老版本的编译器中（Rust 1.31 前），将会报错，因为 r1 和 r2 的作用域在花括号 } 处结束，那么 r3 的借用就会触发 <strong>无法同时借用可变和不可变</strong>的规则。<br>但是在新的编译器中，该代码将顺利通过，因为 引用作用域的结束位置从花括号变成最后一次使用的位置，因此 r1 借用和 r2 借用在 println! 后，就结束了，此时 r3 可以顺利借用到可变引用。</p>
<h1 id="3-NULL"><a href="#3-NULL" class="headerlink" title="3.NULL"></a>3.NULL</h1><p>对于这种编译器优化行为，Rust 专门起了一个名字 —— Non-Lexical Lifetimes(NLL)，专门用于找到某个引用在作用域(})结束前就不再被使用的代码位置。</p>
<p>虽然这种借用错误有的时候会让我们很郁闷，但是你只要想想这是 Rust 提前帮你发现了潜在的 BUG，其实就开心了，虽然减慢了开发速度，但是从长期来看，大幅减少了后续开发和运维成本。</p>
<h1 id="4-悬垂引用-Dangling-References"><a href="#4-悬垂引用-Dangling-References" class="headerlink" title="4.悬垂引用(Dangling References)"></a>4.悬垂引用(Dangling References)</h1><p>悬垂引用也叫做悬垂指针，意思为指针指向某个值后，这个值被释放掉了，而指针仍然存在，其指向的内存可能不存在任何值或已被其它变量重新使用。在 Rust 中编译器可以确保引用永远也不会变成悬垂状态：当你获取数据的引用后，编译器可以确保数据不会在引用结束前被释放，要想释放数据，必须先停止其引用的使用。</p>
<p>让我们尝试创建一个悬垂引用，Rust 会抛出一个编译时错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let reference_to_nothing = dangle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn dangle() -&gt; &amp;String &#123;</span><br><span class="line">    let s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    &amp;s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> --&gt; src/main.rs:5:16</span><br><span class="line">  |</span><br><span class="line">5 | fn dangle() -&gt; &amp;String &#123;</span><br><span class="line">  |                ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">  = help: this function&#x27;s return type contains a borrowed value, but there is no value for it to be borrowed from</span><br><span class="line">help: consider using the `&#x27;static` lifetime, but this is uncommon unless you&#x27;re returning a borrowed value from a `const` or a `static`</span><br><span class="line">  |</span><br><span class="line">5 | fn dangle() -&gt; &amp;&#x27;static String &#123;</span><br><span class="line">  |                 +++++++</span><br><span class="line">help: instead, you are more likely to want to return an owned value</span><br><span class="line">  |</span><br><span class="line">5 - fn dangle() -&gt; &amp;String &#123;</span><br><span class="line">5 + fn dangle() -&gt; String &#123;</span><br><span class="line">  |</span><br><span class="line"></span><br><span class="line">warning: unused variable: `reference_to_nothing`</span><br><span class="line"> --&gt; src/main.rs:2:9</span><br><span class="line">  |</span><br><span class="line">2 |     let reference_to_nothing = dangle();</span><br><span class="line">  |         ^^^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_reference_to_nothing`</span><br><span class="line">  |</span><br><span class="line">  = note: `#[warn(unused_variables)]` on by default</span><br><span class="line"></span><br><span class="line">error[E0515]: cannot return reference to local variable `s`</span><br><span class="line"> --&gt; src/main.rs:8:5</span><br><span class="line">  |</span><br><span class="line">8 |     &amp;s</span><br><span class="line">  |     ^^ returns a reference to data owned by the current function</span><br><span class="line"></span><br><span class="line">error: aborting due to 2 previous errors; 1 warning emitted</span><br><span class="line"></span><br><span class="line">Some errors have detailed explanations: E0106, E0515.</span><br><span class="line">For more information about an error, try `rustc --explain E0106`.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>错误信息引用了一个我们还未介绍的功能：<strong>生命周期(lifetimes)</strong>。不过，即使你不理解生命周期，也可以通过错误信息知道这段代码错误的关键信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this function&#x27;s return type contains a borrowed value, but there is no value for it to be borrowed from.</span><br><span class="line">该函数返回了一个借用的值，但是已经找不到它所借用值的来源</span><br></pre></td></tr></table></figure>
<p>仔细看看 dangle 代码的每一步到底发生了什么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn dangle() -&gt; &amp;String &#123; // dangle 返回一个字符串的引用</span><br><span class="line"></span><br><span class="line">    let s = String::from(&quot;hello&quot;); // s 是一个新字符串</span><br><span class="line"></span><br><span class="line">    &amp;s // 返回字符串 s 的引用</span><br><span class="line">&#125; // 这里 s 离开作用域并被丢弃。其内存被释放。</span><br><span class="line">  // 危险！</span><br></pre></td></tr></table></figure>
<p>因为 s 是在 dangle 函数内创建的，当 dangle 的代码执行完毕后，s 将被释放，但是此时我们又尝试去返回它的引用。这意味着这个引用会指向一个无效的 String，这可不对！</p>
<p>其中一个很好的解决方法是直接返回 String：<br>fn no_dangle() -&gt; String {<br>    let s &#x3D; String::from(“hello”);</p>
<pre><code>s
</code></pre>
<p>}<br>这样就没有任何错误了，最终 String 的 <strong>所有权被转移给外面的调用者。</strong></p>
<h1 id="5-切片-slice"><a href="#5-切片-slice" class="headerlink" title="5.切片(slice)"></a>5.切片(slice)</h1><ul>
<li>字符串切片</li>
<li>数组切片</li>
</ul>
<p>切片并不是 Rust 独有的概念，在 Go 语言中就非常流行，它允许你引用集合中部分连续的元素序列，而不是引用整个集合。</p>
<p>对于字符串而言，切片就是对 String 类型中某一部分的引用，它看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let s = String::from(&quot;hello world&quot;);</span><br><span class="line"></span><br><span class="line">let hello = &amp;s[0..5];</span><br><span class="line">let world = &amp;s[6..11];</span><br></pre></td></tr></table></figure>
<p>hello 没有引用整个 String s，而是引用了 s 的一部分内容，通过 [0..5] 的方式来指定。</p>
<p>这就是创建切片的语法，使用方括号包括的一个序列：[开始索引..终止索引]，其中开始索引是切片中第一个元素的索引位置，而终止索引是最后一个元素后面的索引位置，也就是这是一个 右半开区间。在切片数据结构内部会保存开始的位置和切片的长度，其中长度是通过 终止索引 - 开始索引 的方式计算得来的。</p>
<p>对于 let world &#x3D; &amp;s[6..11]; 来说，world 是一个切片，该切片的指针指向 s 的第 7 个字节(索引从 0 开始, 6 是第 7 个字节)，且该切片的长度是 5 个字节。<br><img src="/../images/slice.png"><br>在使用 Rust 的 .. range 序列语法时，如果你想从索引 0 开始，可以使用如下的方式，这两个是等效的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">let slice = &amp;s[0..2];</span><br><span class="line">let slice = &amp;s[..2];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同样的，如果你的切片想要包含 String 的最后一个字节，则可以这样使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">let len = s.len();</span><br><span class="line"></span><br><span class="line">let slice = &amp;s[4..len];</span><br><span class="line">let slice = &amp;s[4..];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你也可以截取完整的 String 切片：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">let len = s.len();</span><br><span class="line"></span><br><span class="line">let slice = &amp;s[0..len];</span><br><span class="line">let slice = &amp;s[..];</span><br></pre></td></tr></table></figure>

<table>
    <tr>
        <td bgcolor=#F0F8FF>
            在对字符串使用切片语法时需要格外小心，切片的索引必须落在字符之间的边界位置，也就是 UTF-8 字符的边界，例如中文在 UTF-8 中占用三个字节，下面的代码就会崩溃：

<pre><code>        let s = &quot;中国人&quot;;
        let a = &amp;s[0..2];
        println!(&quot;&#123;&#125;&quot;,a);
        因为我们只取 s 字符串的前两个字节，但是本例中每个汉字占用三个字节，因此没有落在边界处，也就是连 中 字都取不完整，此时程序会直接崩溃退出，如果改成 &amp;s[0..3]，则可以正常通过编译。 因此，当你需要对字符串做切片索引操作时，需要格外小心这一点, 关于该如何操作 UTF-8 字符串
    &lt;/td&gt;
&lt;/tr&gt;
</code></pre>
</table>
字符串切片的类型标识是 &str，因此我们可以这样声明一个函数，输入 String 类型，返回它的切片: fn first_word(s: &String) -> &str 。
有了切片就可以写出这样的代码：

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello world&quot;);</span><br><span class="line"></span><br><span class="line">    let word = first_word(&amp;s);</span><br><span class="line"></span><br><span class="line">    s.clear(); // error!</span><br><span class="line"></span><br><span class="line">    println!(&quot;the first word is: &#123;&#125;&quot;, word);</span><br><span class="line">&#125;</span><br><span class="line">fn first_word(s: &amp;String) -&gt; &amp;str &#123;</span><br><span class="line">    &amp;s[..1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器报错如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable</span><br><span class="line"> --&gt; src/main.rs:6:5</span><br><span class="line">  |</span><br><span class="line">4 |     let word = first_word(&amp;s);</span><br><span class="line">  |                           -- immutable borrow occurs here</span><br><span class="line">5 |</span><br><span class="line">6 |     s.clear(); // error!</span><br><span class="line">  |     ^^^^^^^^^ mutable borrow occurs here</span><br><span class="line">7 |</span><br><span class="line">8 |     println!(&quot;the first word is: &#123;&#125;&quot;, word);</span><br><span class="line">  |                                       ---- immutable borrow later used here</span><br><span class="line"></span><br><span class="line">error: aborting due to 1 previous error</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0502`.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>回忆一下借用的规则：当我们已经有了可变借用时，就无法再拥有不可变的借用。因为 clear 需要清空改变 String，因此它需要一个可变借用（利用 VSCode 可以看到该方法的声明是 pub fn clear(&amp;mut self) ，参数是对自身的可变借用 ）；而之后的 println! 又使用了不可变借用，也就是在 s.clear() 处可变借用与不可变借用试图同时生效，因此编译无法通过。</p>
<p>从上述代码可以看出，Rust 不仅让我们的 API 更加容易使用，而且也在编译期就消除了大量错误！</p>
<h2 id="5-1其它切片"><a href="#5-1其它切片" class="headerlink" title="5.1其它切片"></a>5.1其它切片</h2><p>因为切片是对集合的部分引用，因此不仅仅字符串有切片，其它集合类型也有，例如数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">let slice = &amp;a[1..3];</span><br><span class="line"></span><br><span class="line">assert_eq!(slice, &amp;[2, 3]);</span><br></pre></td></tr></table></figure>
<p>该数组切片的类型是 &amp;[i32]，数组切片和字符串切片的工作方式是一样的，例如持有一个引用指向原始数组的某个元素和长度。</p>
<h1 id="6-生命周期"><a href="#6-生命周期" class="headerlink" title="6.生命周期"></a>6.生命周期</h1><blockquote>
<blockquote>
<p>dangling referencing<br>生命周期是Rust用来保证引用有效性的机制.生命周期注解允许编译器推断引用的有效范围,确保在引用仍然有效时使用它们.</p>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn test_dangling_pointer() &#123;</span><br><span class="line">    let a = get_a();</span><br><span class="line"></span><br><span class="line">    fn get_a() -&gt; &amp;String &#123;</span><br><span class="line">        &amp;&quot;a&quot;.to_string()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-借用规则总结"><a href="#7-借用规则总结" class="headerlink" title="7.借用规则总结"></a>7.借用规则总结</h1><p>总的来说，借用规则如下：</p>
<ul>
<li>同一时刻，你只能拥有要么一个可变引用, 要么任意多个不可变引用</li>
<li>引用必须总是有效的</li>
</ul>
<h1 id="8-课后习题"><a href="#8-课后习题" class="headerlink" title="8.课后习题"></a>8.课后习题</h1><p>1. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">   let x = 5;</span><br><span class="line">   // 填写空白处</span><br><span class="line">   let p = __;</span><br><span class="line"></span><br><span class="line">   println!(&quot;x 的内存地址是 &#123;:p&#125;&quot;, p); // output: 0x16fa3ac84</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let x = 5;</span><br><span class="line">    // 填写空白处</span><br><span class="line">    let p = &amp;x;</span><br><span class="line"> </span><br><span class="line">    println!(&quot;x 的内存地址是 &#123;:p&#125;&quot;, p); // output: 0x16fa3ac84</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>2. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = 5;</span><br><span class="line">    let y = &amp;x;</span><br><span class="line"></span><br><span class="line">    // 只能修改以下行</span><br><span class="line">    assert_eq!(5, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let x = 5;</span><br><span class="line">    let y = &amp;x;</span><br><span class="line"></span><br><span class="line">    // 只能修改以下行</span><br><span class="line">    assert_eq!(5, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 修复错误</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    borrow_object(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn borrow_object(s: &amp;String) &#123;&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    borrow_object(&amp;s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn borrow_object(s: &amp;String) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>4. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 修复错误</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    push_str(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn push_str(s: &amp;mut String) &#123;</span><br><span class="line">    s.push_str(&quot;world&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    push_str(&amp;mut s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn push_str(s: &amp;mut String) &#123;</span><br><span class="line">    s.push_str(&quot;world&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ref<br>ref 与 &amp; 类似，可以用来获取一个值的引用，但是它们的用法有所不同。<br>5. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    // 填写空白处，让代码工作</span><br><span class="line">    let p = __;</span><br><span class="line">    </span><br><span class="line">    p.push_str(&quot;world&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    // 填写空白处，让代码工作</span><br><span class="line">    let p = &amp;mut s;</span><br><span class="line">    </span><br><span class="line">    p.push_str(&quot;world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let c = &#x27;中&#x27;;</span><br><span class="line"></span><br><span class="line">    let r1 = &amp;c;</span><br><span class="line">    // 填写空白处，但是不要修改其它行的代码</span><br><span class="line">    let __ r2 = c;</span><br><span class="line"></span><br><span class="line">    assert_eq!(*r1, *r2);</span><br><span class="line">    </span><br><span class="line">    // 判断两个内存地址的字符串是否相等</span><br><span class="line">    assert_eq!(get_addr(r1),get_addr(r2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取传入引用的内存地址的字符串形式</span><br><span class="line">fn get_addr(r: &amp;char) -&gt; String &#123;</span><br><span class="line">    format!(&quot;&#123;:p&#125;&quot;, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let c = &#x27;中&#x27;;</span><br><span class="line"></span><br><span class="line">    let r1 = &amp;c;</span><br><span class="line">    // 填写空白处，但是不要修改其它行的代码</span><br><span class="line">    let ref r2 = c;</span><br><span class="line"></span><br><span class="line">    assert_eq!(*r1, *r2);</span><br><span class="line">    </span><br><span class="line">    // 判断两个内存地址的字符串是否相等</span><br><span class="line">    assert_eq!(get_addr(r1),get_addr(r2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取传入引用的内存地址的字符串形式</span><br><span class="line">fn get_addr(r: &amp;char) -&gt; String &#123;</span><br><span class="line">    format!(&quot;&#123;:p&#125;&quot;, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>借用规则<br>7. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 移除代码某个部分，让它工作</span><br><span class="line">// 你不能移除整行的代码！</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    let r1 = &amp;mut s;</span><br><span class="line">    let r2 = &amp;mut s;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    let r1 =  &amp;s;</span><br><span class="line">    let r2 =  &amp;s;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可变性<br>8.  🌟 错误: 从不可变对象借用可变</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    // 通过修改下面一行代码来修复错误</span><br><span class="line">    let  s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    borrow_object(&amp;mut s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn borrow_object(s: &amp;mut String) &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    // 通过修改下面一行代码来修复错误</span><br><span class="line">    let  mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    borrow_object(&amp;mut s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn borrow_object(s: &amp;mut String) &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li><p>🌟🌟 Ok: 从可变对象借用不可变 不用修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 下面的代码没有任何错误</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    borrow_object(&amp;s);</span><br><span class="line">    </span><br><span class="line">    s.push_str(&quot;world&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn borrow_object(s: &amp;String) &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>NLL</p>
</li>
<li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 注释掉一行代码让它工作</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    let r1 = &amp;mut s;</span><br><span class="line">    r1.push_str(&quot;world&quot;);</span><br><span class="line">    let r2 = &amp;mut s;</span><br><span class="line">    r2.push_str(&quot;!&quot;);</span><br><span class="line">    </span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,r1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    let r1 = &amp;mut s;</span><br><span class="line">    r1.push_str(&quot;world&quot;);</span><br><span class="line">    let r2 = &amp;mut s;</span><br><span class="line">    r2.push_str(&quot;!&quot;);</span><br><span class="line">    </span><br><span class="line">    //println!(&quot;&#123;&#125;&quot;,r1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    let r1 = &amp;mut s;</span><br><span class="line">    let r2 = &amp;mut s;</span><br><span class="line"></span><br><span class="line">    // 在下面增加一行代码人为制造编译错误：cannot borrow `s` as mutable more than once at a time</span><br><span class="line">    // 你不能同时使用 r1 和 r2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    let r1 = &amp;mut s;</span><br><span class="line">    let r2 = &amp;mut s;</span><br><span class="line"></span><br><span class="line">    //print!(&quot;&#123;&#125; &#123;&#125;&quot;, r1, r2);</span><br><span class="line">    // r1.push_str(&quot;world&quot;);</span><br><span class="line">    print!(&quot;&#123;&#125; &#123;&#125; &quot;, r1, s);</span><br><span class="line">    // 在下面增加一行代码人为制造编译错误：cannot borrow `s` as mutable more than once at a time</span><br><span class="line">    // 你不能同时使用 r1 和 r2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fn test_lifetime() &#123;</span><br><span class="line">    let large = longest(&quot;a&quot;, &quot;ab&quot;);</span><br><span class="line">    println!(&quot;large one is &#123;large&#125;&quot;);</span><br><span class="line"></span><br><span class="line">    fn longest(x:&amp;str, y:&amp;str) -&gt; &amp;str &#123;</span><br><span class="line">        if x.len() &gt; y.len() &#123;</span><br><span class="line">            x</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            y</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    test_lifetime();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn test_lifetime() &#123;</span><br><span class="line">    let large = longest(&quot;a&quot;, &quot;ab&quot;);</span><br><span class="line">    println!(&quot;large one is &#123;large&#125;&quot;);</span><br><span class="line"></span><br><span class="line">    fn longest&lt;&#x27;a&gt;(x:&amp;&#x27;a str, y:&amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123;</span><br><span class="line">        if x.len() &gt; y.len() &#123;</span><br><span class="line">            x</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            y</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    test_lifetime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/21/learnRust6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Byte的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/21/learnRust6/" itemprop="url">Rust入门-基础 第六节 所有权</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-08-21T01:13:46+08:00">
                2024-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<blockquote>
<p>零开销内存回收的一种高效实现方式<br>Rust是一种系统编程语言,其设计目的是确保内存安全并防止数据竞争,而不依赖垃圾回收器。这种内存安全性只要通过所有权系统来实现。</p>
</blockquote>
</blockquote>
<h1 id="1内存回收"><a href="#1内存回收" class="headerlink" title="1内存回收"></a>1内存回收</h1><blockquote>
<blockquote>
<p>硬件内存大小受限，数据泄露 隐私安全</p>
</blockquote>
</blockquote>
<h2 id="1-1-主流编程语言的内存回收机制对比"><a href="#1-1-主流编程语言的内存回收机制对比" class="headerlink" title="1.1 主流编程语言的内存回收机制对比"></a>1.1 主流编程语言的内存回收机制对比</h2><p>所有的程序都必须和计算机内存打交道，如何从内存中申请空间来存放程序的运行内容，如何在不需要的时候释放这些空间，成了重中之重，也是所有编程语言设计的难点之一。在计算机语言不断演变过程中，出现了三种流派：</p>
<ul>
<li><strong>垃圾回收机制(GC)</strong>，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go</li>
<li><strong>手动管理内存的分配和释放</strong>, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++</li>
<li><strong>通过所有权来管理内存</strong>，编译器在编译时会根据一系列规则进行检查<br>其中 Rust 选择了第三种，最妙的是，这种检查只发生在编译期，因此对于程序运行期，不会有任何性能上的损失。</li>
</ul>
<p>由于所有权是一个新概念，因此读者需要花费一些时间来掌握它，一旦掌握，海阔天空任你飞跃，在本章，我们将通过 字符串 来引导讲解所有权的相关知识。</p>
<p>一段不安全的代码<br>先来看看一段来自 C 语言的糟糕代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int* foo() &#123;</span><br><span class="line">    int a;          // 变量a的作用域开始</span><br><span class="line">    a = 100;</span><br><span class="line">    char *c = &quot;xyz&quot;;   // 变量c的作用域开始</span><br><span class="line">    return &amp;a;</span><br><span class="line">&#125;                   // 变量a和c的作用域结束</span><br></pre></td></tr></table></figure>
<p>这段代码虽然可以编译通过，但是其实非常糟糕，变量 a 和 c 都是局部变量，函数结束后将局部变量 a 的地址返回，但局部变量 a 存在栈中，在离开作用域后，a 所申请的栈上内存都会被系统回收，从而造成了 悬空指针(Dangling Pointer) 的问题。这是一个非常典型的内存安全问题，虽然编译可以通过，但是运行的时候会出现错误, 很多编程语言都存在。</p>
<p>再来看变量 c，c 的值是常量字符串，存储于常量区，可能这个函数我们只调用了一次，也可能我们不再会使用这个字符串，但 “xyz” 只有当整个程序结束后系统才能回收这片内存。</p>
<h2 id="1-1-1-C-C"><a href="#1-1-1-C-C" class="headerlink" title="1.1.1 C&#x2F;C++"></a>1.1.1 C&#x2F;C++</h2><ul>
<li>特点<ul>
<li>程序员通过malloc和free 或者 new delete 手动分配和释放内存</li>
<li>没有内置的垃圾回收机制</li>
</ul>
</li>
<li>优点<ul>
<li>高效灵活 适用于对性能要求极高的系统级编程</li>
</ul>
</li>
<li>缺点<ul>
<li>容易出现内存泄漏 悬垂指针和缓冲区溢出等问题 需要非常小心的处理   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 释放分配的内存</span><br><span class="line">free(ptr);ptr = NULL;//将指针设置为NULL 避免悬空指针</span><br><span class="line">// 动态分配一个数组的内存</span><br><span class="line">int n = 5;int *arr = (int *)malloc(n * sizeof(int));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="1-1-2-JavaScript"><a href="#1-1-2-JavaScript" class="headerlink" title="1.1.2 JavaScript"></a>1.1.2 JavaScript</h2><ul>
<li>内存管理方式：垃圾回收</li>
<li>特点<ul>
<li>浏览器和Node.js环境中均使用垃圾回收器(如V8引擎的垃圾回收器)</li>
<li>采用标记-清除(Mark-and-Sweep) 标记-压缩（Mark-and-Compact）分代回收等算法</li>
</ul>
</li>
<li>优点：<ul>
<li>自动内存管理 适合快速开发和运行在多平台上的应用</li>
</ul>
</li>
<li>缺点：<ul>
<li>垃圾回收机制在某些情况下可能导致性能问题 如UI线程停顿</li>
</ul>
</li>
</ul>
<p>所以内存安全问题，一直都是程序员非常头疼的问题，好在, 在 Rust 中这些问题即将成为历史，因为 Rust 在编译的时候就可以帮助我们发现内存不安全的问题，那 Rust 如何做到这一点呢？</p>
<p>在正式进入主题前，先来一个预热知识。</p>
<h2 id="1-2-栈-Stack-与堆-Heap"><a href="#1-2-栈-Stack-与堆-Heap" class="headerlink" title="1.2 栈(Stack)与堆(Heap)"></a>1.2 栈(Stack)与堆(Heap)</h2><p>栈和堆是编程语言最核心的数据结构，但是在很多语言中，你并不需要深入了解栈与堆。 但对于 Rust 这样的系统编程语言，值是位于栈上还是堆上非常重要, 因为这会影响程序的行为和性能。</p>
<p>栈和堆的核心目标就是为程序在运行时提供可供使用的内存空间。</p>
<h3 id="1-2-1-栈"><a href="#1-2-1-栈" class="headerlink" title="1.2.1 栈"></a>1.2.1 栈</h3><p>栈按照顺序存储值并以相反顺序取出值，这也被称作后进先出。想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，再从顶部拿走。不能从中间也不能从底部增加或拿走盘子！</p>
<p>增加数据叫做进栈，移出数据则叫做出栈。</p>
<p>因为上述的实现方式，栈中的所有数据都必须占用已知且固定大小的内存空间，假设数据大小是未知的，那么在取出数据时，你将无法取到你想要的数据。</p>
<h3 id="1-2-2-堆"><a href="#1-2-2-堆" class="headerlink" title="1.2.2 堆"></a>1.2.2 堆</h3><p>与栈不同，对于大小未知或者可能变化的数据，我们需要将它存储在堆上。</p>
<p>当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的指针, 该过程被称为在堆上分配内存，有时简称为 “分配”(allocating)。</p>
<p>接着，该指针会被推入栈中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的指针，来获取数据在堆上的实际内存位置，进而访问该数据。</p>
<p>由上可知，堆是一种缺乏组织的数据结构。想象一下去餐馆就座吃饭: 进入餐馆，告知服务员有几个人，然后服务员找到一个够大的空桌子（堆上分配的内存空间）并领你们过去。如果有人来迟了，他们也可以通过桌号（栈上的指针）来找到你们坐在哪。</p>
<h3 id="1-2-3-性能区别"><a href="#1-2-3-性能区别" class="headerlink" title="1.2.3 性能区别"></a>1.2.3 性能区别</h3><p>在栈上分配内存比在堆上分配内存要快，因为入栈时操作系统无需进行函数调用（或更慢的系统调用）来分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备，如果当前进程分配的内存页不足时，还需要进行系统调用来申请更多内存。 因此，处理器在栈上分配数据会比在堆上分配数据更加高效。</p>
<h3 id="1-2-4-所有权与堆栈"><a href="#1-2-4-所有权与堆栈" class="headerlink" title="1.2.4 所有权与堆栈"></a>1.2.4 所有权与堆栈</h3><p>当你的代码调用一个函数时，传递给函数的参数（包括可能指向堆上数据的指针和函数的局部变量）依次被压入栈中，当函数调用结束时，这些值将被从栈中按照相反的顺序依次移除。</p>
<p>因为堆上的数据缺乏组织，因此跟踪这些数据何时分配和释放是非常重要的，否则堆上的数据将产生内存泄漏 —— 这些数据将永远无法被回收。这就是 Rust 所有权系统为我们提供的强大保障。</p>
<p>对于其他很多编程语言，你确实无需理解堆栈的原理，但是在 Rust 中，明白堆栈的原理，对于我们理解所有权的工作原理会有很大的帮助。</p>
<h1 id="2-所有权原则"><a href="#2-所有权原则" class="headerlink" title="2.所有权原则"></a>2.所有权原则</h1><p>理解了堆栈，接下来看一下关于所有权的规则，首先请谨记以下规则：</p>
<table>
    <tr>
        <td bgcolor=#F0F8FF>
        1. Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
        2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
        3. 当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)
        </td>
    </tr>
</table>

<h1 id="3-变量作用域"><a href="#3-变量作用域" class="headerlink" title="3.变量作用域"></a>3.变量作用域</h1><p>作用域是一个变量在程序中有效的范围, 假如有这样一个变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let s = &quot;hello&quot;;</span><br></pre></td></tr></table></figure>

<p>变量 s 绑定到了一个字符串字面值，该字符串字面值是硬编码到程序代码中的。s 变量从声明的点开始直到当前作用域的结束都是有效的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;                      // s 在这里无效，它尚未声明</span><br><span class="line">    let s = &quot;hello&quot;;   // 从此处起，s 是有效的</span><br><span class="line"></span><br><span class="line">    // 使用 s</span><br><span class="line">&#125;                      // 此作用域已结束，s不再有效</span><br></pre></td></tr></table></figure>
<p>简而言之，s 从创建开始就有效，然后有效期持续到它离开作用域为止，可以看出，就作用域来说，Rust 语言跟其他编程语言没有区别。</p>
<p>简单介绍 String 类型<br>之前提到过，本章会用 String 作为例子，因此这里会进行一下简单的介绍，具体的 String 学习请参见 String 类型。</p>
<p>我们已经见过字符串字面值 let s &#x3D;”hello”，s 是被硬编码进程序里的字符串值（类型为 &amp;str ）。字符串字面值是很方便的，但是它并不适用于所有场景。原因有二：</p>
<p><strong>字符串字面值是不可变的</strong>，因为被硬编码到程序代码中<br>并非所有字符串的值都能在编写代码时得知<br>例如，字符串是需要程序运行时，通过用户动态输入然后存储在内存中的，这种情况，字符串字面值就完全无用武之地。 为此，Rust 为我们提供动态字符串类型: String, 该类型被分配到堆上，因此可以动态伸缩，也就能存储在编译时大小未知的文本。</p>
<p>可以使用下面的方法基于字符串字面量来创建 String 类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let s = String::from(&quot;hello&quot;);</span><br></pre></td></tr></table></figure>
<p>:: 是一种调用操作符，这里表示调用 String 模块中的 from 方法，由于 String 类型存储在堆上，因此它是动态的，你可以这样修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let mut s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">s.push_str(&quot;, world!&quot;); // push_str() 在字符串后追加字面值</span><br><span class="line"></span><br><span class="line">println!(&quot;&#123;&#125;&quot;, s); // 将打印 `hello, world!`</span><br></pre></td></tr></table></figure>
<p>言归正传，了解 String 后，一起来看看关于所有权的交互。</p>
<h1 id="4-变量绑定背后的数据交互"><a href="#4-变量绑定背后的数据交互" class="headerlink" title="4.变量绑定背后的数据交互"></a>4.变量绑定背后的数据交互</h1><h2 id="4-1转移所有权"><a href="#4-1转移所有权" class="headerlink" title="4.1转移所有权"></a>4.1转移所有权</h2><p>先来看一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let x = 5;</span><br><span class="line">let y = x;</span><br></pre></td></tr></table></figure>
<p>这段代码并没有发生所有权的转移，原因很简单： 代码首先将 5 绑定到变量 x，接着<strong>拷贝</strong> x 的值赋给 y，最终 x 和 y 都等于 5，因为整数是 Rust 基本数据类型，是固定大小的简单值，因此这两个值都是通过<strong>自动拷贝</strong>的方式来赋值的，都被存在栈中，完全无需在堆上分配内存。</p>
<p>整个过程中的赋值都是通过值拷贝的方式完成(发生在栈中)，因此并不需要所有权转移。</p>
<p>可能有同学会有疑问：这种拷贝不消耗性能吗？实际上，这种栈上的数据足够简单，而且拷贝非常非常快，只需要复制一个整数大小（i32，4 个字节）的内存即可，因此在这种情况下，拷贝的速度远比在堆上创建内存来得快的多。实际上，上一章我们讲到的 Rust 基本类型都是通过自动拷贝的方式来赋值的，就像上面代码一样。</p>
<p>然后再来看一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let s1 = String::from(&quot;hello&quot;);</span><br><span class="line">let s2 = s1;</span><br></pre></td></tr></table></figure>
<p>此时，可能某个大聪明( 善意昵称 )已经想到了：嗯，上面一样，把 s1 的内容拷贝一份赋值给 s2，实际上，并不是这样。之前也提到了，对于基本类型（存储在栈上），Rust 会自动拷贝，但是 String 不是基本类型，而且是存储在堆上的，因此不能自动拷贝。</p>
<p>实际上， String 类型是一个复杂类型，由存储在栈中的<strong>堆指针、字符串长度、字符串容量</strong>共同组成，其中<strong>堆指针</strong>是最重要的，它指向了真实存储字符串内容的堆内存，至于长度和容量，如果你有 Go 语言的经验，这里就很好理解：容量是堆内存分配空间的大小，长度是目前已经使用的大小。</p>
<p>总之 String 类型指向了一个堆上的空间，这里存储着它的真实数据，下面对上面代码中的 let s2 &#x3D; s1 分成两种情况讨论：</p>
<p>拷贝 String 和存储在堆上的字节数组 如果该语句是拷贝所有数据(深拷贝)，那么无论是 String 本身还是底层的堆上数据，都会被全部拷贝，这对于性能而言会造成非常大的影响</p>
<p>只拷贝 String 本身 这样的拷贝非常快，因为在 64 位机器上就拷贝了 8字节的指针、8字节的长度、8字节的容量，总计 24 字节，但是带来了新的问题，还记得我们之前提到的所有权规则吧？其中有一条就是：<strong>一个值只允许有一个所有者</strong>，而现在这个值（堆上的真实字符串数据）有了两个所有者：s1 和 s2。</p>
<p>好吧，就假定一个值可以拥有两个所有者，会发生什么呢？</p>
<p>当变量离开作用域后，Rust 会自动调用 drop 函数并清理变量的堆内存。不过由于两个 String 变量指向了同一位置。这就有了一个问题：当 s1 和 s2 离开作用域，它们都会尝试释放相同的内存。这是一个叫做 <strong>二次释放\（double free\）</strong> 的错误，也是之前提到过的内存安全性 BUG 之一。两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。</p>
<p>因此，Rust 这样解决问题：<strong>当 s1 被赋予 s2 后，Rust 认为 s1 不再有效，因此也无需在 s1 离开作用域后 drop 任何东西，这就是把所有权从 s1 转移给了 s2，s1 在被赋予 s2 后就马上失效了。</strong></p>
<p>再来看看，在所有权转移后再来使用旧的所有者，会发生什么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let s1 = String::from(&quot;hello&quot;);</span><br><span class="line">let s2 = s1;</span><br><span class="line"></span><br><span class="line">println!(&quot;&#123;&#125;, world!&quot;, s1);</span><br></pre></td></tr></table></figure>
<p>由于 Rust 禁止你使用无效的引用，你会看到以下的错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">error[E0382]: borrow of moved value: `s1`</span><br><span class="line"> --&gt; src/main.rs:5:28</span><br><span class="line">  |</span><br><span class="line">2 |     let s1 = String::from(&quot;hello&quot;);</span><br><span class="line">  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait</span><br><span class="line">3 |     let s2 = s1;</span><br><span class="line">  |              -- value moved here</span><br><span class="line">4 |</span><br><span class="line">5 |     println!(&quot;&#123;&#125;, world!&quot;, s1);</span><br><span class="line">  |                            ^^ value borrowed here after move</span><br><span class="line">  |</span><br><span class="line">  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)</span><br><span class="line">help: consider cloning the value if the performance cost is acceptable</span><br><span class="line">  |</span><br><span class="line">3 |     let s2 = s1.clone();</span><br><span class="line">  |                ++++++++</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0382`.</span><br></pre></td></tr></table></figure>
<p>现在再回头看看之前的规则，相信大家已经有了更深刻的理解：</p>
<table>
    <tr>
        <td bgcolor=#F0F8FF>
        1.Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
        2.一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
        3.当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)
        </td>
    </tr>
</table>
如果你在其他语言中听说过术语 **浅拷贝\(shallow copy\)** 和 **深拷贝\(deep copy\)**，那么拷贝指针、长度和容量而不拷贝数据听起来就像浅拷贝，但是又因为 Rust 同时使第一个变量 s1 无效了，因此这个操作被称为 **移动**(move)，而不是浅拷贝。上面的例子可以解读为 s1 被移动到了 s2 中。那么具体发生了什么，用一张图简单说明：

<p><img src="/../images/moveOp.png"></p>
<p>这样就解决了我们之前的问题，s1 不再指向任何数据，只有 s2 是有效的，当 s2 离开作用域，它就会释放内存。 相信此刻，你应该明白了，为什么 Rust 称呼 let a &#x3D; b 为变量绑定了吧？</p>
<p>再来看一段代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x: &amp;str = &quot;hello, world&quot;;</span><br><span class="line">    let y = x;</span><br><span class="line">    println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码，大家觉得会否报错？如果参考之前的 String 所有权转移的例子，那这段代码也应该报错才是，但是实际上呢？</p>
<p>这段代码和之前的 String 有一个本质上的区别：在 String 的例子中 s1 持有了通过String::from(“hello”) 创建的值的所有权，而这个例子中，x 只是引用了存储在二进制中的字符串 “hello, world”，并没有持有所有权。</p>
<p>因此 let y &#x3D; x 中，仅仅是对该引用进行了拷贝，此时 y 和 x 都引用了同一个字符串。如果还不理解也没关系，当学习了下一章节 “引用与借用” 后，大家自然而言就会理解。</p>
<h2 id="4-2克隆-深拷贝"><a href="#4-2克隆-深拷贝" class="headerlink" title="4.2克隆(深拷贝)"></a>4.2克隆(深拷贝)</h2><p>首先，Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何自动的复制都不是深拷贝，可以被认为对运行时性能影响较小。</p>
<p>如果我们确实需要深度复制 String 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 clone 的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let s1 = String::from(&quot;hello&quot;);</span><br><span class="line">let s2 = s1.clone();</span><br><span class="line"></span><br><span class="line">println!(&quot;s1 = &#123;&#125;, s2 = &#123;&#125;&quot;, s1, s2);</span><br></pre></td></tr></table></figure>
<p>这段代码能够正常运行，说明 s2 确实完整的复制了 s1 的数据。</p>
<p>如果代码性能无关紧要，例如初始化程序时或者在某段时间只会执行寥寥数次时，你可以使用 clone 来简化编程。但是对于执行较为频繁的代码(热点路径)，使用 clone 会极大的降低程序性能，需要小心使用！</p>
<h2 id="4-3拷贝-浅拷贝"><a href="#4-3拷贝-浅拷贝" class="headerlink" title="4.3拷贝(浅拷贝)"></a>4.3拷贝(浅拷贝)</h2><p>浅拷贝只发生在栈上，因此性能很高，在日常编程中，浅拷贝无处不在。</p>
<p>再回到之前看过的例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let x = 5;</span><br><span class="line">let y = x;</span><br><span class="line"></span><br><span class="line">println!(&quot;x = &#123;&#125;, y = &#123;&#125;&quot;, x, y);</span><br></pre></td></tr></table></figure>
<p>但这段代码似乎与我们刚刚学到的内容相矛盾：没有调用 clone，不过依然实现了类似深拷贝的效果 —— 没有报所有权的错误。</p>
<p>原因是像整型这样的基本类型在编译时是已知大小的，会被存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 y 后使 x 无效（x、y 都仍然有效）。换句话说，这里没有深浅拷贝的区别，因此这里调用 clone 并不会与通常的浅拷贝有什么不同，我们可以不用管它（可以理解成在栈上做了深拷贝）。</p>
<p>Rust 有一个叫做 Copy 的特征，可以用在类似整型这样在栈中存储的类型。如果一个类型拥有 Copy 特征，一个旧的变量在被赋值给其他变量后仍然可用，也就是赋值的过程即是拷贝的过程。</p>
<p>那么什么类型是可 Copy 的呢？可以查看给定类型的文档来确认，这里可以给出一个通用的规则： <strong>任何基本类型的组合可以 Copy ，不需要分配内存或某种形式资源的类型是可以 Copy 的。如下是一些 Copy 的类型</strong>：</p>
<ul>
<li>所有整数类型，比如 u32</li>
<li>布尔类型，bool，它的值是 true 和 false</li>
<li>所有浮点数类型，比如 f64</li>
<li>字符类型，char</li>
<li>元组，当且仅当其包含的类型也都是 Copy 的时候。比如，(i32, i32) 是 Copy 的，但 (i32, String) 就不是</li>
<li>不可变引用 &amp;T ，例如转移所有权中的最后一个例子，但是注意: <strong>可变引用 &amp;mut T 是不可以 Copy的</strong></li>
</ul>
<h1 id="5-函数传值与返回"><a href="#5-函数传值与返回" class="headerlink" title="5.函数传值与返回"></a>5.函数传值与返回</h1><p>将值传递给函数，一样会发生 移动 或者 复制，就跟 let 语句一样，下面的代码展示了所有权、作用域的规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;hello&quot;);  // s 进入作用域</span><br><span class="line"></span><br><span class="line">    takes_ownership(s);             // s 的值移动到函数里 ...</span><br><span class="line">                                    // ... 所以到这里不再有效</span><br><span class="line"></span><br><span class="line">    let x = 5;                      // x 进入作用域</span><br><span class="line"></span><br><span class="line">    makes_copy(x);                  // x 应该移动函数里，</span><br><span class="line">                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x</span><br><span class="line"></span><br><span class="line">&#125; // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，</span><br><span class="line">  // 所以不会有特殊操作</span><br><span class="line"></span><br><span class="line">fn takes_ownership(some_string: String) &#123; // some_string 进入作用域</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, some_string);</span><br><span class="line">&#125; // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放</span><br><span class="line"></span><br><span class="line">fn makes_copy(some_integer: i32) &#123; // some_integer 进入作用域</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, some_integer);</span><br><span class="line">&#125; // 这里，some_integer 移出作用域。不会有特殊操作</span><br></pre></td></tr></table></figure>
<p>你可以尝试在 takes_ownership 之后，再使用 s，看看如何报错？例如添加一行 println!(“在move进函数后继续使用s: {}”,s);。</p>
<p>同样的，函数返回值也有所有权，例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = gives_ownership();         // gives_ownership 将返回值</span><br><span class="line">                                        // 移给 s1</span><br><span class="line"></span><br><span class="line">    let s2 = String::from(&quot;hello&quot;);     // s2 进入作用域</span><br><span class="line"></span><br><span class="line">    let s3 = takes_and_gives_back(s2);  // s2 被移动到</span><br><span class="line">                                        // takes_and_gives_back 中,</span><br><span class="line">                                        // 它也将返回值移给 s3</span><br><span class="line">&#125; // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span><br><span class="line">  // 所以什么也不会发生。s1 移出作用域并被丢弃</span><br><span class="line"></span><br><span class="line">fn gives_ownership() -&gt; String &#123;             // gives_ownership 将返回值移动给</span><br><span class="line">                                             // 调用它的函数</span><br><span class="line"></span><br><span class="line">    let some_string = String::from(&quot;hello&quot;); // some_string 进入作用域.</span><br><span class="line"></span><br><span class="line">    some_string                              // 返回 some_string 并移出给调用的函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// takes_and_gives_back 将传入字符串并返回该值</span><br><span class="line">fn takes_and_gives_back(a_string: String) -&gt; String &#123; // a_string 进入作用域</span><br><span class="line"></span><br><span class="line">    a_string  // 返回 a_string 并移出给调用的函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有权很强大，避免了内存的不安全性，但是也带来了一个新麻烦： 总是把一个值传来传去来使用它。 传入一个函数，很可能还要从该函数传出去，结果就是语言表达变得非常啰嗦，幸运的是，Rust 提供了新功能解决这个问题。</p>
<h1 id="6-练习题"><a href="#6-练习题" class="headerlink" title="6.练习题"></a>6.练习题</h1><h2 id="6-1"><a href="#6-1" class="headerlink" title="6.1"></a>6.1</h2> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // 使用尽可能多的方法来通过编译</span><br><span class="line">    let x = String::from(&quot;hello, world&quot;);</span><br><span class="line">    let y = x;</span><br><span class="line">    println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // 使用尽可能多的方法来通过编译</span><br><span class="line">    let x = String::from(&quot;hello, world&quot;);</span><br><span class="line">    let y = x.clone();</span><br><span class="line">    println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = &quot;hello, world&quot;;</span><br><span class="line">    let y = x;</span><br><span class="line">    println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = &amp;String::from(&quot;hello, world&quot;);</span><br><span class="line">    let y = x;</span><br><span class="line">    println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = String::from(&quot;hello, world&quot;);</span><br><span class="line">    let y = x.as_str();</span><br><span class="line">    println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-2"><a href="#6-2" class="headerlink" title="6.2"></a>6.2</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Don&#x27;t modify code in main!</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(&quot;hello, world&quot;);</span><br><span class="line">    let s2 = take_ownership(s1);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Only modify the code below!</span><br><span class="line">fn take_ownership(s: String) -&gt; String &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s);</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 不要修改 main 中的代码</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(&quot;hello, world&quot;);</span><br><span class="line">    let s2 = take_ownership(s1);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 只能修改下面的代码!</span><br><span class="line">fn take_ownership(s: String) -&gt;String&#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s);</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-3"><a href="#6-3" class="headerlink" title="6.3"></a>6.3</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = give_ownership();</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 只能修改下面的代码!</span><br><span class="line">fn give_ownership() -&gt; String &#123;</span><br><span class="line">    let s = String::from(&quot;hello, world&quot;);</span><br><span class="line">    // convert String to Vec</span><br><span class="line">    // 将 String 转换成 Vec 类型</span><br><span class="line">    let _s = s.into_bytes();</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = give_ownership();</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 只能修改下面的代码!</span><br><span class="line">fn give_ownership() -&gt; String &#123;</span><br><span class="line">    let s = String::from(&quot;hello, world&quot;);</span><br><span class="line">    // convert String to Vec</span><br><span class="line">    // 将 String 转换成 Vec 类型</span><br><span class="line">    let _s = s.as_bytes();</span><br><span class="line">    </span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-4"><a href="#6-4" class="headerlink" title="6.4"></a>6.4</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 修复错误，不要删除任何代码行</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;hello, world&quot;);</span><br><span class="line"></span><br><span class="line">    print_str(s);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn print_str(s: String)  &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 修复错误，不要删除任何代码行</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;hello, world&quot;);</span><br><span class="line"></span><br><span class="line">    print_str(s.clone());</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn print_str(s: String)  &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-5"><a href="#6-5" class="headerlink" title="6.5"></a>6.5</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 不要使用 clone，使用 copy 的方式替代</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let x = (1, 2, (), &quot;hello&quot;.to_string());</span><br><span class="line">    let y = x.clone();</span><br><span class="line">    println!(&quot;&#123;:?&#125;, &#123;:?&#125;&quot;, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = (1, 2, (), &quot;hello&quot;);</span><br><span class="line">    let y = x;</span><br><span class="line">    println!(&quot;&#123;:?&#125;, &#123;:?&#125;&quot;, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-6"><a href="#6-6" class="headerlink" title="6.6"></a>6.6</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;hello, &quot;);</span><br><span class="line">    </span><br><span class="line">    // 只修改下面这行代码 !</span><br><span class="line">    let s1 = s;</span><br><span class="line"></span><br><span class="line">    s1.push_str(&quot;world&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;hello, &quot;);</span><br><span class="line">    </span><br><span class="line">    // 只修改下面这行代码 !</span><br><span class="line">    let mut s1 = s;</span><br><span class="line"></span><br><span class="line">    s1.push_str(&quot;world&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-7"><a href="#6-7" class="headerlink" title="6.7"></a>6.7</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = Box::new(5);</span><br><span class="line">    </span><br><span class="line">    let ...      // 完成该行代码，不要修改其它行！</span><br><span class="line">    </span><br><span class="line">    *y = 4;</span><br><span class="line">    </span><br><span class="line">    assert_eq!(*x, 5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = Box::new(5);</span><br><span class="line">    </span><br><span class="line">    let mut y = Box::new(4);      // 完成该行代码，不要修改其它行！</span><br><span class="line">    </span><br><span class="line">    *y = 4;</span><br><span class="line">    </span><br><span class="line">    assert_eq!(*x, 5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-8"><a href="#6-8" class="headerlink" title="6.8"></a>6.8</h1><p>部分 move<br>当解构一个变量时，可以同时使用 move 和引用模式绑定的方式。当这么做时，部分 move 就会发生：变量中一部分的所有权被转移给其它变量，而另一部分我们获取了它的引用。</p>
<p>在这种情况下，原变量将无法再被使用，但是它没有转移所有权的那一部分依然可以使用，也就是之前被引用的那部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    #[derive(Debug)]</span><br><span class="line">    struct Person &#123;</span><br><span class="line">        name: String,</span><br><span class="line">        age: Box&lt;u8&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let person = Person &#123;</span><br><span class="line">        name: String::from(&quot;Alice&quot;),</span><br><span class="line">        age: Box::new(20),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 通过这种解构式模式匹配，person.name 的所有权被转移给新的变量 `name`</span><br><span class="line">    // 但是，这里 `age` 变量却是对 person.age 的引用, 这里 ref 的使用相当于: let age = &amp;person.age </span><br><span class="line">    let Person &#123; name, ref age &#125; = person;</span><br><span class="line"></span><br><span class="line">    println!(&quot;The person&#x27;s age is &#123;&#125;&quot;, age);</span><br><span class="line"></span><br><span class="line">    println!(&quot;The person&#x27;s name is &#123;&#125;&quot;, name);</span><br><span class="line"></span><br><span class="line">    // Error! 原因是 person 的一部分已经被转移了所有权，因此我们无法再使用它</span><br><span class="line">    //println!(&quot;The person struct is &#123;:?&#125;&quot;, person);</span><br><span class="line"></span><br><span class="line">    // 虽然 `person` 作为一个整体无法再被使用，但是 `person.age` 依然可以使用</span><br><span class="line">    println!(&quot;The person&#x27;s age from person struct is &#123;&#125;&quot;, person.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">   let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;));</span><br><span class="line"></span><br><span class="line">   let _s = t.0;</span><br><span class="line"></span><br><span class="line">   // 仅修改下面这行代码，且不要使用 `_s`</span><br><span class="line">   println!(&quot;&#123;:?&#125;&quot;, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;));</span><br><span class="line"> </span><br><span class="line">    let _s = t.0;</span><br><span class="line"> </span><br><span class="line">    // 仅修改下面这行代码，且不要使用 `_s`</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, t.1);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-9"><a href="#6-9" class="headerlink" title="6.9"></a>6.9</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">   let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;));</span><br><span class="line"></span><br><span class="line">   // 填空，不要修改其它代码</span><br><span class="line">   let (__, __) = __;</span><br><span class="line"></span><br><span class="line">   println!(&quot;&#123;:?&#125;, &#123;:?&#125;, &#123;:?&#125;&quot;, s1, s2, t); // -&gt; &quot;hello&quot;, &quot;world&quot;, (&quot;hello&quot;, &quot;world&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;));</span><br><span class="line"> </span><br><span class="line">    // 填空，不要修改其它代码</span><br><span class="line">    let (s1, s2) = t.clone();</span><br><span class="line"> </span><br><span class="line">    println!(&quot;&#123;:?&#125;, &#123;:?&#125;, &#123;:?&#125;&quot;, s1, s2, t); // -&gt; &quot;hello&quot;, &quot;world&quot;, (&quot;hello&quot;, &quot;world&quot;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/21/learnRust5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Byte的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/21/learnRust5/" itemprop="url">Rust入门-基础 第五节 基础类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-08-21T00:13:30+08:00">
                2024-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1.基本类型"></a>1.基本类型</h1><p>Rust 每个值都有其确切的数据类型，总的来说可以分为两类：基本类型和复合类型。 基本类型意味着它们往往是一个最小化原子类型，无法解构为其它类型(一般意义上来说)</p>
<ul>
<li>数值类型: 有符号整数 (i8, i16, i32, i64, isize)、 无符号整数 (u8, u16, u32, u64, usize) 、浮点数 (f32, f64)、以及有理数、复数</li>
<li>isize usize 与机器字(32位或64位)一样大的有符号整数和无符号整数</li>
<li>复合类型（Compound types）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）</li>
<li>字符串：字符串字面量和字符串切片 &amp;str</li>
<li>布尔类型： true和false</li>
<li>字符类型: 表示单个 Unicode 字符，存储为 4 个字节</li>
<li>单元类型: 即 () ，其唯一的值也是 ()</li>
<li>struct S 具名字段型结构体 S {x:120,y:209.0}</li>
<li>struct T(i32,char); 元组型结构体</li>
<li>struct E 单元型结构体,无字段</li>
<li>enum 枚举 或代数或数据类型</li>
<li>Box<Attend> 指向堆中值的拥有型指针</li>
<li>&amp;i32 &amp;mut i32 共享引用和可变引用:非拥有型指针 其生命周期不能超出引用目标</li>
<li>string UTF8 字符串 动态分配大小</li>
<li>&amp;str 对str的引用：指向UTF-8文本的非拥有型指针</li>
<li>[f64;4] [u8;256] 数组 固定长度 其元素类型都相同</li>
<li>Vec<f64> 向量 可变长度 其元素类型都相同</li>
<li>&amp;[u8] *mut [u8] 对切片(数组或向量某一部分)的引用 包含指针和长度</li>
<li>Option&lt;&amp;str&gt; 可选值:或者为 None(无值) 或者为 Some(v) (有值 其值位v)   Some(“Dr.”) None</li>
<li>Result 可能失败的操作结果:或者为成功值Ok(v) 或者为错误值Err(e)        Ok(4096) Err(Error::last_os_error())</li>
<li>&amp;dyn Any &amp;mut dyn Read 特型对象 是对任何实现了一组给定方法的值的引用  </li>
<li>fn(&amp;str) -&gt; bool 函数指针 str::is_empty</li>
<li>闭包类型没有显示书写形式 闭包 |a,b| a*a + b * b</li>
<li>x..&#x3D;y 序列 1..&#x3D;4</li>
</ul>
<h1 id="1-1整数类型"><a href="#1-1整数类型" class="headerlink" title="1.1整数类型"></a>1.1整数类型</h1><p>整数是没有小数部分的数字。之前使用过的 i32 类型，表示有符号的 32 位整数（ i 是英文单词 integer 的首字母，与之相反的是 u，代表无符号 unsigned 类型）。下表显示了 Rust 中的内置的整数类型</p>
<table>
<thead>
<tr>
<th align="center">长度</th>
<th align="center">有符号类型</th>
<th align="center">无符号类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">8 位</td>
<td align="center">i8</td>
<td align="center">u8</td>
</tr>
<tr>
<td align="center">16 位</td>
<td align="center">i16</td>
<td align="center">u16</td>
</tr>
<tr>
<td align="center">32 位</td>
<td align="center">i32</td>
<td align="center">u32</td>
</tr>
<tr>
<td align="center">64 位</td>
<td align="center">i64</td>
<td align="center">u64</td>
</tr>
<tr>
<td align="center">128 位</td>
<td align="center">i128</td>
<td align="center">u128</td>
</tr>
<tr>
<td align="center">视架构而定</td>
<td align="center">isize</td>
<td align="center">usize</td>
</tr>
</tbody></table>
<p>类型定义的形式统一为：有无符号 + 类型大小(位数)。无符号数表示数字只能取正数和0，而有符号则表示数字可以取正数、负数还有0。就像在纸上写数字一样：当要强调符号时，数字前面可以带上正号或负号；然而，当很明显确定数字为正数时，就不需要加上正号了。有符号数字以补码形式存储。</p>
<p>每个有符号类型规定的数字范围是 -(2n - 1) ~ 2n - 1 - 1，其中 n 是该定义形式的位长度。因此 i8 可存储数字范围是 -(27) ~ 27 - 1，即 -128 ~ 127。无符号类型可以存储的数字范围是 0 ~ 2n - 1，所以 u8 能够存储的数字为 0 ~ 28 - 1，即 0 ~ 255。</p>
<p>此外，isize 和 usize 类型取决于程序运行的计算机 CPU 类型： 若 CPU 是 32 位的，则这两个类型是 32 位的，同理，若 CPU 是 64 位，那么它们则是 64 位。</p>
<p>整形字面量可以用下表的形式书写：</p>
<table>
<thead>
<tr>
<th align="center">数字字面量</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">十进制</td>
<td align="center">98_222</td>
</tr>
<tr>
<td align="center">十六进制</td>
<td align="center">0xff</td>
</tr>
<tr>
<td align="center">八进制</td>
<td align="center">0o77</td>
</tr>
<tr>
<td align="center">二进制</td>
<td align="center">0b1111_0000</td>
</tr>
<tr>
<td align="center">字节 (仅限于 u8)</td>
<td align="center">b’A’</td>
</tr>
</tbody></table>
<h2 id="1-2-整形实例"><a href="#1-2-整形实例" class="headerlink" title="1.2 整形实例"></a>1.2 整形实例</h2><p> Rust 整型默认使用 i32，例如 let i &#x3D; 1，那 i 就是 i32 类型，因此你可以首选它，同时该类型也往往是性能最好的。isize 和 usize 的主要应用场景是用作集合的索引。</p>
<h1 id="1-3-整型溢出"><a href="#1-3-整型溢出" class="headerlink" title="1.3 整型溢出"></a>1.3 整型溢出</h1><p>假设有一个 u8 ，它可以存放从 0 到 255 的值。那么当你将其修改为范围之外的值，比如 256，则会发生整型溢出。关于这一行为 Rust 有一些有趣的规则：当在 debug 模式编译时，Rust 会检查整型溢出，若存在这些问题，则使程序在编译时 panic(崩溃,Rust 使用这个术语来表明程序因错误而退出)。</p>
<p>在当使用 –release 参数进行 release 模式构建时，Rust 不检测溢出。相反，当检测到整型溢出时，Rust 会按照补码循环溢出（two’s complement wrapping）的规则处理。简而言之，大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在 u8 的情况下，256 变成 0，257 变成 1，依此类推。程序不会 panic，但是该变量的值可能不是你期望的值。依赖这种默认行为的代码都应该被认为是错误的代码。</p>
<p>要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：</p>
<ul>
<li>使用 wrapping_* 方法在所有模式下都按照补码循环溢出规则处理，例如 wrapping_add</li>
<li>如果使用 checked_* 方法时发生溢出，则返回 None 值</li>
<li>使用 overflowing_* 方法返回该值和一个指示是否存在溢出的布尔值</li>
<li>使用 saturating_* 方法，可以限定计算后的结果不超过目标类型的最大值或低于最小值，例如:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assert_eq!(100u8.saturating_add(1), 101);</span><br><span class="line">assert_eq!(u8::MAX.saturating_add(127), u8::MAX);</span><br></pre></td></tr></table></figure>
<p>下面是一个演示wrapping_*方法的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a : u8 = 255;</span><br><span class="line">    let b = a.wrapping_add(20);</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, b);  // 19</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-浮点类型"><a href="#2-浮点类型" class="headerlink" title="2.浮点类型"></a>2.浮点类型</h1><p>浮点类型数字 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型： f32 和 f64，分别为 32 位和 64 位大小。默认浮点类型是 f64，在现代的 CPU 中它的速度与 f32 几乎相同，但精度更高。</p>
<p>下面是一个演示浮点数的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = 2.0; // f64</span><br><span class="line"></span><br><span class="line">    let y: f32 = 3.0; // f32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>浮点数根据 IEEE-754 标准实现。f32 类型是单精度浮点型，f64 为双精度。</p>
<h1 id="2-1浮点数陷阱"><a href="#2-1浮点数陷阱" class="headerlink" title="2.1浮点数陷阱"></a>2.1浮点数陷阱</h1><p>浮点数由于底层格式的特殊性，导致了如果在使用浮点数时不够谨慎，就可能造成危险，有两个原因：</p>
<p>浮点数往往是你想要数字的近似表达 浮点数类型是基于二进制实现的，但是我们想要计算的数字往往是基于十进制，例如 0.1 在二进制上并不存在精确的表达形式，但是在十进制上就存在。这种不匹配性导致一定的歧义性，更多的，虽然浮点数能代表真实的数值，但是由于底层格式问题，它往往受限于定长的浮点数精度，如果你想要表达完全精准的真实数字，只有使用无限精度的浮点数才行</p>
<p>浮点数在某些特性上是反直觉的 例如大家都会觉得浮点数可以进行比较，对吧？是的，它们确实可以使用 &gt;，&gt;&#x3D; 等进行比较，但是在某些场景下，这种直觉上的比较特性反而会害了你。因为 f32 ， f64 上的比较运算实现的是 std::cmp::PartialEq 特征(类似其他语言的接口)，但是并没有实现 std::cmp::Eq 特征，但是后者在其它数值类型上都有定义，说了这么多，可能大家还是云里雾里，用一个例子来举例：</p>
<p>Rust 的 HashMap 数据结构，是一个 KV 类型的 Hash Map 实现，它对于 K 没有特定类型的限制，但是要求能用作 K 的类型必须实现了 std::cmp::Eq 特征，因此这意味着你无法使用浮点数作为 HashMap 的 Key，来存储键值对，但是作为对比，Rust 的整数类型、字符串类型、布尔类型都实现了该特征，因此可以作为 HashMap 的 Key。</p>
<p>为了避免上面说的两个陷阱，你需要遵守以下准则：</p>
<p>避免在浮点数上测试相等性<br>当结果在数学上可能存在未定义时，需要格外的小心<br>来看个小例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  // 断言0.1 + 0.2与0.3相等</span><br><span class="line">  assert!(0.1 + 0.2 == 0.3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能以为，这段代码没啥问题吧，实际上它会 panic(程序崩溃，抛出异常)，因为二进制精度问题，导致了 0.1 + 0.2 并不严格等于 0.3，它们可能在小数点 N 位后存在误差。</p>
<p>那如果非要进行比较呢？可以考虑用这种方式 (0.1_f64 + 0.2 - 0.3).abs() &lt; 0.00001 ，具体小于多少，取决于你对精度的需求。</p>
<p>讲到这里，相信大家基本已经明白了，为什么操作浮点数时要格外的小心，但是还不够，下面再来一段代码，直接震撼你的灵魂：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let abc: (f32, f32, f32) = (0.1, 0.2, 0.3);</span><br><span class="line">    let xyz: (f64, f64, f64) = (0.1, 0.2, 0.3);</span><br><span class="line"></span><br><span class="line">    println!(&quot;abc (f32)&quot;);</span><br><span class="line">    println!(&quot;   0.1 + 0.2: &#123;:x&#125;&quot;, (abc.0 + abc.1).to_bits());</span><br><span class="line">    println!(&quot;         0.3: &#123;:x&#125;&quot;, (abc.2).to_bits());</span><br><span class="line">    println!();</span><br><span class="line"></span><br><span class="line">    println!(&quot;xyz (f64)&quot;);</span><br><span class="line">    println!(&quot;   0.1 + 0.2: &#123;:x&#125;&quot;, (xyz.0 + xyz.1).to_bits());</span><br><span class="line">    println!(&quot;         0.3: &#123;:x&#125;&quot;, (xyz.2).to_bits());</span><br><span class="line">    println!();</span><br><span class="line"></span><br><span class="line">    assert!(abc.0 + abc.1 == abc.2);</span><br><span class="line">    assert!(xyz.0 + xyz.1 == xyz.2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行该程序，输出如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">abc (f32)</span><br><span class="line">   0.1 + 0.2: 3e99999a</span><br><span class="line">         0.3: 3e99999a</span><br><span class="line"></span><br><span class="line">xyz (f64)</span><br><span class="line">   0.1 + 0.2: 3fd3333333333334</span><br><span class="line">         0.3: 3fd3333333333333</span><br><span class="line"></span><br><span class="line">thread &#x27;main&#x27; panicked at &#x27;assertion failed: xyz.0 + xyz.1 == xyz.2&#x27;,</span><br><span class="line">➥ch2-add-floats.rs.rs:14:5</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display</span><br><span class="line">➥a backtrace</span><br></pre></td></tr></table></figure>
<p>仔细看，对 f32 类型做加法时，0.1 + 0.2 的结果是 3e99999a，0.3 也是 3e99999a，因此 f32 下的 0.1 + 0.2 &#x3D;&#x3D; 0.3 通过测试，但是到了 f64 类型时，结果就不一样了，因为 f64 精度高很多，因此在小数点非常后面发生了一点微小的变化，0.1 + 0.2 以 4 结尾，但是 0.3 以3结尾，这个细微区别导致 f64 下的测试失败了，并且抛出了异常。</p>
<h1 id="3-NaN"><a href="#3-NaN" class="headerlink" title="3.NaN"></a>3.NaN</h1><p>对于数学上未定义的结果，例如对负数取平方根 -42.1.sqrt() ，会产生一个特殊的结果：Rust 的浮点数类型使用 NaN (not a number)来处理这些情况。</p>
<p>所有跟 NaN 交互的操作，都会返回一个 NaN，而且 NaN 不能用来比较，下面的代码会崩溃：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  let x = (-42.0_f32).sqrt();</span><br><span class="line">  assert_eq!(x, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出于防御性编程的考虑，可以使用 is_nan() 等方法，可以用来判断一个数值是否是 NaN ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = (-42.0_f32).sqrt();</span><br><span class="line">    if x.is_nan() &#123;</span><br><span class="line">        println!(&quot;未定义的数学行为&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-数字运算"><a href="#4-数字运算" class="headerlink" title="4.数字运算"></a>4.数字运算</h1><p>Rust 支持所有数字类型的基本数学运算：加法、减法、乘法、除法和取模运算。下面代码各使用一条 let 语句来说明相应运算的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // 加法</span><br><span class="line">    let sum = 5 + 10;</span><br><span class="line"></span><br><span class="line">    // 减法</span><br><span class="line">    let difference = 95.5 - 4.3;</span><br><span class="line"></span><br><span class="line">    // 乘法</span><br><span class="line">    let product = 4 * 30;</span><br><span class="line"></span><br><span class="line">    // 除法</span><br><span class="line">    let quotient = 56.7 / 32.2;</span><br><span class="line"></span><br><span class="line">    // 求余</span><br><span class="line">    let remainder = 43 % 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些语句中的每个表达式都使用了数学运算符，并且计算结果为一个值，然后绑定到一个变量上。</p>
<p>再来看一个综合性的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  // 编译器会进行自动推导，给予twenty i32的类型</span><br><span class="line">  let twenty = 20;</span><br><span class="line">  // 类型标注</span><br><span class="line">  let twenty_one: i32 = 21;</span><br><span class="line">  // 通过类型后缀的方式进行类型标注：22是i32类型</span><br><span class="line">  let twenty_two = 22i32;</span><br><span class="line"></span><br><span class="line">  // 只有同样类型，才能运算</span><br><span class="line">  let addition = twenty + twenty_one + twenty_two;</span><br><span class="line">  println!(&quot;&#123;&#125; + &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;, twenty, twenty_one, twenty_two, addition);</span><br><span class="line"></span><br><span class="line">  // 对于较长的数字，可以用_进行分割，提升可读性</span><br><span class="line">  let one_million: i64 = 1_000_000;</span><br><span class="line">  println!(&quot;&#123;&#125;&quot;, one_million.pow(2));</span><br><span class="line"></span><br><span class="line">  // 定义一个f32数组，其中42.0会自动被推导为f32类型</span><br><span class="line">  let forty_twos = [</span><br><span class="line">    42.0,</span><br><span class="line">    42f32,</span><br><span class="line">    42.0_f32,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  // 打印数组中第一个值，并控制小数位为2位</span><br><span class="line">  println!(&quot;&#123;:.2&#125;&quot;, forty_twos[0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-位运算"><a href="#5-位运算" class="headerlink" title="5.位运算"></a>5.位运算</h1><p>Rust的位运算基本上和其他语言一样</p>
<p>运算符	说明<br>&amp; 位与	相同位置均为1时则为1，否则为0<br>| 位或	相同位置只要有1时则为1，否则为0<br>^ 异或	相同位置不相同则为1，相同则为0<br>! 位非	把位中的0和1相互取反，即0置为1，1置为0<br>&lt;&lt; 左移	所有位向左移动指定位数，右位补0<br>&gt;&gt; 右移	所有位向右移动指定位数，带符号移动（正数补0，负数补1）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // 二进制为00000010</span><br><span class="line">    let a:i32 = 2;</span><br><span class="line">    // 二进制为00000011</span><br><span class="line">    let b:i32 = 3;</span><br><span class="line"></span><br><span class="line">    println!(&quot;(a &amp; b) value is &#123;&#125;&quot;, a &amp; b);</span><br><span class="line"></span><br><span class="line">    println!(&quot;(a | b) value is &#123;&#125;&quot;, a | b);</span><br><span class="line"></span><br><span class="line">    println!(&quot;(a ^ b) value is &#123;&#125;&quot;, a ^ b);</span><br><span class="line"></span><br><span class="line">    println!(&quot;(!b) value is &#123;&#125; &quot;, !b);</span><br><span class="line"></span><br><span class="line">    println!(&quot;(a &lt;&lt; b) value is &#123;&#125;&quot;, a &lt;&lt; b);</span><br><span class="line"></span><br><span class="line">    println!(&quot;(a &gt;&gt; b) value is &#123;&#125;&quot;, a &gt;&gt; b);</span><br><span class="line"></span><br><span class="line">    let mut a = a;</span><br><span class="line">    // 注意这些计算符除了!之外都可以加上=进行赋值 (因为!=要用来判断不等于)</span><br><span class="line">    a &lt;&lt;= b;</span><br><span class="line">    println!(&quot;(a &lt;&lt; b) value is &#123;&#125;&quot;, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-序列-Range"><a href="#6-序列-Range" class="headerlink" title="6.序列(Range)"></a>6.序列(Range)</h1><p>Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 1..5，生成从 1 到 4 的连续数字，不包含 5 ；1..&#x3D;5，生成从 1 到 5 的连续数字，包含 5，它的用途很简单，常常用于循环中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in 1..=5 &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终程序输出:</p>
<p>1<br>2<br>3<br>4<br>5<br>序列只允许用于数字或字符类型，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。如下是一个使用字符类型序列的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in &#x27;a&#x27;..=&#x27;z&#x27; &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-使用-As-完成类型转换"><a href="#7-使用-As-完成类型转换" class="headerlink" title="7.使用 As 完成类型转换"></a>7.使用 As 完成类型转换</h1><p>Rust 中可以使用 As 来完成一个类型到另一个类型的转换，其最常用于将原始类型转换为其他原始类型，但是它也可以完成诸如将指针转换为地址、地址转换为指针以及将指针转换为其他指针等功能。你可以在这里了解更多相关的知识。</p>
<h1 id="8-有理数和复数"><a href="#8-有理数和复数" class="headerlink" title="8.有理数和复数"></a>8.有理数和复数</h1><p>Rust 的标准库相比其它语言，准入门槛较高，因此有理数和复数并未包含在标准库中：</p>
<p>有理数和复数<br>任意大小的整数和任意精度的浮点数<br>固定精度的十进制小数，常用于货币相关的场景<br>好在社区已经开发出高质量的 Rust 数值库：num。</p>
<p>按照以下步骤来引入 num 库：</p>
<ol>
<li>创建新工程 cargo new complex-num &amp;&amp; cd complex-num</li>
<li>在 Cargo.toml 中的 [dependencies] 下添加一行 num &#x3D; “0.4.0”</li>
<li>将 src&#x2F;main.rs 文件中的 main 函数替换为下面的代码</li>
<li>运行 cargo run<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use num::complex::Complex;</span><br><span class="line"></span><br><span class="line"> fn main() &#123;</span><br><span class="line">   let a = Complex &#123; re: 2.1, im: -1.2 &#125;;</span><br><span class="line">   let b = Complex::new(11.1, 22.2);</span><br><span class="line">   let result = a + b;</span><br><span class="line"></span><br><span class="line">   println!(&quot;&#123;&#125; + &#123;&#125;i&quot;, result.re, result.im)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="9-布尔-bool"><a href="#9-布尔-bool" class="headerlink" title="9.布尔(bool)"></a>9.布尔(bool)</h1><p>Rust 中的布尔类型有两个可能的值：true 和 false，布尔值占用内存的大小为 1 个字节：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let t = true;</span><br><span class="line"></span><br><span class="line">    let f: bool = false; // 使用类型标注,显式指定f的类型</span><br><span class="line"></span><br><span class="line">    if f &#123;</span><br><span class="line">        println!(&quot;这是段毫无意义的代码&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用布尔类型的场景主要在于流程控制，例如上述代码的中的 if 就是其中之一。</p>
<h1 id="10-字符类型-char"><a href="#10-字符类型-char" class="headerlink" title="10.字符类型(char)"></a>10.字符类型(char)</h1><p>字符，对于没有其它编程经验的新手来说可能不太好理解（没有编程经验敢来学 Rust 的绝对是好汉），但是你可以把它理解为英文中的字母，中文中的汉字。</p>
<p>下面的代码展示了几个颇具异域风情的字符：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let c = &#x27;z&#x27;;</span><br><span class="line">    let z = &#x27;ℤ&#x27;;</span><br><span class="line">    let g = &#x27;国&#x27;;</span><br><span class="line">    let heart_eyed_cat = &#x27;😻&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果大家是从有年代感的编程语言过来，可能会大喊一声：这 XX 叫字符？是的，在 Rust 语言中这些都是字符，Rust 的字符不仅仅是 ASCII，所有的 Unicode 值都可以作为 Rust 字符，包括单个的中文、日文、韩文、emoji 表情符号等等，都是合法的字符类型。Unicode 值的范围从 U+0000 ~ U+D7FF 和 U+E000 ~ U+10FFFF。不过“字符”并不是 Unicode 中的一个概念，所以人在直觉上对“字符”的理解和 Rust 的字符概念并不一致。</p>
<p>由于 Unicode 都是 4 个字节编码，因此字符类型也是占用 4 个字节：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = &#x27;中&#x27;;</span><br><span class="line">    println!(&quot;字符&#x27;中&#x27;占用了&#123;&#125;字节的内存大小&quot;,std::mem::size_of_val(&amp;x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出如下:<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling ...</span><br></pre></td></tr></table></figure><br>字符’中’占用了4字节的内存大小</p>
<table>
    <td bgcolor=#F0F8FF>[package]
        注意，我们还没开始讲字符串，但是这里提前说一下，和一些语言不同，Rust 的字符只能用 '' 来表示， "" 是留给字符串的。
    </td>
</table>


<h1 id="9-总结"><a href="#9-总结" class="headerlink" title="9.总结"></a>9.总结</h1><p>之前提到了过 Rust 的数值类型和运算跟其他语言较为相似，但是实际上，除了语法上的不同之外，还是存在一些差异点：</p>
<p>Rust 拥有相当多的数值类型. 因此你需要熟悉这些类型所占用的字节数，这样就知道该类型允许的大小范围以及你选择的类型是否能表达负数<br>类型转换必须是显式的. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数<br>Rust 的数值上可以使用方法. 例如你可以用以下方法来将 13.14 取整：13.14_f32.round()，在这里我们使用了类型后缀，因为编译器需要知道 13.14 的具体类型<br>数值类型的讲解已经基本结束，接下来，来看看字符和布尔类型。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/14/color/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Byte的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/14/color/" itemprop="url">Color</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-08-14T00:58:23+08:00">
                2024-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>#E0FFFF: 亮浅蓝色 (Light Cyan)</li>
<li>#D3E8FF: 淡蓝色 (Pale Blue)</li>
<li>#F0F8FF: 爱丽丝蓝 (Alice Blue)</li>
<li>#CCFFFF: 淡青色 (Pale Cyan)</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/14/learnRust4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Byte的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/14/learnRust4/" itemprop="url">Rust入门-基础 第四节 Rust - 流程控制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-08-14T00:37:21+08:00">
                2024-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="if-表达式"><a href="#if-表达式" class="headerlink" title="if 表达式"></a>if 表达式</h1><p>不像 Ruby 或 JavaScript这样的语言，Rust并不会尝试自动地将非布尔值转换为布尔值。必须总是显式地使用布尔值作为 if 条件<br>但凡你能找到一门编程语言没有 if else，那么一定更要反馈给鲁迅，反正不是我说的:) 总之，只要你拥有其它语言的编程经验，就一定会有以下认知：if else 表达式根据条件执行不同的代码分支：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if condition == true &#123;</span><br><span class="line">    // A...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // B...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码读作：若 condition 的值为 true，则执行 A 代码，否则执行 B 代码。</p>
<p>先看下面代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let condition = true;</span><br><span class="line">    let number = if condition &#123;</span><br><span class="line">        5</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        6</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;The value of number is: &#123;&#125;&quot;, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码有以下几点要注意：</p>
<ul>
<li>if 语句块是表达式，这里我们使用 if 表达式的返回值来给 number 进行赋值：number 的值是 5</li>
<li>用 if 来赋值时，要保证每个分支返回的类型一样(事实上，这种说法不完全准确，见这里)，此处返回的 5 和 6 就是同一个类型，如果返回类型不一致就会报错</li>
<li>代码块的值是其最后一个表达式的值，这里继续不谈**语句(statement)和表达式(expression)**的概念，只要知道这里不应该有分号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let number:i32 = 3;</span><br><span class="line">    if number &lt; 5 &#123;</span><br><span class="line">        println!(&quot;condition was true&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        println!(&quot;condition was false&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="以上代码有以下几点要注意："><a href="#以上代码有以下几点要注意：" class="headerlink" title="以上代码有以下几点要注意："></a>以上代码有以下几点要注意：</h2><ul>
<li>if 语句块是表达式，这里我们使用 if 表达式的返回值来给 number 进行赋值：number 的值是 5</li>
<li>用 if 来赋值时，要保证每个分支返回的类型一样(事实上，这种说法不完全准确，见这里)，此处返回的 5 和 6 就是同一个类型，如果返回类型不一致就会报错</li>
</ul>
<h1 id="使用-else-if-来处理多重条件"><a href="#使用-else-if-来处理多重条件" class="headerlink" title="使用 else if 来处理多重条件"></a>使用 else if 来处理多重条件</h1><p>可以将 else if 与 if、else 组合在一起实现更复杂的条件分支判断：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let n = 6;</span><br><span class="line"></span><br><span class="line">    if n % 4 == 0 &#123;</span><br><span class="line">        println!(&quot;number is divisible by 4&quot;);</span><br><span class="line">    &#125; else if n % 3 == 0 &#123;</span><br><span class="line">        println!(&quot;number is divisible by 3&quot;);</span><br><span class="line">    &#125; else if n % 2 == 0 &#123;</span><br><span class="line">        println!(&quot;number is divisible by 2&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        println!(&quot;number is not divisible by 4, 3, or 2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行时，会按照自上至下的顺序执行每一个分支判断，一旦成功，则跳出 if 语句块，最终本程序会匹配执行 else if n % 3 &#x3D;&#x3D; 0 的分支，输出 “number is divisible by 3”。<br>有一点要注意，就算有多个分支能匹配，也只有第一个匹配的分支会被执行！<br>如果代码中有大量的 else if 会让代码变得极其丑陋，不过不用担心，下一章的 match 专门用以解决多分支模式匹配的问题。</p>
<h1 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h1><p>循环无处不在，上到数钱，下到数年，你能想象的很多场景都存在循环，因此它也是流程控制中最重要的组成部分之一。</p>
<p>在 Rust 语言中有三种循环方式：for、while 和 loop，其中 for 循环是 Rust 循环王冠上的明珠。</p>
<h1 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h1><h2 id="for-循环是-Rust-的大杀器："><a href="#for-循环是-Rust-的大杀器：" class="headerlink" title="for 循环是 Rust 的大杀器："></a>for 循环是 Rust 的大杀器：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    for i in 1..=5 &#123;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码循环输出一个从 1 到 5 的序列，简单粗暴，核心就在于 for 和 in 的联动，语义表达如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for 元素 in 集合 &#123;</span><br><span class="line">  // 使用元素干一些你懂我不懂的事情</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个语法跟 JavaScript 还蛮像，应该挺好理解。</p>
<p>注意，使用 for 时我们往往使用集合的引用形式，除非你不想在后面的代码中继续使用该集合（比如我们这里使用了 container 的引用）。如果不使用引用的话，所有权会被转移（move）到 for 语句块中，后面就无法再使用这个集合了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for item in &amp;container &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
    <tr>
        <td bgcolor=#F0F8FF>对于实现了 copy 特征的数组(例如 [i32; 10] )而言， for item in arr 并不会把 arr 的所有权转移，而是直接对其进行了拷贝，因此循环之后仍然可以使用 arr 。
        </td>
    </tr>
</table>
如果想在循环中，修改该元素，可以使用 mut 关键字：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for item in &amp;mut collection &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">使用方法</th>
<th align="center">等价使用方式</th>
<th align="right">所有权</th>
</tr>
</thead>
<tbody><tr>
<td align="left">for item in collection</td>
<td align="center">for item in IntoIterator::into_iter(collection)</td>
<td align="right">转移所有权</td>
</tr>
<tr>
<td align="left">for item in &amp;collection</td>
<td align="center">for item in collection.iter()</td>
<td align="right">不可变借用</td>
</tr>
<tr>
<td align="left">for item in &amp;mut collection</td>
<td align="center">for item in collection.iter_mut()</td>
<td align="right">可变借用</td>
</tr>
</tbody></table>
<style>
  table {
    font-size: 12px;
  }
</style>
<p>如果想在循环中获取元素的索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a = [4, 3, 2, 1];</span><br><span class="line">    // `.iter()` 方法把 `a` 数组变成一个迭代器</span><br><span class="line">    for (i, v) in a.iter().enumerate() &#123;</span><br><span class="line">        println!(&quot;第&#123;&#125;个元素是&#123;&#125;&quot;, i + 1, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有同学可能会想到，如果我们想用 for 循环控制某个过程执行 10 次，但是又不想单独声明一个变量来控制这个流程，该怎么写？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//有点类似lua的写法</span><br><span class="line">for _ in 0..10 &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以用 _ 来替代 i 用于 for 循环中，在 Rust 中 _ 的含义是忽略该值或者类型的意思，如果不使用 _，那么编译器会给你一个 变量未使用的 的警告。</p>
<h2 id="两种循环方式优劣对比"><a href="#两种循环方式优劣对比" class="headerlink" title="两种循环方式优劣对比"></a>两种循环方式优劣对比</h2><p>以下代码，使用了两种循环方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 第一种</span><br><span class="line">let collection = [1, 2, 3, 4, 5];</span><br><span class="line">for i in 0..collection.len() &#123;</span><br><span class="line">  let item = collection[i];</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第二种</span><br><span class="line">for item in collection &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一种方式是循环索引，然后通过索引下标去访问集合，第二种方式是直接循环集合中的元素，优劣如下：</p>
<ul>
<li>性能：第一种使用方式中 collection[index] 的索引访问，会因为边界检查(Bounds Checking)导致运行时的性能损耗 —— Rust 会检查并确认 index 是否落在集合内，但是第二种直接迭代的方式就不会触发这种检查，因为编译器会在编译时就完成分析并证明这种访问是合法的</li>
<li>安全：第一种方式里对 collection 的索引访问是非连续的，存在一定可能性在两次访问之间，collection 发生了变化，导致脏数据产生。而第二种直接迭代的方式是连续访问，因此不存在这种风险( 由于所有权限制，在访问过程中，数据并不会发生变化)。<br>由于 for 循环无需任何条件限制，也不需要通过索引来访问，因此是最安全也是最常用的，通过与下面的 while 的对比，我们能看到为什么 for 会更加安全。</li>
</ul>
<h1 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h1><p>使用 continue 可以跳过当前当次的循环，开始下次的循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i in 1..4 &#123;</span><br><span class="line">    if i == 2 &#123;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码对 1 到 3 的序列进行迭代，且跳过值为 2 时的循环，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h1 id="break"><a href="#break" class="headerlink" title="break"></a>break</h1><p>使用 break 可以直接跳出当前整个循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i in 1..4 &#123;</span><br><span class="line">    if i == 2 &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码对 1 到 3 的序列进行迭代，在遇到值为 2 时的跳出整个循环，后面的循环不再执行，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<h1 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h1><p>如果你需要一个条件来循环，当该条件为 true 时，继续循环，条件为 false，跳出循环，那么 while 就非常适用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut n = 0;</span><br><span class="line"></span><br><span class="line">    while n &lt;= 5  &#123;</span><br><span class="line">        println!(&quot;&#123;&#125;!&quot;, n);</span><br><span class="line"></span><br><span class="line">        n = n + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;我出来了！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该 while 循环，只有当 n 小于等于 5 时，才执行，否则就立刻跳出循环，因此在上述代码中，它会先从 0 开始，满足条件，进行循环，然后是 1，满足条件，进行循环，最终到 6 的时候，大于 5，不满足条件，跳出 while 循环，执行 我出来了 的打印，然后程序结束：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0!</span><br><span class="line">1!</span><br><span class="line">2!</span><br><span class="line">3!</span><br><span class="line">4!</span><br><span class="line">5!</span><br><span class="line">我出来了！</span><br></pre></td></tr></table></figure>
<p>当然，你也可以用其它方式组合实现，例如 loop（无条件循环，将在下面介绍） + if + break：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut n = 0;</span><br><span class="line"></span><br><span class="line">    loop &#123;</span><br><span class="line">        if n &gt; 5 &#123;</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;, n);</span><br><span class="line">        n+=1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;我出来了！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，在这种循环场景下，while 要简洁的多。</p>
<h1 id="while-vs-for"><a href="#while-vs-for" class="headerlink" title="while vs for"></a>while vs for</h1><p>我们也能用 while 来实现 for 的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a = [10, 20, 30, 40, 50];</span><br><span class="line">    let mut index = 0;</span><br><span class="line"></span><br><span class="line">    while index &lt; 5 &#123;</span><br><span class="line">        println!(&quot;the value is: &#123;&#125;&quot;, a[index]);</span><br><span class="line"></span><br><span class="line">        index = index + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，代码对数组中的元素进行计数。它从索引 0 开始，并接着循环直到遇到数组的最后一个索引（这时，index &lt; 5 不再为真）。运行这段代码会打印出数组中的每一个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">the value is: 10</span><br><span class="line">the value is: 20</span><br><span class="line">the value is: 30</span><br><span class="line">the value is: 40</span><br><span class="line">the value is: 50</span><br></pre></td></tr></table></figure>
<p>数组中的所有五个元素都如期被打印出来。尽管 index 在某一时刻会到达值 5，不过循环在其尝试从数组获取第六个值（会越界）之前就停止了。</p>
<p>但这个过程很容易出错；如果索引长度不正确会导致程序 panic。这也使程序更慢，因为编译器增加了运行时代码来对每次循环的每个元素进行条件检查。</p>
<p>for循环代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a = [10, 20, 30, 40, 50];</span><br><span class="line"></span><br><span class="line">    for element in a.iter() &#123;</span><br><span class="line">        println!(&quot;the value is: &#123;&#125;&quot;, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，for 并不会使用索引去访问数组，因此更安全也更简洁，同时避免 运行时的边界检查，性能更高。</p>
<h1 id="loop-循环"><a href="#loop-循环" class="headerlink" title="loop 循环"></a>loop 循环</h1><p>对于循环而言，loop 循环毋庸置疑，是适用面最高的，它可以适用于所有循环场景（虽然能用，但是在很多场景下， for 和 while 才是最优选择），因为 loop 就是一个简单的无限循环，你可以在内部实现逻辑通过 break 关键字来控制循环何时结束。</p>
<p>使用 loop 循环一定要打起精神，否则你会写出下面的跑满你一个 CPU 核心的疯子代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    loop &#123;</span><br><span class="line">        println!(&quot;again!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该循环会不停的在终端打印输出，直到你使用 Ctrl-C 结束程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">again!</span><br><span class="line">again!</span><br><span class="line">again!</span><br><span class="line">again!</span><br><span class="line">^Cagain!</span><br></pre></td></tr></table></figure>
<p>注意，不要轻易尝试上述代码，如果你电脑配置不行，可能会死机！！！</p>
<p>因此，当使用 loop 时，必不可少的伙伴是 break 关键字，它能让循环在满足某个条件时跳出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut counter = 0;</span><br><span class="line"></span><br><span class="line">    let result = loop &#123;</span><br><span class="line">        counter += 1;</span><br><span class="line"></span><br><span class="line">        if counter == 10 &#123;</span><br><span class="line">            break counter * 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;The result is &#123;&#125;&quot;, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码当 counter 递增到 10 时，就会通过 break 返回一个 counter * 2 的值，最后赋给 result 并打印出来。</p>
<p>这里有几点值得注意：</p>
<ul>
<li>break 可以单独使用，也可以带一个返回值，有些类似 return</li>
<li>loop 是一个表达式，因此可以返回一个值</li>
</ul>
<h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 填空</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let n = 5;</span><br><span class="line"></span><br><span class="line">    if n &lt; 0 &#123;</span><br><span class="line">        println!(&quot;&#123;&#125; is negative&quot;, n);</span><br><span class="line">    &#125; else if n &gt; 0 &#123;</span><br><span class="line">        println!(&quot;&#123;&#125; is positive&quot;, n);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        println!(&quot;&#123;&#125; is zero&quot;, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 修复错误</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let n = 5;</span><br><span class="line"></span><br><span class="line">    let big_n =  </span><br><span class="line">    if n &lt; 10 &amp;&amp; n &gt; -10 &#123;</span><br><span class="line">        println!(&quot; 数字太小，先增加 10 倍再说&quot;);</span><br><span class="line"></span><br><span class="line">         10 * n</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        println!(&quot;数字太大，我们得让它减半&quot;);</span><br><span class="line"></span><br><span class="line">        n / 2 </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125; -&gt; &#123;&#125;&quot;, n, big_n);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    for n in 1..=99 &#123; // 修改此行，让代码工作</span><br><span class="line">        if n == 100 &#123;</span><br><span class="line">            panic!(&quot;NEVER LET THIS RUN&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">//</span><br><span class="line">//fn main() &#123;</span><br><span class="line">    //for n in 1..99 &#123; // 修改此行，让代码工作</span><br><span class="line">        //if n == 100 &#123;</span><br><span class="line">            //panic!(&quot;NEVER LET THIS RUN&quot;)</span><br><span class="line">        //&#125;</span><br><span class="line">    //&#125;</span><br><span class="line">//&#125; </span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 修复错误，不要新增或删除代码行</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let names = [String::from(&quot;liming&quot;),String::from(&quot;hanmeimei&quot;)];</span><br><span class="line">    for name in &amp;names &#123;</span><br><span class="line">        // do something with name...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, names);</span><br><span class="line"></span><br><span class="line">    let numbers = [1, 2, 3];</span><br><span class="line">    // numbers中的元素实现了 Copy，因此无需转移所有权</span><br><span class="line">    for n in numbers &#123;</span><br><span class="line">        // do something with name...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, numbers);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a = [4,3,2,1];</span><br><span class="line"></span><br><span class="line">    // 通过索引和值的方式迭代数组 `a` </span><br><span class="line">    for (i,v) in a.iter().enumerate() &#123;</span><br><span class="line">        println!(&quot;第&#123;&#125;个元素是&#123;&#125;&quot;,i+1,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 填空，让最后一行的  println! 工作 !</span><br><span class="line">fn main() &#123;</span><br><span class="line">    // 一个计数值</span><br><span class="line">    let mut n = 1;</span><br><span class="line"></span><br><span class="line">    // 当条件为真时，不停的循环</span><br><span class="line">    while n &lt; 10 &#123;</span><br><span class="line">        if n % 15 == 0 &#123;</span><br><span class="line">            println!(&quot;fizzbuzz&quot;);</span><br><span class="line">        &#125; else if n % 3 == 0 &#123;</span><br><span class="line">            println!(&quot;fizz&quot;);</span><br><span class="line">        &#125; else if n % 5 == 0 &#123;</span><br><span class="line">            println!(&quot;buzz&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            println!(&quot;&#123;&#125;&quot;, n);</span><br><span class="line">        &#125;</span><br><span class="line">        n = n + 1;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;n 的值是 &#123;&#125;, 循环结束&quot;,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li><p>🌟 使用 break 可以跳出循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 填空，不要修改其它代码</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut n = 0;</span><br><span class="line">    for i in 0..=100 &#123;</span><br><span class="line">       if n == 66 &#123;</span><br><span class="line">           break;</span><br><span class="line">       &#125;</span><br><span class="line">       n += 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert_eq!(n, 66);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>🌟🌟 continue 会结束当次循环并立即开始下一次循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 填空，不要修改其它代码</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut n = 0;</span><br><span class="line">    for i in 0..=100 &#123;</span><br><span class="line">       if n != 66 &#123;</span><br><span class="line">           n+=1;</span><br><span class="line">           continue;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert_eq!(n, 66);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>🌟🌟 loop 一般都需要配合 break 或 continue 一起使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 填空，不要修改其它代码</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut count = 0u32;</span><br><span class="line"></span><br><span class="line">    println!(&quot;Let&#x27;s count until infinity!&quot;);</span><br><span class="line"></span><br><span class="line">    // 无限循环</span><br><span class="line">    loop &#123;</span><br><span class="line">        count += 1;</span><br><span class="line"></span><br><span class="line">        if count == 3 &#123;</span><br><span class="line">            println!(&quot;three&quot;);</span><br><span class="line"></span><br><span class="line">            // 跳过当此循环的剩余代码</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println!(&quot;&#123;&#125;&quot;, count);</span><br><span class="line"></span><br><span class="line">        if count == 5 &#123;</span><br><span class="line">            println!(&quot;OK, that&#x27;s enough&quot;);</span><br><span class="line"></span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert_eq!(count, 5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>🌟🌟 loop 是一个表达式，因此我们可以配合 break 来返回一个值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 填空</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut counter = 0;</span><br><span class="line"></span><br><span class="line">    let result = loop &#123;</span><br><span class="line">        counter += 1;</span><br><span class="line"></span><br><span class="line">        if counter == 10 &#123;</span><br><span class="line">            break counter + 10</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    assert_eq!(result, 20);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>🌟🌟🌟 当有多层循环时，你可以使用 continue 或 break 来控制外层的循环。要实现这一点，外部的循环必须拥有一个标签 ‘label, 然后在 break 或 continue 时指定该标签</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 填空</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut count = 0;</span><br><span class="line">    &#x27;outer: loop &#123;</span><br><span class="line">        &#x27;inner1: loop &#123;</span><br><span class="line">            if count &gt;= 20 &#123;</span><br><span class="line">                // 这只会跳出 inner1 循环</span><br><span class="line">                break &#x27;inner1; // 这里使用 `break` 也是一样的</span><br><span class="line">            &#125;</span><br><span class="line">            count += 2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count += 5;</span><br><span class="line"></span><br><span class="line">        &#x27;inner2: loop &#123;</span><br><span class="line">            if count &gt;= 30 &#123;</span><br><span class="line">                break &#x27;outer;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            continue &#x27;outer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert!(count == 30)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/13/learnRust3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Byte的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/13/learnRust3/" itemprop="url">Rust入门-基础 第三节 Rust - 函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-08-13T23:49:28+08:00">
                2024-08-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="函数组成"><a href="#函数组成" class="headerlink" title="函数组成"></a>函数组成</h1><ul>
<li>声朗函数的关键字 fn</li>
<li>函数名 add()</li>
<li>参数i和j和参数类型 i32</li>
<li>返同值类型 i32</li>
<li>函数体i+j</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn add(i:i32,j:i32)-&gt; i32 &#123;</span><br><span class="line">    i + j</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let a = 1;</span><br><span class="line">    let b = 2;</span><br><span class="line">    let c = add(2, b);</span><br><span class="line">    printin!(&quot;&#123;&#125;&quot;,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数如此简单，但是又是如此的五脏俱全，声明函数的关键字 fn ,函数名 add()，参数 i 和 j，参数类型和返回值类型都是 i32，总之一切那么的普通，但是又那么的自信，直到你看到了下面这张图：<br><img src="/../images/function.png"><br>当你看懂了这张图，其实就等于差不多完成了函数章节的学习，但是这么短的章节显然对不起读者老爷们的厚爱，所以我们来展开下。</p>
<h1 id="函数要点"><a href="#函数要点" class="headerlink" title="函数要点"></a>函数要点</h1><ul>
<li>开头是字符，后面是数字，下划线，字母</li>
<li>开头是下划线，后面是数字，下划线，字母，不能仅有下划线</li>
<li>通数名和变量名使用蛇形命名法(snakecase)，例如fn add_two() &#x3D;&gt; {}</li>
</ul>
<h1 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h1><p>Rust 是强类型语言，因此需要你为每一个的数参数都标识出它的具体类型<br>注意:是每一个⚠️</p>
<h1 id="函数返回"><a href="#函数返回" class="headerlink" title="函数返回"></a>函数返回</h1><p>函数的返日值裁是函数体最后一条表达式的返回值，也可以使用return 提前返回想要完全理解这句话需要掌握**语句(statement)和表达式(expression)””的概念初学者裁记住函数的两种形态就行了</p>
<ul>
<li>return + 分号</li>
<li>没有return + 没有分号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn add(i:i32, j:i32)-&gt; i32 &#123;</span><br><span class="line">    i + j</span><br><span class="line">&#125;</span><br><span class="line">fn add(i:i32, j:i32)-&gt; i32 &#123;</span><br><span class="line">    return i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Rust-中的特殊返回类型"><a href="#Rust-中的特殊返回类型" class="headerlink" title="Rust 中的特殊返回类型"></a>Rust 中的特殊返回类型</h1><h2 id="无返回值"><a href="#无返回值" class="headerlink" title="无返回值()"></a>无返回值()</h2><p>如果一个的数没有返回值，那么就返回()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn print(i: i32)&#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, i);</span><br><span class="line">&#125;</span><br><span class="line">fn print(i:i32) -&gt;() &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 Rust 新手来说，有些返回类型很难理解，而且如果你想通过百度或者谷歌去搜索，都不好查询，因为这些符号太常见了，根本难以精确搜索到。</p>
<p>例如单元类型 ()，是一个零长度的元组。它没啥作用，但是可以用来表达一个函数没有返回值：</p>
<p>函数没有返回值，那么返回一个 ()<br>通过 ; 结尾的语句返回一个 ()<br>例如下面的 report 函数会隐式返回一个 ()：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use std::fmt::Debug;</span><br><span class="line"></span><br><span class="line">fn report&lt;T: Debug&gt;(item: T) &#123;</span><br><span class="line">  println!(&quot;&#123;:?&#125;&quot;, item);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与上面的函数返回值相同，但是下面的函数显式的返回了 ()：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn clear(text: &amp;mut String) -&gt; () &#123;</span><br><span class="line">  *text = String::from(&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际编程中，你会经常在错误提示中看到该 () 的身影出没，假如你的函数需要返回一个 u32 值，但是如果你不幸的以 表达式; 的语句形式作为函数的最后一行代码，就会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn add(x:u32,y:u32) -&gt; u32 &#123;</span><br><span class="line">    x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error[E0308]: mismatched types // 类型不匹配</span><br><span class="line"> --&gt; src/main.rs:6:24</span><br><span class="line">  |</span><br><span class="line">6 | fn add(x:u32,y:u32) -&gt; u32 &#123;</span><br><span class="line">  |    ---                 ^^^ expected `u32`, found `()` // 期望返回u32,却返回()</span><br><span class="line">  |    |</span><br><span class="line">  |    implicitly returns `()` as its body has no tail or `return` expression</span><br><span class="line">7 |     x + y;</span><br><span class="line">  |          - help: consider removing this semicolon</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>还记得我们在语句与表达式中讲过的吗？只有表达式能返回值，而 ; 结尾的是语句，在 Rust 中，一定要严格区分表达式和语句的区别，这个在其它语言中往往是被忽视的点。</p>
<h1 id="永不返回的发散函数"><a href="#永不返回的发散函数" class="headerlink" title="永不返回的发散函数 !"></a>永不返回的发散函数 !</h1><p>当用 ! 作函数返回类型的时候，表示该函数永不返回( diverge function )，特别的，这种语法往往用做会导致程序崩溃的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn dead_end() -&gt; ! &#123;</span><br><span class="line">  panic!(&quot;你已经到了穷途末路，崩溃吧！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的函数创建了一个无限循环，该循环永不跳出，因此函数也永不返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn forever() -&gt; ! &#123;</span><br><span class="line">  loop &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // 不要修改下面两行代码!</span><br><span class="line">    let (x, y) = (1, 2);</span><br><span class="line">    let s = sum(x, y);</span><br><span class="line">    print(s);</span><br><span class="line">    assert_eq!(s, 3);</span><br><span class="line">&#125;</span><br><span class="line">fn print(i: i32)&#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, i);</span><br><span class="line">&#125;</span><br><span class="line">fn sum(x:i32, y: i32) -&gt; i32 &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    print();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> // 使用另一个类型来替代 i32</span><br><span class="line"> fn print() -&gt; () &#123;</span><br><span class="line">    println!(&quot;hello,world&quot;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    never_return();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn never_return() -&gt; ! &#123;</span><br><span class="line">    // 实现这个函数，不要修改函数签名!</span><br><span class="line">    // panic!(&quot;error&quot;);</span><br><span class="line">    loop &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    get_option(1);</span><br><span class="line">    println!(&quot;Success!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn get_option(tp: u8) -&gt; Option&lt;i32&gt; &#123;</span><br><span class="line">    match tp &#123;</span><br><span class="line">        1 =&gt; &#123;</span><br><span class="line">            // TODO</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            // TODO</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    // 这里与其返回一个 None，不如使用发散函数替代</span><br><span class="line">    never_return_fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用三种方法实现以下发散函数</span><br><span class="line">fn never_return_fn() -&gt; ! &#123;</span><br><span class="line">    // panic!(&quot;error&quot;);</span><br><span class="line">    //todo!()</span><br><span class="line">    loop &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // 填空</span><br><span class="line">    let b: bool = false;</span><br><span class="line"></span><br><span class="line">    let _v: i32 = match b &#123;</span><br><span class="line">        true =&gt; 1,</span><br><span class="line">        // 发散函数也可以用于 `match` 表达式，用于替代任何类型的值</span><br><span class="line">        false =&gt; &#123;</span><br><span class="line">            println!(&quot;Success!&quot;);</span><br><span class="line">            panic!(&quot;we have no value for `false`, but we can panic&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;Exercise Failed if printing out this line!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/07/learnRust2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Byte的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/07/learnRust2/" itemprop="url">Rust入门-基础 第二节 Rust变量和可变性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-08-07T22:54:03+08:00">
                2024-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="可变变量和不可变变量-Mutable和Immutable"><a href="#可变变量和不可变变量-Mutable和Immutable" class="headerlink" title="可变变量和不可变变量(Mutable和Immutable)"></a>可变变量和不可变变量(Mutable和Immutable)</h1><p>Rust的变量默认是不可改变的(immutable),如果我们想改变变量的值,就需要声明可变变量(mutable)</p>
<h2 id="声明不可变变量"><a href="#声明不可变变量" class="headerlink" title="声明不可变变量"></a>声明不可变变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let x=5;</span><br><span class="line">println!(&#x27;The value of x is:&#123;&#125;&quot;,x);</span><br></pre></td></tr></table></figure>
<h2 id="声明可变变量"><a href="#声明可变变量" class="headerlink" title="声明可变变量"></a>声明可变变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let mut x=5;</span><br><span class="line">println!(&quot;The value of xis:&#123;&#125;&quot;,x);</span><br><span class="line">X = 6;</span><br><span class="line">printin!(&quot;The value of x is: &#123;&#125;&quot;,x);</span><br></pre></td></tr></table></figure>
<h1 id="常量（Constants）"><a href="#常量（Constants）" class="headerlink" title="常量（Constants）"></a>常量（Constants）</h1><p>使用const关键字来定义一个常量。定义常量时需要明确的指定常量的数据类型。</p>
<h2 id="关于常量，需要注意以下几点"><a href="#关于常量，需要注意以下几点" class="headerlink" title="关于常量，需要注意以下几点"></a>关于常量，需要注意以下几点</h2><ul>
<li>必须显示指定数据类型</li>
<li>常量名一般使用大写字母，否则编译器会报 Warning。</li>
<li>必须使用常量表达式进行赋值，即必须是编译期能计算出的值。</li>
<li>常量不支持重定义(遮蔽)，这和变量是不同的。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 常量声明</span><br><span class="line">const NUM: i32 = 5;</span><br><span class="line">println!(&quot;constants values is &#123;&#125;&quot;, NUM);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="不可变变量和常量的区别？"><a href="#不可变变量和常量的区别？" class="headerlink" title="不可变变量和常量的区别？"></a>不可变变量和常量的区别？</h2><ul>
<li>关键字：常量使用const声明，不可变变量使用let</li>
<li>赋值时机：常量在编译期就确定了值，无法再运行时改变。不可变变量直到运行期才能确定下来</li>
<li>能否改变：常量不可以修改，不可变变量可以通过shadowing来修改</li>
<li>声明：常量必须声明类型，不可变变量不需要</li>
<li>命名：常量必须使用大写字母，不可变变量不需要</li>
</ul>
<h1 id="静态变量（Static）"><a href="#静态变量（Static）" class="headerlink" title="静态变量（Static）"></a>静态变量（Static）</h1><p>使用static关键字声明，并在编译时分配内存，且在程序运行期间一直存在；</p>
<p>静态变量可以在整个程序中共享，且可以再多个线程间共享；</p>
<p>静态变量的值在运行期间不会改变，因此它们通常用于存储程序的全局状态。</p>
<h2 id="静态变量与常量的相似之处"><a href="#静态变量与常量的相似之处" class="headerlink" title="静态变量与常量的相似之处"></a>静态变量与常量的相似之处</h2><ul>
<li>定义方式类型，一个使用 static，一个使用const;</li>
<li>名称都要求使用大写，否则会报 Warning;</li>
<li>都必须明确指定类型;</li>
<li>两者都要求必须使用常量表达式进行赋值，即必须是编译期能计算出的值;</li>
<li>两者都不支持重定义(遮蔽)，这和变量是不同的。</li>
</ul>
<h2 id="静态变量和常量区别"><a href="#静态变量和常量区别" class="headerlink" title="静态变量和常量区别"></a>静态变量和常量区别</h2><ul>
<li>常量在编译时被内联，但静态变量不会。在整个程序中静态变量只有一个实例，也就是说所有引用都指向同一个地址 。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 常量的内联</span><br><span class="line">const A: i32 = 1;</span><br><span class="line">static B: i32 = 2;</span><br><span class="line">fn main () &#123;</span><br><span class="line">	println!&#123;&quot;const value = &#123;&#125;&quot;, A&#125;;</span><br><span class="line">	//在编译期间，常量的访问会被替换成常量的值（内联）</span><br><span class="line">	//所以上面的代码会被编译成：println!&#123;&quot;const value = &#123;&#125;&quot;, 1&#125;;</span><br><span class="line">  </span><br><span class="line">  // 但是静态变量的访问指向的是这个变量所对应的内存地址</span><br><span class="line">  println!&#123;&quot;static value = &#123;&#125;&quot;, B&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>常量不可变，而静态变量和普通变量一样，默认不可变但可以通过 mut 关键字定义为可变。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个可变的静态变量</span><br><span class="line">static mut NUM: i32 = 30;</span><br><span class="line"></span><br><span class="line">// 静态变量是全局的，多线程共享的。对它的值的修改不是线程安全的，需要把这段代码放入unsafe代码块中执行。否则编译期间会报错。这里只是举例</span><br><span class="line">unsafe &#123;</span><br><span class="line">	NUM += 1;</span><br><span class="line">	println!(&quot;the static value is &#123;&#125;&quot;, NUM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="作用域和遮蔽-variableshadowing"><a href="#作用域和遮蔽-variableshadowing" class="headerlink" title="作用域和遮蔽(variableshadowing)"></a>作用域和遮蔽(variableshadowing)</h1><p>变量绑定有一个作用域(scope)，它被限定只在一个代码块(block)中生存(live)。代码块是一个被{}包围的语句集合。另外也允许变量遮蔽(variable shadowing)。</p>
<p>通过对不可变变量的重新声明的方式，可以完成对不可变变量值的遮蔽</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个不可变变量</span><br><span class="line">let short_live_binding: i32 = 2;</span><br><span class="line">println!(&quot;before shadowing -- short variable : &#123;&#125;&quot;, short_live_binding);</span><br><span class="line"></span><br><span class="line">// 遮蔽, 对同一个不可变变量的变量名重新声明赋值</span><br><span class="line">let short_live_binding: i32 = 5;</span><br><span class="line">println!(&quot;after shadowing -- short variable : &#123;&#125;&quot;, short_live_binding);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before shadowing -- short variable : 2</span><br><span class="line">after shadowing -- short variable : 5</span><br></pre></td></tr></table></figure>
<p>遮蔽一个比当前作用域声明周期更长的变量的时候，遮蔽的作用范围只在当前的作用域内，超出作用域的变量的值还是遮蔽之前的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let global_value: i32 = 1;</span><br><span class="line">// 声明一个代码块</span><br><span class="line">&#123;</span><br><span class="line">	let global_value: i32 = 2;</span><br><span class="line">	// 完成遮蔽</span><br><span class="line">	println!(&quot;in block value is &#123;&#125;&quot;,global_value);</span><br><span class="line">&#125;</span><br><span class="line">// 在遮蔽的作用域外</span><br><span class="line">println!(&quot;global value is &#123;&#125;&quot;, global_value)</span><br></pre></td></tr></table></figure>
<h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in block value is 2</span><br><span class="line">global value is 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/31/learnRust1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Byte的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/07/31/learnRust1/" itemprop="url">Rust入门-基础 第一节 环境搭建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-07-31T23:12:06+08:00">
                2024-07-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-Rust介绍"><a href="#1-Rust介绍" class="headerlink" title="1.Rust介绍"></a>1.Rust介绍</h1><p>Rust是由Mozilla主导开发的通用、编译型编程语言。设计准则为”安全、并发、实用”，支持函数式、并发式、过程式以及面向对象的编程风格。–维基百科</p>
<h2 id="1-1-内存安全"><a href="#1-1-内存安全" class="headerlink" title="1.1 内存安全"></a>1.1 内存安全</h2><p>为了提供内存安全，它的设计不允许空指针和悬空指针。指针只能透过固定的初始化形态来建构，而所有这些形态都要求它们的输入已经分析过了。Rust有一个检查指针生命期间和指针冻结的系统，可以用来预防在C++中许多的类型错误，甚至是用了智能指针功能之后会发生的类型错误。</p>
<h2 id="1-2-基本类型"><a href="#1-2-基本类型" class="headerlink" title="1.2 基本类型"></a>1.2 基本类型</h2><p>当一门语言不谈类型时，你得小心，这大概率是动态语言(别拍我，我承认是废话)。但是把类型大张旗鼓的用多个章节去讲的，Rust 是其中之一。</p>
<p>Rust 每个值都有其确切的数据类型，总的来说可以分为两类：基本类型和复合类型。 基本类型意味着它们往往是一个最小化原子类型，无法解构为其它类型(一般意义上来说)，由以下组成：</p>
<ul>
<li>数值类型: 有符号整数 (i8, i16, i32, i64, isize)、 无符号整数 (u8, u16, u32, u64, usize) 、浮点数 (f32, f64)、以及有理数、复数</li>
<li>字符串：字符串字面量和字符串切片 &amp;str</li>
<li>布尔类型： true和false</li>
<li>字符类型: 表示单个 Unicode 字符，存储为 4 个字节</li>
<li>单元类型: 即 () ，其唯一的值也是 ()</li>
</ul>
<h2 id="1-3-静态类型"><a href="#1-3-静态类型" class="headerlink" title="1.3 静态类型"></a>1.3 静态类型</h2><p>与 Python、JavaScript 等动态语言不同，Rust 是一门静态类型语言，也就是编译器必须在编译期知道我们所有变量的类型，但这不意味着你需要为每个变量指定类型，因为 Rust 编译器很聪明，它可以根据变量的值和上下文中的使用方式来自动推导出变量的类型，同时编译器也不够聪明，在某些情况下，它无法推导出变量类型，需要手动去给予一个类型标注。</p>
<h2 id="1-4-并发编程"><a href="#1-4-并发编程" class="headerlink" title="1.4 并发编程"></a>1.4 并发编程</h2><p>Rust提供了强大的并发编程支持，使得开发者能够编写高效的多线程程序。通过其所有权系统和并发原语，Rust能够确保并发安全，并避免数据竞争和其他并发问题。</p>
<h1 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2.环境搭建"></a>2.环境搭建</h1><p>通过 rustup 下载 Rust，这是一个管理 Rust 版本和相关工具的命令行工具。下载时需要联网</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --proto &#x27;=https&#x27; --tlsv1.2 https://sh.rustup.rs -sSf | sh</span><br></pre></td></tr></table></figure>
<p>这个命令将下载一个脚本并开始安装 rustup 工具，此工具将安装 Rust 的最新稳定版本。可能会提示你输入管理员密码。</p>
<p>如果安装成功，将出现下面这行：</p>
<p>Rust is installed now. Great!<br>OK，这样就已经完成 Rust 安装啦。</p>
<h2 id="在-Windows-上安装-rustup"><a href="#在-Windows-上安装-rustup" class="headerlink" title="在 Windows 上安装 rustup"></a>在 Windows 上安装 rustup</h2><p>Windows 上安装 Rust 需要有 C++ 环境，以下为安装的两种方式：</p>
<h3 id="1-x86-64-pc-windows-msvc（官方推荐）"><a href="#1-x86-64-pc-windows-msvc（官方推荐）" class="headerlink" title="1. x86_64-pc-windows-msvc（官方推荐）"></a>1. x86_64-pc-windows-msvc（官方推荐）</h3><p>先安装 Microsoft C++ Build Tools，勾选安装 C++ 环境即可。安装时可自行修改缓存路径与安装路径，避免占用过多 C 盘空间。安装完成后，Rust 所需的 msvc 命令行程序需要手动添加到环境变量中，否则安装 Rust 时 rustup-init 会提示未安装 Microsoft C++ Build Tools，其位于：%Visual Studio 安装位置%\VC\Tools\MSVC%version%\bin\Hostx64\x64（请自行替换其中的 %Visual Studio 安装位置%、%version% 字段）下。</p>
<p>如果你不想这么做，可以选择安装 Microsoft C++ Build Tools 新增的“定制”终端 Developer Command Prompt for %Visual Studio version% 或 Developer PowerShell for %Visual Studio version%，在其中运行 rustup-init.exe。</p>
<p>准备好 C++ 环境后开始安装 Rust：<br>在 RUSTUP-INIT 下载系统相对应的 Rust 安装程序，一路默认即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Hehongyuan&gt; rustup-init.exe</span><br><span class="line">......</span><br><span class="line">Current installation options:</span><br><span class="line"></span><br><span class="line">default host triple: x86_64-pc-windows-msvc</span><br><span class="line">    default toolchain: stable (default)</span><br><span class="line">            profile: default</span><br><span class="line">modify PATH variable: yes</span><br><span class="line"></span><br><span class="line">1) Proceed with installation (default)</span><br><span class="line">2) Customize installation</span><br><span class="line">3) Cancel installation</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-x86-64-pc-windows-gnu"><a href="#2-x86-64-pc-windows-gnu" class="headerlink" title="2. x86_64-pc-windows-gnu"></a>2. x86_64-pc-windows-gnu</h3><p>相比于 MSVC 版本来说，GNU 版本具有更轻量，更靠近 Linux 的优势。</p>
<p>首先，根据 MSYS2 官网 配置 MSYS。</p>
<p>若您觉得下载太慢，可以试试由 Caviar-X 提供的 代理。</p>
<p>在安装 mingw-toolchain 后，请将 %MSYS 安装路径%\mingw64\bin 添加到系统变量 PATH 中。</p>
<p>配置好后，在 MSYS 中输入下面的命令来安装 rustup。</p>
<p>在 RUSTUP-INIT 下载系统相对应的 Rust 安装程序，一路默认即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    Current installation options:</span><br><span class="line"></span><br><span class="line">default host triple: x86_64-pc-windows-msvc</span><br><span class="line">    default toolchain: stable (default)</span><br><span class="line">            profile: default</span><br><span class="line">modify PATH variable: yes</span><br><span class="line"></span><br><span class="line">1) Proceed with installation (default)</span><br><span class="line">2) Customize installation</span><br><span class="line">3) Cancel installation</span><br><span class="line">&gt;2</span><br><span class="line"></span><br><span class="line">I&#x27;m going to ask you the value of each of these installation options.</span><br><span class="line">You may simply press the Enter key to leave unchanged.</span><br><span class="line"></span><br><span class="line">Default host triple? [x86_64-pc-windows-msvc]</span><br><span class="line">x86_64-pc-windows-gnu</span><br><span class="line"></span><br><span class="line">Default toolchain? (stable/beta/nightly/none) [stable]</span><br><span class="line">stable</span><br><span class="line"></span><br><span class="line">Profile (which tools and data to install)? (minimal/default/complete) [default]</span><br><span class="line">complete</span><br><span class="line"></span><br><span class="line">Modify PATH variable? (Y/n)</span><br><span class="line">Y</span><br><span class="line"></span><br><span class="line">Current installation options:</span><br><span class="line"></span><br><span class="line">default host triple: x86_64-pc-windows-gnu</span><br><span class="line">    default toolchain: stable</span><br><span class="line">            profile: complete</span><br><span class="line">modify PATH variable: yes</span><br><span class="line"></span><br><span class="line">1) Proceed with installation (default)</span><br><span class="line">2) Customize installation</span><br><span class="line">3) Cancel installation</span><br><span class="line">&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再之后，按下 1，等待。完成后，您就已经安装了 Rust 和 rustup。</p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>要更新 Rust，在终端执行以下命令即可更新：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rustup update</span><br></pre></td></tr></table></figure>
<ul>
<li>update:升级rust工具链和rustup本身</li>
<li>self uninstall: 卸载rust</li>
<li>doc:在浏览器中打开离线文档</li>
</ul>
<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>要卸载 Rust 和 rustup，在终端执行以下命令即可卸载：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rustup self uninstall</span><br></pre></td></tr></table></figure>
<h2 id="检查安装是否成功"><a href="#检查安装是否成功" class="headerlink" title="检查安装是否成功"></a>检查安装是否成功</h2><p>检查是否正确安装了 Rust，可打开终端并输入下面这行，此时能看到最新发布的稳定版本的版本号、提交哈希值和提交日期：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ rustc -V</span><br><span class="line">rustc 1.56.1 (59eed8a2a 2021-11-01)</span><br><span class="line"></span><br><span class="line">$ cargo -V</span><br><span class="line">cargo 1.57.0 (b2e52d7ca 2021-10-21)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注：若发现版本号不同，以您的版本号为准<br>恭喜，你已成功安装 Rust！</p>
<p>如果没看到此信息:</p>
<ol>
<li>如果你使用的是 Windows，请检查 Rust 或 %USERPROFILE%.cargo\bin 是否在 %PATH% 系统变量中。</li>
<li>如果你使用的是 Windows 下的 Linux 子系统，请关闭并重新打开终端，再次执行以上命令。</li>
</ol>
<h1 id="3-vscode配置"><a href="#3-vscode配置" class="headerlink" title="3 vscode配置"></a>3 vscode配置</h1><h2 id="推荐插件"><a href="#推荐插件" class="headerlink" title="推荐插件"></a>推荐插件</h2><ul>
<li>社区驱动的rust-analyzer其他几个rust语言插件虽然是官方的，但都不如这个好用。</li>
<li>even-better-toml支持.toml 文件完整特性</li>
<li>crates 显示 crate 的最新版本，以及显示所有能使用的crate版本</li>
</ul>
<h2 id="安装-VSCode-的-Rust-插件"><a href="#安装-VSCode-的-Rust-插件" class="headerlink" title="安装 VSCode 的 Rust 插件"></a>安装 VSCode 的 Rust 插件</h2><p>在 VSCode 的左侧扩展目录里，搜索 rust, 你能看到两个 Rust 插件，如果没有意外，这两个应该分别排名第一和第二：</p>
<p>官方的 Rust，作者是 The Rust Programming Language, 官方出品，牛逼就完了，但是……我们并不推荐（事实上已经不再维护了，官方收编了第二个插件，现在第二个插件的作者也是 The Rust Programming Language），这个插件有几个问题：<br>首先是在代码跳转上支持的很烂，只能在自己的代码库中跳转，一旦跳到别的三方库，那就无法继续跳转，对于查看标准库和三方库的源码带来了极大的困扰<br>其次，不支持类型自动标注，对于 Rust 语言而言，类型说明是非常重要的，特别是在你不知道给变量一个什么类型时，这种 IDE 的自动提示就变得弥足珍贵<br>代码提示不太好用，有些方法既不会提示，也不能跳转<br>社区驱动的 rust-analyzer，非常推荐，上面说的所有问题，在这个插件上都得到了解决，不得不说，Rust 社区 yyds!<br>所以，综上所述，我们选择 rust-analyzer 作为 Rust 语言的插件，具体的安装很简单，点击插件，选择安装即可，根据提示可能需要重新加载 IDE。</p>
<table>
    <tr>
        <td bgcolor=#F0F8FF>在搜索 VSCode 插件时，报错：提取扩展出错，XHR failed，这个报错是因为网络原因导致，很可能是你的网络不行或者翻墙工具阻拦你的访问，试着关掉翻墙，再进行尝试。</td>
    </tr>
</table>

<p>安装完成后，在第一次打开 Rust 项目时，需要安装一些依赖，具体的状态在左下角会进行提示，包括下载、代码构建、building 等。</p>
<p>当插件使用默认设置时，每一次保存代码，都会出进行一次重新编译。</p>
<table>
    <tr>
        <td bgcolor=#F0F8FF>如果你的电脑慢，有一点一定要注意：
在编译器构建代码的同时，不要在终端再运行 cargo run 等命令进行编译，不然会获得一个报错提示，大意是当前文件目录已经被锁定，等待其它使用者释放。如果等了很久 IDE 还是没有释放（虽然我没遇到过，但是存在这个可能性），你可以关掉 IDE，并手动 kill 掉 rust-analyzer，然后重新尝试。</td>
    </tr>
</table>

<h3 id="rust-analyzer"><a href="#rust-analyzer" class="headerlink" title="rust-analyzer"></a>rust-analyzer</h3><p><img src="/../images/rust-analyzer.png"></p>
<h3 id="even-better-toml"><a href="#even-better-toml" class="headerlink" title="even-better-toml"></a>even-better-toml</h3><p>支持.toml文件（项目配置文件，类似Gradle）完整特性<br><img src="/../images/even-better-toml.png"></p>
<h3 id="crates-io"><a href="#crates-io" class="headerlink" title="crates-io"></a>crates-io</h3><p>crates已经无法使用 可以使用crates-io代替<br><img src="/../images/crates-io.png"></p>
<h3 id="logo-error-lens-png"><a href="#logo-error-lens-png" class="headerlink" title="logo-error-lens.png"></a>logo-error-lens.png</h3><p>更好的获得错误展示<br><img src="/../images/logo-error-lens.png"></p>
<h3 id="One-Dark-Pro"><a href="#One-Dark-Pro" class="headerlink" title="One Dark Pro"></a>One Dark Pro</h3><p>非常好看的 VSCode 主题</p>
<h3 id="CodeLLDB"><a href="#CodeLLDB" class="headerlink" title="CodeLLDB"></a>CodeLLDB</h3><p>Debugger 程序</p>
<h1 id="3-Hello-World"><a href="#3-Hello-World" class="headerlink" title="3. Hello,World"></a>3. Hello,World</h1><p>既然安装好了 Rust，是时候来编写第一个 Rust 程序了</p>
<h2 id="编写rust代码"><a href="#编写rust代码" class="headerlink" title="编写rust代码"></a>编写rust代码</h2><p>首先创建一个存放 Rust 代码的目录。Rust 并不关心代码的存放位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir hello world</span><br><span class="line">cd hello world</span><br></pre></td></tr></table></figure>
<p>接下来，新建一个源文件，命名为 main.rs。Rust源文件总是以,s扩展名结尾。如果文件名包含多个单词，那么按照命名习惯，应当使用下划线来分隔单词。例如命名为 hello_world.rs，而不是 he&#x2F;loworld.rs。现在打开刚创建的 main.rs 文件，输入示例 1-1中的代码,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    println!(&quot;Hello, world!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main文件夹下存在.rs结尾的rust源文件；</p>
<p>target下存放build之后的可执行文件；</p>
<p>Cargo.toml则是项目的配置文件，里面描述了我们项目的名称，版本号，依赖包管理等等….非常像Android中的Gradle。；</p>
<p>Cargo_lock文件是cargo工具根据同一项目的toml文件生成的项目依赖详细清单，我们一般不用去编辑它，只需要关注Cargo.toml文件内容即可。</p>
<h1 id="4-认识-Cargo"><a href="#4-认识-Cargo" class="headerlink" title="4. 认识 Cargo"></a>4. 认识 Cargo</h1><p>但凡经历过 C&#x2F;C++ 或 Go 语言 1.10 版本之前的用户都知道，一个好的包管理工具有多么的重要！！我那个时候是如此的渴望类似 nodejs 的 npm 包管理工具，但是却求而不得。</p>
<p>包管理工具最重要的意义就是任何用户拿到你的代码，都能运行起来，而不会因为各种包版本依赖焦头烂额。</p>
<p>Go 语言在 1.10 版本之前，所有的包都是在 github.com 下存放，导致了所有的项目都公用一套依赖代码，在本地项目复杂后，这简直是一种灾难。</p>
<p>说多了都是泪，笔者目前还有一个早期 Go 的项目 (15 年写的），用到了 iris （一个坑爹 HTTP 服务），结果现在运行不起来了，因为找不到 iris 当时的那个版本了！！</p>
<p>作为一门现代化语言，Rust 吸收了多个语言的包管理优点，为大家提供超级大杀器： cargo，真的，再挑剔的开发者，都对它赞不绝口。👍</p>
<p>总而言之，cargo 提供了一系列的工具，从项目的建立、构建到测试、运行直至部署，为 Rust 项目的管理提供尽可能完整的手段。同时，与 Rust 语言及其编译器 rustc 紧密结合，可以说用了后就忘不掉，如同初恋般的感觉。</p>
<h2 id="创建一个”你好，世界”项目"><a href="#创建一个”你好，世界”项目" class="headerlink" title="创建一个”你好，世界”项目"></a>创建一个”你好，世界”项目</h2><p>又见”你好，世界”，肯定有读者在批评了：你就不能有点创意吗？”世界，你好”难道不配？你是读者，你说了算，那我们就来创建一个”世界，你好”。</p>
<p>上文提到，Rust 语言的包管理工具是 cargo。不过，我们无需再手动安装，之前安装 Rust 的时候，就已经一并安装了。</p>
<p>终于到了紧张刺激的 new new new 环节：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo new test_demo</span><br><span class="line">cd test_demo</span><br></pre></td></tr></table></figure>
<p>上面的命令使用 cargo new 创建一个项目，项目名是 world_hello （向读者势力低头的项目名称，泪奔），该项目的结构和配置文件都是由 cargo 生成，意味着我们的项目被 cargo 所管理。</p>
<table>
    <tr>
        <td bgcolor=#F0F8FF>如果你在终端无法使用这个命令，考虑一下 环境变量 是否正确的设置：把 cargo 可执行文件所在的目录添加到环境变量中。

<p>如果是在 Windows 的 WSL2 子系统下，出现以下错误：</p>
<p>error: command failed: ‘rustc’ error: caused by: Permission denied (os error 13)</p>
<p>可尝试先卸载，再使用sudo命令进行安装：$ sudo curl –proto ‘&#x3D;https’ –tlsv1.2 <a target="_blank" rel="noopener" href="https://sh.rustup.rs/">https://sh.rustup.rs</a> -sSf | sh<br>        </td><br>    </tr></p>
</table>
进入 world_hello 目录并列出文件
+ Cargo.toml/文件
+ src 目录
  + src 目录中的 main.rs 文件
  
<h2 id="文件名-Cargo-toml"><a href="#文件名-Cargo-toml" class="headerlink" title="文件名:Cargo.toml"></a>文件名:Cargo.toml</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[package]</span><br><span class="line">name = &quot;world_hello&quot;</span><br><span class="line">version = &quot;0.1.0&quot;</span><br><span class="line">edition = &quot;2021&quot;</span><br><span class="line"></span><br><span class="line">[dependencies]</span><br><span class="line">ferris-says = &quot;0.3.1&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>[package]</p>
<ul>
<li>项目的名称</li>
<li>项目的版本</li>
<li>使用的 RuSt 版本</li>
</ul>
<p>[dependencies]<br>罗列项目依赖，在 Rust中，代码包被称为 crates</p>
<h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><p>有两种方式可以运行项目：</p>
<p>cargo run</p>
<p>手动编译和运行项目</p>
<p>首先来看看第一种方式，一码胜似千言，在之前创建的 world_hello 目录下运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.09s</span><br><span class="line">     Running `target\debug\world_hello.exe`</span><br><span class="line"> __________________________ </span><br><span class="line">&lt; Hello fellow Rustaceans! &gt;</span><br><span class="line"> -------------------------- </span><br><span class="line">        \</span><br><span class="line">         \</span><br><span class="line">            _~^~^~_</span><br><span class="line">        \) /  o o  \ (/     </span><br><span class="line">          &#x27;_   -   _&#x27;       </span><br><span class="line">          / &#x27;-----&#x27; \</span><br></pre></td></tr></table></figure>

<p>好了，你已经看到程序的输出：”Hello, world”。</p>
<p>如果你安装的 Rust 的 host triple 是 x86_64-pc-windows-msvc 并确认 Rust 已经正确安装，但在终端上运行上述命令时，出现类似如下的错误摘要 linking with <code>link.exe</code> failed: exit code: 1181，请使用 Visual Studio Installer 安装 Windows SDK。</p>
<p>可能有读者不愿意了，说好了”世界，你好”呢？别急，在下一节，我们再对代码进行修改。（认真想来，”你好，世界“强调的是我对世界说你好，而”世界，你好“是世界对我说你好，明显是后者更有包容性和国际范儿，读者真·好眼光。）</p>
<p>上述代码，cargo run 首先对项目进行编译，然后再运行，因此它实际上等同于运行了两个指令，下面我们手动试一下编译和运行项目：</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>在运行 Rust 程序之前，必须先使用 Rust 编译器编译它，即输入 rustc 命令并传入源文件名称，如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustc main.rs</span><br></pre></td></tr></table></figure>
<p>编译成功后，Rust 会输出一个二进制的可执行文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LSmain main.rs</span><br></pre></td></tr></table></figure>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>Rust是一种 预编译静态类型(ahead-of-time compiled)语言，这意味着你可以编译程序，并将可执行文件送给其他人，他们甚至不需要安装 Rust 就可以运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main</span><br></pre></td></tr></table></figure>

<h2 id="发布构建"><a href="#发布构建" class="headerlink" title="发布构建"></a>发布构建</h2><p>当项目最终准备好发布时，可以使用cargobuild–release 来优化编译项目</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build -release</span><br></pre></td></tr></table></figure>
<p>这会在 target&#x2F;release 而不是 target&#x2F;debug 下生成可执行文件。这些优化可以让 Rust代码运行的更快，不过启用这些优化要消耗更长的编译时间。<br>这也就是为什么会有两种不同的配置:</p>
<ul>
<li>一种是为了开发，你需要经常快速重新构建;</li>
<li>另一种是为用户构建最终程序，它们不会经常重新构建，并且希望程序运行得越快越好</li>
</ul>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>我们添加一个随机数功能的库(crate)。crate是一个 Rust 代码库，库 crate 可以包含任意能被其他程序使用的代码，但是不能自执行<br>文件名:Cargo.toml<br>[dependencies]rand &#x3D;”0.8.5’<br>重新构建项目</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build</span><br></pre></td></tr></table></figure>
<p>当有了新依赖，Cargo 会从 Crates.io 获取依赖，并将指定的依赖版本写入Cargo.lock文件中</p>
<p>为什么需要Cargo.lock文件<br>确保任何人在任何时候重新构建代码，都会产生相同的结果:Cargo只会使用你指定的依赖版本</p>
<p>当你 确实 需要升级 crate 时，Cargo提供了这样一个命令，update，它会忽路 Carga.&#x2F;ock文件，并计算出所有符合 Cargo.tom声明的最新版本。Cargo接下来会把这些版本写入Carga.1ock文件。不过，Cargo默认只会寻找大于 0.8.5 而小于 0.9.0 的版本。如果rand crate发布了两个新版本，0.8.6和0.9.0，在运行 cargo update 时会出现如下内容:</p>
<table>
    <td bgcolor=#F0F8FF>$ cargo updateUpdating crates.io indexUpdating randv.8.5->v.8.6
    </td>
</table>

<p>Cargo 忽略了 0.9.0版本。这时，你也会注意到的 Carg.1ock文件中的变化无外乎现在使用的 rand crate版本是 0.8.6。如<br>果想要使用 0.9.0版本的rand 或是任何 0.9.x 系列的版本，必须像这样更新 Cargo.tom&#x2F;文件:</p>
<table>
    <td bgcolor=#F0F8FF>[dependencies]
rand = "0.9.0"
    </td>
</table>

<h2 id="cargo-check"><a href="#cargo-check" class="headerlink" title="cargo check"></a>cargo check</h2><p>当项目大了后，cargo run 和 cargo build 不可避免的会变慢，那么有没有更快的方式来验证代码的正确性呢？大杀器来了，接着！<br>cargo check 是我们在代码开发过程中最常用的命令，它的作用很简单：快速的检查一下代码能否编译通过。因此该命令速度会非常快，能节省大量的编译时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cargo check</span><br><span class="line">    Checking world_hello v0.1.0 (/Users/sunfei/development/rust/world_hello)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.06s</span><br></pre></td></tr></table></figure>
<p>Rust 虽然编译速度还行，但是还是不能与 Go 语言相提并论，因为 Rust 需要做很多复杂的编译优化和语言特性解析，甚至连如何优化编译速度都成了一门学问: 优化编译速度</p>
<p>Cargo.toml 和 Cargo.lock<br>Cargo.toml 和 Cargo.lock 是 cargo 的核心文件，它的所有活动均基于此二者。</p>
<p>Cargo.toml 是 cargo 特有的项目数据描述文件。它存储了项目的所有元配置信息，如果 Rust 开发者希望 Rust 项目能够按照期望的方式进行构建、测试和运行，那么，必须按照合理的方式构建 Cargo.toml。</p>
<p>Cargo.lock 文件是 cargo 工具根据同一项目的 toml 文件生成的项目依赖详细清单，因此我们一般不用修改它，只需要对着 Cargo.toml 文件撸就行了。</p>
<p>什么情况下该把 Cargo.lock 上传到 git 仓库里？很简单，当你的项目是一个可运行的程序时，就上传 Cargo.lock，如果是一个依赖库项目，那么请把它添加到 .gitignore 中。</p>
<p>现在用 VSCode 打开上面创建的”世界，你好”项目，然后进入根目录的 Cargo.toml 文件，可以看到该文件包含不少信息：<br>package 配置段落<br>package 中记录了项目的描述信息，典型的如下：</p>
<table>
    <td bgcolor=#F0F8FF>[package]
name = "world_hello"
version = "0.1.0"
edition = "2021"
    </td>
</table>

<p>name 字段定义了项目名称，version 字段定义当前版本，新项目默认是 0.1.0，edition 字段定义了我们使用的 Rust 大版本。因为本书很新（不仅仅是现在新，未来也将及时修订，跟得上 Rust 的小步伐），所以使用的是 Rust edition 2021 大版本，详情见 Rust 版本详解</p>
<h2 id="配置国内镜像"><a href="#配置国内镜像" class="headerlink" title="配置国内镜像"></a>配置国内镜像</h2><p>为了使用 crates.10之外的注册服务，我们需要对 $HOME&#x2F;.cargo&#x2F;conf1g.toml 文件进行配置，添加新的服务提供商cargo 1.68版本卉始支持稀疏索引:不再需要完整克隆 crates.io-index 仓库，可以加快获取包的速度<br>协议推荐使用 git，但对于 htps 和 git 协议，一般各镜像源都支持，并且是可以互换的。如果你所处的环境中不允许使用git 协议，或者配置 git 协议后不能正常获取和编译 crate，可以换 https 协议再试试有两种方式可以实现:增加新的镜像地址和覆盖默认的镜像地址。</p>
<h2 id="两者相同，选择一种方式即可"><a href="#两者相同，选择一种方式即可" class="headerlink" title="两者相同，选择一种方式即可"></a>两者相同，选择一种方式即可</h2><h3 id="https的"><a href="#https的" class="headerlink" title="https的"></a>https的</h3><p>[registries]ustc &#x3D;{index&#x3D;”<a target="_blank" rel="noopener" href="https://mirrors.ustc.edu.cn/crates.io-index/%22%7D">https://mirrors.ustc.edu.cn/crates.io-index/&quot;}</a><br>[registries.ustc]index &#x3D;”<a target="_blank" rel="noopener" href="https://mirrors.ustc.edu.cn/crates.io-index/">https://mirrors.ustc.edu.cn/crates.io-index/</a>“</p>
<h3 id="git的"><a href="#git的" class="headerlink" title="git的"></a>git的</h3><p>[registries]ustc &#x3D;{index&#x3D;”git:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;crates.io-index” }<br>[registries.ustc]index&#x3D;”git:&#x2F;nirrors.ustc.edu.cn&#x2F;crates.io-index”</p>
<h2 id="如果支持稀疏索引的话。两者相同，选择一种方式即可"><a href="#如果支持稀疏索引的话。两者相同，选择一种方式即可" class="headerlink" title="如果支持稀疏索引的话。两者相同，选择一种方式即可"></a>如果支持稀疏索引的话。两者相同，选择一种方式即可</h2><h3 id="https的-1"><a href="#https的-1" class="headerlink" title="https的"></a>https的</h3><p>[registries]<br>ustc &#x3D;{ index&#x3D;”sparse+<a target="_blank" rel="noopener" href="https://mirrors.ustc.edu.cn/crates.io-index/%22%7D[registries.ustc]index=%22sparse+https://mirrors.ustc.edu.cn/crates.io-index/">https://mirrors.ustc.edu.cn/crates.io-index/&quot;}[registries.ustc]index=&quot;sparse+https://mirrors.ustc.edu.cn/crates.io-index/</a>“</p>
<h3 id="git的-1"><a href="#git的-1" class="headerlink" title="git的"></a>git的</h3><p>[registries]<br>ustc &#x3D;{ index&#x3D;”sparse+git:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;crates.io-index” }<br>[registries.ustc]<br>index&#x3D;”sparse+git:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;crates.io-index”</p>
<h2 id="覆盖默认的镜像地址"><a href="#覆盖默认的镜像地址" class="headerlink" title="覆盖默认的镜像地址"></a>覆盖默认的镜像地址</h2><p>而第二种方式，则不需要修改 Cargo.toml 文件，因为它是直接使用新注册服务来替代默认的 crates.io 。在 $HOME&#x2F;.cargo&#x2F;config.toml 添加以下内容:<br>[source.crates-io]replace-with &#x3D;’ustc!’<br>[source.ustc]registry &#x3D;”git:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;crates.io-index”<br>首先，创建一个新的镜像源【source.ustc)，然后将默认的crates-10 替换成新的镜像源:replace-with&#x3D;’ustc’</p>
<h2 id="可用的镜像列表"><a href="#可用的镜像列表" class="headerlink" title="可用的镜像列表"></a>可用的镜像列表</h2><p>#中国科学技术大学”<a target="_blank" rel="noopener" href="https://mirrors.ustc.edu.cn/crates.io-index'%22git://mirrors.ustc.edu.cn/crates.i0-index">https://mirrors.ustc.edu.cn/crates.io-index&#39;&quot;git://mirrors.ustc.edu.cn/crates.i0-index</a>“<br>#上海交通大学”<a target="_blank" rel="noopener" href="https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index/">https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index/</a>“<br>#清华大学”<a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git">https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git</a>“<br>#字节跳动”<a target="_blank" rel="noopener" href="https://rsproxy.cn/crates.io-index">https://rsproxy.cn/crates.io-index</a>“</p>
<h2 id="Cargo小结"><a href="#Cargo小结" class="headerlink" title="Cargo小结"></a>Cargo小结</h2><p>对于简单项目，Cargo并不比rustc提供了更多的优势，不过随着开发的深入，终将证明其价值。一旦程序壮大到由多个文件组成，亦或者是需要其他的依赖，让 Cargo 协调构建过程就会简单得多。<br>我们回顾下已学习的 Cargo 内容:<br>。可以使用 cargo new 创建项目<br>。Cargo 期望源文件放在 src 目录中<br>。项目根目录只存放 README、license 信息、配置文件和其他跟代码无关的文件<br>。使用 Cargo 帮助你保持项目干净整洁，一切井井有条。可以使用 cargo build 构建项目<br>。cargo build-release 构建最终用户程序，编译时间更长。可以使用 cargo run 一步构建并运行项目<br>。大多数开发者开发者的选择</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>rust是一个类型安全 静态编译的语言。rust官网拥有丰富的学习资料。</li>
<li>使用rustup来管理rust版本和相关工具的命令行(cargo rustc..)</li>
<li>vscode 推荐插件rust-analyzer even-better-toml crates</li>
<li>rustc是rust的编译器，</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives%7C%7C%20archive">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">One Byte</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
