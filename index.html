<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Byte的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Byte的博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="One Byte">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/"/>





  <title>Byte的博客</title>
  








<meta name="generator" content="Hexo 7.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Byte的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/21/learnRust5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Byte的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/21/learnRust5/" itemprop="url">Rust入门-基础 第五节 基础类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-08-21T00:13:30+08:00">
                2024-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1.基本类型"></a>1.基本类型</h1><p>Rust 每个值都有其确切的数据类型，总的来说可以分为两类：基本类型和复合类型。 基本类型意味着它们往往是一个最小化原子类型，无法解构为其它类型(一般意义上来说)</p>
<ul>
<li>数值类型: 有符号整数 (i8, i16, i32, i64, isize)、 无符号整数 (u8, u16, u32, u64, usize) 、浮点数 (f32, f64)、以及有理数、复数</li>
<li>isize usize 与机器字(32位或64位)一样大的有符号整数和无符号整数</li>
<li>复合类型（Compound types）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）</li>
<li>字符串：字符串字面量和字符串切片 &amp;str</li>
<li>布尔类型： true和false</li>
<li>字符类型: 表示单个 Unicode 字符，存储为 4 个字节</li>
<li>单元类型: 即 () ，其唯一的值也是 ()</li>
<li>struct S 具名字段型结构体 S {x:120,y:209.0}</li>
<li>struct T(i32,char); 元组型结构体</li>
<li>struct E 单元型结构体,无字段</li>
<li>enum 枚举 或代数或数据类型</li>
<li>Box<Attend> 指向堆中值的拥有型指针</li>
<li>&amp;i32 &amp;mut i32 共享引用和可变引用:非拥有型指针 其生命周期不能超出引用目标</li>
<li>string UTF8 字符串 动态分配大小</li>
<li>&amp;str 对str的引用：指向UTF-8文本的非拥有型指针</li>
<li>[f64;4] [u8;256] 数组 固定长度 其元素类型都相同</li>
<li>Vec<f64> 向量 可变长度 其元素类型都相同</li>
<li>&amp;[u8] *mut [u8] 对切片(数组或向量某一部分)的引用 包含指针和长度</li>
<li>Option&lt;&amp;str&gt; 可选值:或者为 None(无值) 或者为 Some(v) (有值 其值位v)   Some(“Dr.”) None</li>
<li>Result 可能失败的操作结果:或者为成功值Ok(v) 或者为错误值Err(e)        Ok(4096) Err(Error::last_os_error())</li>
<li>&amp;dyn Any &amp;mut dyn Read 特型对象 是对任何实现了一组给定方法的值的引用  </li>
<li>fn(&amp;str) -&gt; bool 函数指针 str::is_empty</li>
<li>闭包类型没有显示书写形式 闭包 |a,b| a*a + b * b</li>
<li>x..&#x3D;y 序列 1..&#x3D;4</li>
</ul>
<h1 id="1-1整数类型"><a href="#1-1整数类型" class="headerlink" title="1.1整数类型"></a>1.1整数类型</h1><p>整数是没有小数部分的数字。之前使用过的 i32 类型，表示有符号的 32 位整数（ i 是英文单词 integer 的首字母，与之相反的是 u，代表无符号 unsigned 类型）。下表显示了 Rust 中的内置的整数类型</p>
<table>
<thead>
<tr>
<th align="center">长度</th>
<th align="center">有符号类型</th>
<th align="center">无符号类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">8 位</td>
<td align="center">i8</td>
<td align="center">u8</td>
</tr>
<tr>
<td align="center">16 位</td>
<td align="center">i16</td>
<td align="center">u16</td>
</tr>
<tr>
<td align="center">32 位</td>
<td align="center">i32</td>
<td align="center">u32</td>
</tr>
<tr>
<td align="center">64 位</td>
<td align="center">i64</td>
<td align="center">u64</td>
</tr>
<tr>
<td align="center">128 位</td>
<td align="center">i128</td>
<td align="center">u128</td>
</tr>
<tr>
<td align="center">视架构而定</td>
<td align="center">isize</td>
<td align="center">usize</td>
</tr>
</tbody></table>
<p>类型定义的形式统一为：有无符号 + 类型大小(位数)。无符号数表示数字只能取正数和0，而有符号则表示数字可以取正数、负数还有0。就像在纸上写数字一样：当要强调符号时，数字前面可以带上正号或负号；然而，当很明显确定数字为正数时，就不需要加上正号了。有符号数字以补码形式存储。</p>
<p>每个有符号类型规定的数字范围是 -(2n - 1) ~ 2n - 1 - 1，其中 n 是该定义形式的位长度。因此 i8 可存储数字范围是 -(27) ~ 27 - 1，即 -128 ~ 127。无符号类型可以存储的数字范围是 0 ~ 2n - 1，所以 u8 能够存储的数字为 0 ~ 28 - 1，即 0 ~ 255。</p>
<p>此外，isize 和 usize 类型取决于程序运行的计算机 CPU 类型： 若 CPU 是 32 位的，则这两个类型是 32 位的，同理，若 CPU 是 64 位，那么它们则是 64 位。</p>
<p>整形字面量可以用下表的形式书写：</p>
<table>
<thead>
<tr>
<th align="center">数字字面量</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">十进制</td>
<td align="center">98_222</td>
</tr>
<tr>
<td align="center">十六进制</td>
<td align="center">0xff</td>
</tr>
<tr>
<td align="center">八进制</td>
<td align="center">0o77</td>
</tr>
<tr>
<td align="center">二进制</td>
<td align="center">0b1111_0000</td>
</tr>
<tr>
<td align="center">字节 (仅限于 u8)</td>
<td align="center">b’A’</td>
</tr>
</tbody></table>
<h2 id="1-2-整形实例"><a href="#1-2-整形实例" class="headerlink" title="1.2 整形实例"></a>1.2 整形实例</h2><p> Rust 整型默认使用 i32，例如 let i &#x3D; 1，那 i 就是 i32 类型，因此你可以首选它，同时该类型也往往是性能最好的。isize 和 usize 的主要应用场景是用作集合的索引。</p>
<h1 id="1-3-整型溢出"><a href="#1-3-整型溢出" class="headerlink" title="1.3 整型溢出"></a>1.3 整型溢出</h1><p>假设有一个 u8 ，它可以存放从 0 到 255 的值。那么当你将其修改为范围之外的值，比如 256，则会发生整型溢出。关于这一行为 Rust 有一些有趣的规则：当在 debug 模式编译时，Rust 会检查整型溢出，若存在这些问题，则使程序在编译时 panic(崩溃,Rust 使用这个术语来表明程序因错误而退出)。</p>
<p>在当使用 –release 参数进行 release 模式构建时，Rust 不检测溢出。相反，当检测到整型溢出时，Rust 会按照补码循环溢出（two’s complement wrapping）的规则处理。简而言之，大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在 u8 的情况下，256 变成 0，257 变成 1，依此类推。程序不会 panic，但是该变量的值可能不是你期望的值。依赖这种默认行为的代码都应该被认为是错误的代码。</p>
<p>要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：</p>
<ul>
<li>使用 wrapping_* 方法在所有模式下都按照补码循环溢出规则处理，例如 wrapping_add</li>
<li>如果使用 checked_* 方法时发生溢出，则返回 None 值</li>
<li>使用 overflowing_* 方法返回该值和一个指示是否存在溢出的布尔值</li>
<li>使用 saturating_* 方法，可以限定计算后的结果不超过目标类型的最大值或低于最小值，例如:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assert_eq!(100u8.saturating_add(1), 101);</span><br><span class="line">assert_eq!(u8::MAX.saturating_add(127), u8::MAX);</span><br></pre></td></tr></table></figure>
<p>下面是一个演示wrapping_*方法的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a : u8 = 255;</span><br><span class="line">    let b = a.wrapping_add(20);</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, b);  // 19</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-浮点类型"><a href="#2-浮点类型" class="headerlink" title="2.浮点类型"></a>2.浮点类型</h1><p>浮点类型数字 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型： f32 和 f64，分别为 32 位和 64 位大小。默认浮点类型是 f64，在现代的 CPU 中它的速度与 f32 几乎相同，但精度更高。</p>
<p>下面是一个演示浮点数的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = 2.0; // f64</span><br><span class="line"></span><br><span class="line">    let y: f32 = 3.0; // f32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>浮点数根据 IEEE-754 标准实现。f32 类型是单精度浮点型，f64 为双精度。</p>
<h1 id="2-1浮点数陷阱"><a href="#2-1浮点数陷阱" class="headerlink" title="2.1浮点数陷阱"></a>2.1浮点数陷阱</h1><p>浮点数由于底层格式的特殊性，导致了如果在使用浮点数时不够谨慎，就可能造成危险，有两个原因：</p>
<p>浮点数往往是你想要数字的近似表达 浮点数类型是基于二进制实现的，但是我们想要计算的数字往往是基于十进制，例如 0.1 在二进制上并不存在精确的表达形式，但是在十进制上就存在。这种不匹配性导致一定的歧义性，更多的，虽然浮点数能代表真实的数值，但是由于底层格式问题，它往往受限于定长的浮点数精度，如果你想要表达完全精准的真实数字，只有使用无限精度的浮点数才行</p>
<p>浮点数在某些特性上是反直觉的 例如大家都会觉得浮点数可以进行比较，对吧？是的，它们确实可以使用 &gt;，&gt;&#x3D; 等进行比较，但是在某些场景下，这种直觉上的比较特性反而会害了你。因为 f32 ， f64 上的比较运算实现的是 std::cmp::PartialEq 特征(类似其他语言的接口)，但是并没有实现 std::cmp::Eq 特征，但是后者在其它数值类型上都有定义，说了这么多，可能大家还是云里雾里，用一个例子来举例：</p>
<p>Rust 的 HashMap 数据结构，是一个 KV 类型的 Hash Map 实现，它对于 K 没有特定类型的限制，但是要求能用作 K 的类型必须实现了 std::cmp::Eq 特征，因此这意味着你无法使用浮点数作为 HashMap 的 Key，来存储键值对，但是作为对比，Rust 的整数类型、字符串类型、布尔类型都实现了该特征，因此可以作为 HashMap 的 Key。</p>
<p>为了避免上面说的两个陷阱，你需要遵守以下准则：</p>
<p>避免在浮点数上测试相等性<br>当结果在数学上可能存在未定义时，需要格外的小心<br>来看个小例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  // 断言0.1 + 0.2与0.3相等</span><br><span class="line">  assert!(0.1 + 0.2 == 0.3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能以为，这段代码没啥问题吧，实际上它会 panic(程序崩溃，抛出异常)，因为二进制精度问题，导致了 0.1 + 0.2 并不严格等于 0.3，它们可能在小数点 N 位后存在误差。</p>
<p>那如果非要进行比较呢？可以考虑用这种方式 (0.1_f64 + 0.2 - 0.3).abs() &lt; 0.00001 ，具体小于多少，取决于你对精度的需求。</p>
<p>讲到这里，相信大家基本已经明白了，为什么操作浮点数时要格外的小心，但是还不够，下面再来一段代码，直接震撼你的灵魂：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let abc: (f32, f32, f32) = (0.1, 0.2, 0.3);</span><br><span class="line">    let xyz: (f64, f64, f64) = (0.1, 0.2, 0.3);</span><br><span class="line"></span><br><span class="line">    println!(&quot;abc (f32)&quot;);</span><br><span class="line">    println!(&quot;   0.1 + 0.2: &#123;:x&#125;&quot;, (abc.0 + abc.1).to_bits());</span><br><span class="line">    println!(&quot;         0.3: &#123;:x&#125;&quot;, (abc.2).to_bits());</span><br><span class="line">    println!();</span><br><span class="line"></span><br><span class="line">    println!(&quot;xyz (f64)&quot;);</span><br><span class="line">    println!(&quot;   0.1 + 0.2: &#123;:x&#125;&quot;, (xyz.0 + xyz.1).to_bits());</span><br><span class="line">    println!(&quot;         0.3: &#123;:x&#125;&quot;, (xyz.2).to_bits());</span><br><span class="line">    println!();</span><br><span class="line"></span><br><span class="line">    assert!(abc.0 + abc.1 == abc.2);</span><br><span class="line">    assert!(xyz.0 + xyz.1 == xyz.2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行该程序，输出如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">abc (f32)</span><br><span class="line">   0.1 + 0.2: 3e99999a</span><br><span class="line">         0.3: 3e99999a</span><br><span class="line"></span><br><span class="line">xyz (f64)</span><br><span class="line">   0.1 + 0.2: 3fd3333333333334</span><br><span class="line">         0.3: 3fd3333333333333</span><br><span class="line"></span><br><span class="line">thread &#x27;main&#x27; panicked at &#x27;assertion failed: xyz.0 + xyz.1 == xyz.2&#x27;,</span><br><span class="line">➥ch2-add-floats.rs.rs:14:5</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display</span><br><span class="line">➥a backtrace</span><br></pre></td></tr></table></figure>
<p>仔细看，对 f32 类型做加法时，0.1 + 0.2 的结果是 3e99999a，0.3 也是 3e99999a，因此 f32 下的 0.1 + 0.2 &#x3D;&#x3D; 0.3 通过测试，但是到了 f64 类型时，结果就不一样了，因为 f64 精度高很多，因此在小数点非常后面发生了一点微小的变化，0.1 + 0.2 以 4 结尾，但是 0.3 以3结尾，这个细微区别导致 f64 下的测试失败了，并且抛出了异常。</p>
<h1 id="3-NaN"><a href="#3-NaN" class="headerlink" title="3.NaN"></a>3.NaN</h1><p>对于数学上未定义的结果，例如对负数取平方根 -42.1.sqrt() ，会产生一个特殊的结果：Rust 的浮点数类型使用 NaN (not a number)来处理这些情况。</p>
<p>所有跟 NaN 交互的操作，都会返回一个 NaN，而且 NaN 不能用来比较，下面的代码会崩溃：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  let x = (-42.0_f32).sqrt();</span><br><span class="line">  assert_eq!(x, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出于防御性编程的考虑，可以使用 is_nan() 等方法，可以用来判断一个数值是否是 NaN ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = (-42.0_f32).sqrt();</span><br><span class="line">    if x.is_nan() &#123;</span><br><span class="line">        println!(&quot;未定义的数学行为&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-数字运算"><a href="#4-数字运算" class="headerlink" title="4.数字运算"></a>4.数字运算</h1><p>Rust 支持所有数字类型的基本数学运算：加法、减法、乘法、除法和取模运算。下面代码各使用一条 let 语句来说明相应运算的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // 加法</span><br><span class="line">    let sum = 5 + 10;</span><br><span class="line"></span><br><span class="line">    // 减法</span><br><span class="line">    let difference = 95.5 - 4.3;</span><br><span class="line"></span><br><span class="line">    // 乘法</span><br><span class="line">    let product = 4 * 30;</span><br><span class="line"></span><br><span class="line">    // 除法</span><br><span class="line">    let quotient = 56.7 / 32.2;</span><br><span class="line"></span><br><span class="line">    // 求余</span><br><span class="line">    let remainder = 43 % 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些语句中的每个表达式都使用了数学运算符，并且计算结果为一个值，然后绑定到一个变量上。</p>
<p>再来看一个综合性的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  // 编译器会进行自动推导，给予twenty i32的类型</span><br><span class="line">  let twenty = 20;</span><br><span class="line">  // 类型标注</span><br><span class="line">  let twenty_one: i32 = 21;</span><br><span class="line">  // 通过类型后缀的方式进行类型标注：22是i32类型</span><br><span class="line">  let twenty_two = 22i32;</span><br><span class="line"></span><br><span class="line">  // 只有同样类型，才能运算</span><br><span class="line">  let addition = twenty + twenty_one + twenty_two;</span><br><span class="line">  println!(&quot;&#123;&#125; + &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;, twenty, twenty_one, twenty_two, addition);</span><br><span class="line"></span><br><span class="line">  // 对于较长的数字，可以用_进行分割，提升可读性</span><br><span class="line">  let one_million: i64 = 1_000_000;</span><br><span class="line">  println!(&quot;&#123;&#125;&quot;, one_million.pow(2));</span><br><span class="line"></span><br><span class="line">  // 定义一个f32数组，其中42.0会自动被推导为f32类型</span><br><span class="line">  let forty_twos = [</span><br><span class="line">    42.0,</span><br><span class="line">    42f32,</span><br><span class="line">    42.0_f32,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  // 打印数组中第一个值，并控制小数位为2位</span><br><span class="line">  println!(&quot;&#123;:.2&#125;&quot;, forty_twos[0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-位运算"><a href="#5-位运算" class="headerlink" title="5.位运算"></a>5.位运算</h1><p>Rust的位运算基本上和其他语言一样</p>
<p>运算符	说明<br>&amp; 位与	相同位置均为1时则为1，否则为0<br>| 位或	相同位置只要有1时则为1，否则为0<br>^ 异或	相同位置不相同则为1，相同则为0<br>! 位非	把位中的0和1相互取反，即0置为1，1置为0<br>&lt;&lt; 左移	所有位向左移动指定位数，右位补0<br>&gt;&gt; 右移	所有位向右移动指定位数，带符号移动（正数补0，负数补1）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // 二进制为00000010</span><br><span class="line">    let a:i32 = 2;</span><br><span class="line">    // 二进制为00000011</span><br><span class="line">    let b:i32 = 3;</span><br><span class="line"></span><br><span class="line">    println!(&quot;(a &amp; b) value is &#123;&#125;&quot;, a &amp; b);</span><br><span class="line"></span><br><span class="line">    println!(&quot;(a | b) value is &#123;&#125;&quot;, a | b);</span><br><span class="line"></span><br><span class="line">    println!(&quot;(a ^ b) value is &#123;&#125;&quot;, a ^ b);</span><br><span class="line"></span><br><span class="line">    println!(&quot;(!b) value is &#123;&#125; &quot;, !b);</span><br><span class="line"></span><br><span class="line">    println!(&quot;(a &lt;&lt; b) value is &#123;&#125;&quot;, a &lt;&lt; b);</span><br><span class="line"></span><br><span class="line">    println!(&quot;(a &gt;&gt; b) value is &#123;&#125;&quot;, a &gt;&gt; b);</span><br><span class="line"></span><br><span class="line">    let mut a = a;</span><br><span class="line">    // 注意这些计算符除了!之外都可以加上=进行赋值 (因为!=要用来判断不等于)</span><br><span class="line">    a &lt;&lt;= b;</span><br><span class="line">    println!(&quot;(a &lt;&lt; b) value is &#123;&#125;&quot;, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-序列-Range"><a href="#6-序列-Range" class="headerlink" title="6.序列(Range)"></a>6.序列(Range)</h1><p>Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 1..5，生成从 1 到 4 的连续数字，不包含 5 ；1..&#x3D;5，生成从 1 到 5 的连续数字，包含 5，它的用途很简单，常常用于循环中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in 1..=5 &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终程序输出:</p>
<p>1<br>2<br>3<br>4<br>5<br>序列只允许用于数字或字符类型，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。如下是一个使用字符类型序列的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in &#x27;a&#x27;..=&#x27;z&#x27; &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-使用-As-完成类型转换"><a href="#7-使用-As-完成类型转换" class="headerlink" title="7.使用 As 完成类型转换"></a>7.使用 As 完成类型转换</h1><p>Rust 中可以使用 As 来完成一个类型到另一个类型的转换，其最常用于将原始类型转换为其他原始类型，但是它也可以完成诸如将指针转换为地址、地址转换为指针以及将指针转换为其他指针等功能。你可以在这里了解更多相关的知识。</p>
<h1 id="8-有理数和复数"><a href="#8-有理数和复数" class="headerlink" title="8.有理数和复数"></a>8.有理数和复数</h1><p>Rust 的标准库相比其它语言，准入门槛较高，因此有理数和复数并未包含在标准库中：</p>
<p>有理数和复数<br>任意大小的整数和任意精度的浮点数<br>固定精度的十进制小数，常用于货币相关的场景<br>好在社区已经开发出高质量的 Rust 数值库：num。</p>
<p>按照以下步骤来引入 num 库：</p>
<ol>
<li>创建新工程 cargo new complex-num &amp;&amp; cd complex-num</li>
<li>在 Cargo.toml 中的 [dependencies] 下添加一行 num &#x3D; “0.4.0”</li>
<li>将 src&#x2F;main.rs 文件中的 main 函数替换为下面的代码</li>
<li>运行 cargo run<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use num::complex::Complex;</span><br><span class="line"></span><br><span class="line"> fn main() &#123;</span><br><span class="line">   let a = Complex &#123; re: 2.1, im: -1.2 &#125;;</span><br><span class="line">   let b = Complex::new(11.1, 22.2);</span><br><span class="line">   let result = a + b;</span><br><span class="line"></span><br><span class="line">   println!(&quot;&#123;&#125; + &#123;&#125;i&quot;, result.re, result.im)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="9-布尔-bool"><a href="#9-布尔-bool" class="headerlink" title="9.布尔(bool)"></a>9.布尔(bool)</h1><p>Rust 中的布尔类型有两个可能的值：true 和 false，布尔值占用内存的大小为 1 个字节：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let t = true;</span><br><span class="line"></span><br><span class="line">    let f: bool = false; // 使用类型标注,显式指定f的类型</span><br><span class="line"></span><br><span class="line">    if f &#123;</span><br><span class="line">        println!(&quot;这是段毫无意义的代码&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用布尔类型的场景主要在于流程控制，例如上述代码的中的 if 就是其中之一。</p>
<h1 id="10-字符类型-char"><a href="#10-字符类型-char" class="headerlink" title="10.字符类型(char)"></a>10.字符类型(char)</h1><p>字符，对于没有其它编程经验的新手来说可能不太好理解（没有编程经验敢来学 Rust 的绝对是好汉），但是你可以把它理解为英文中的字母，中文中的汉字。</p>
<p>下面的代码展示了几个颇具异域风情的字符：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let c = &#x27;z&#x27;;</span><br><span class="line">    let z = &#x27;ℤ&#x27;;</span><br><span class="line">    let g = &#x27;国&#x27;;</span><br><span class="line">    let heart_eyed_cat = &#x27;😻&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果大家是从有年代感的编程语言过来，可能会大喊一声：这 XX 叫字符？是的，在 Rust 语言中这些都是字符，Rust 的字符不仅仅是 ASCII，所有的 Unicode 值都可以作为 Rust 字符，包括单个的中文、日文、韩文、emoji 表情符号等等，都是合法的字符类型。Unicode 值的范围从 U+0000 ~ U+D7FF 和 U+E000 ~ U+10FFFF。不过“字符”并不是 Unicode 中的一个概念，所以人在直觉上对“字符”的理解和 Rust 的字符概念并不一致。</p>
<p>由于 Unicode 都是 4 个字节编码，因此字符类型也是占用 4 个字节：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = &#x27;中&#x27;;</span><br><span class="line">    println!(&quot;字符&#x27;中&#x27;占用了&#123;&#125;字节的内存大小&quot;,std::mem::size_of_val(&amp;x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出如下:<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling ...</span><br></pre></td></tr></table></figure><br>字符’中’占用了4字节的内存大小</p>
<table>
    <td bgcolor=#F0F8FF>[package]
        注意，我们还没开始讲字符串，但是这里提前说一下，和一些语言不同，Rust 的字符只能用 '' 来表示， "" 是留给字符串的。
    </td>
</table>


<h1 id="9-总结"><a href="#9-总结" class="headerlink" title="9.总结"></a>9.总结</h1><p>之前提到了过 Rust 的数值类型和运算跟其他语言较为相似，但是实际上，除了语法上的不同之外，还是存在一些差异点：</p>
<p>Rust 拥有相当多的数值类型. 因此你需要熟悉这些类型所占用的字节数，这样就知道该类型允许的大小范围以及你选择的类型是否能表达负数<br>类型转换必须是显式的. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数<br>Rust 的数值上可以使用方法. 例如你可以用以下方法来将 13.14 取整：13.14_f32.round()，在这里我们使用了类型后缀，因为编译器需要知道 13.14 的具体类型<br>数值类型的讲解已经基本结束，接下来，来看看字符和布尔类型。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/14/color/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Byte的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/14/color/" itemprop="url">Color</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-08-14T00:58:23+08:00">
                2024-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>#E0FFFF: 亮浅蓝色 (Light Cyan)</li>
<li>#D3E8FF: 淡蓝色 (Pale Blue)</li>
<li>#F0F8FF: 爱丽丝蓝 (Alice Blue)</li>
<li>#CCFFFF: 淡青色 (Pale Cyan)</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/14/learnRust4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Byte的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/14/learnRust4/" itemprop="url">Rust入门-基础 第四节 Rust - 流程控制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-08-14T00:37:21+08:00">
                2024-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="if-表达式"><a href="#if-表达式" class="headerlink" title="if 表达式"></a>if 表达式</h1><p>不像 Ruby 或 JavaScript这样的语言，Rust并不会尝试自动地将非布尔值转换为布尔值。必须总是显式地使用布尔值作为 if 条件<br>但凡你能找到一门编程语言没有 if else，那么一定更要反馈给鲁迅，反正不是我说的:) 总之，只要你拥有其它语言的编程经验，就一定会有以下认知：if else 表达式根据条件执行不同的代码分支：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if condition == true &#123;</span><br><span class="line">    // A...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // B...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码读作：若 condition 的值为 true，则执行 A 代码，否则执行 B 代码。</p>
<p>先看下面代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let condition = true;</span><br><span class="line">    let number = if condition &#123;</span><br><span class="line">        5</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        6</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;The value of number is: &#123;&#125;&quot;, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码有以下几点要注意：</p>
<ul>
<li>if 语句块是表达式，这里我们使用 if 表达式的返回值来给 number 进行赋值：number 的值是 5</li>
<li>用 if 来赋值时，要保证每个分支返回的类型一样(事实上，这种说法不完全准确，见这里)，此处返回的 5 和 6 就是同一个类型，如果返回类型不一致就会报错</li>
<li>代码块的值是其最后一个表达式的值，这里继续不谈**语句(statement)和表达式(expression)**的概念，只要知道这里不应该有分号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let number:i32 = 3;</span><br><span class="line">    if number &lt; 5 &#123;</span><br><span class="line">        println!(&quot;condition was true&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        println!(&quot;condition was false&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="以上代码有以下几点要注意："><a href="#以上代码有以下几点要注意：" class="headerlink" title="以上代码有以下几点要注意："></a>以上代码有以下几点要注意：</h2><ul>
<li>if 语句块是表达式，这里我们使用 if 表达式的返回值来给 number 进行赋值：number 的值是 5</li>
<li>用 if 来赋值时，要保证每个分支返回的类型一样(事实上，这种说法不完全准确，见这里)，此处返回的 5 和 6 就是同一个类型，如果返回类型不一致就会报错</li>
</ul>
<h1 id="使用-else-if-来处理多重条件"><a href="#使用-else-if-来处理多重条件" class="headerlink" title="使用 else if 来处理多重条件"></a>使用 else if 来处理多重条件</h1><p>可以将 else if 与 if、else 组合在一起实现更复杂的条件分支判断：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let n = 6;</span><br><span class="line"></span><br><span class="line">    if n % 4 == 0 &#123;</span><br><span class="line">        println!(&quot;number is divisible by 4&quot;);</span><br><span class="line">    &#125; else if n % 3 == 0 &#123;</span><br><span class="line">        println!(&quot;number is divisible by 3&quot;);</span><br><span class="line">    &#125; else if n % 2 == 0 &#123;</span><br><span class="line">        println!(&quot;number is divisible by 2&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        println!(&quot;number is not divisible by 4, 3, or 2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行时，会按照自上至下的顺序执行每一个分支判断，一旦成功，则跳出 if 语句块，最终本程序会匹配执行 else if n % 3 &#x3D;&#x3D; 0 的分支，输出 “number is divisible by 3”。<br>有一点要注意，就算有多个分支能匹配，也只有第一个匹配的分支会被执行！<br>如果代码中有大量的 else if 会让代码变得极其丑陋，不过不用担心，下一章的 match 专门用以解决多分支模式匹配的问题。</p>
<h1 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h1><p>循环无处不在，上到数钱，下到数年，你能想象的很多场景都存在循环，因此它也是流程控制中最重要的组成部分之一。</p>
<p>在 Rust 语言中有三种循环方式：for、while 和 loop，其中 for 循环是 Rust 循环王冠上的明珠。</p>
<h1 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h1><h2 id="for-循环是-Rust-的大杀器："><a href="#for-循环是-Rust-的大杀器：" class="headerlink" title="for 循环是 Rust 的大杀器："></a>for 循环是 Rust 的大杀器：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    for i in 1..=5 &#123;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码循环输出一个从 1 到 5 的序列，简单粗暴，核心就在于 for 和 in 的联动，语义表达如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for 元素 in 集合 &#123;</span><br><span class="line">  // 使用元素干一些你懂我不懂的事情</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个语法跟 JavaScript 还蛮像，应该挺好理解。</p>
<p>注意，使用 for 时我们往往使用集合的引用形式，除非你不想在后面的代码中继续使用该集合（比如我们这里使用了 container 的引用）。如果不使用引用的话，所有权会被转移（move）到 for 语句块中，后面就无法再使用这个集合了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for item in &amp;container &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
    <tr>
        <td bgcolor=#F0F8FF>对于实现了 copy 特征的数组(例如 [i32; 10] )而言， for item in arr 并不会把 arr 的所有权转移，而是直接对其进行了拷贝，因此循环之后仍然可以使用 arr 。
        </td>
    </tr>
</table>
如果想在循环中，修改该元素，可以使用 mut 关键字：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for item in &amp;mut collection &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">使用方法</th>
<th align="center">等价使用方式</th>
<th align="right">所有权</th>
</tr>
</thead>
<tbody><tr>
<td align="left">for item in collection</td>
<td align="center">for item in IntoIterator::into_iter(collection)</td>
<td align="right">转移所有权</td>
</tr>
<tr>
<td align="left">for item in &amp;collection</td>
<td align="center">for item in collection.iter()</td>
<td align="right">不可变借用</td>
</tr>
<tr>
<td align="left">for item in &amp;mut collection</td>
<td align="center">for item in collection.iter_mut()</td>
<td align="right">可变借用</td>
</tr>
</tbody></table>
<style>
  table {
    font-size: 12px;
  }
</style>
<p>如果想在循环中获取元素的索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a = [4, 3, 2, 1];</span><br><span class="line">    // `.iter()` 方法把 `a` 数组变成一个迭代器</span><br><span class="line">    for (i, v) in a.iter().enumerate() &#123;</span><br><span class="line">        println!(&quot;第&#123;&#125;个元素是&#123;&#125;&quot;, i + 1, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有同学可能会想到，如果我们想用 for 循环控制某个过程执行 10 次，但是又不想单独声明一个变量来控制这个流程，该怎么写？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//有点类似lua的写法</span><br><span class="line">for _ in 0..10 &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以用 _ 来替代 i 用于 for 循环中，在 Rust 中 _ 的含义是忽略该值或者类型的意思，如果不使用 _，那么编译器会给你一个 变量未使用的 的警告。</p>
<h2 id="两种循环方式优劣对比"><a href="#两种循环方式优劣对比" class="headerlink" title="两种循环方式优劣对比"></a>两种循环方式优劣对比</h2><p>以下代码，使用了两种循环方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 第一种</span><br><span class="line">let collection = [1, 2, 3, 4, 5];</span><br><span class="line">for i in 0..collection.len() &#123;</span><br><span class="line">  let item = collection[i];</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第二种</span><br><span class="line">for item in collection &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一种方式是循环索引，然后通过索引下标去访问集合，第二种方式是直接循环集合中的元素，优劣如下：</p>
<ul>
<li>性能：第一种使用方式中 collection[index] 的索引访问，会因为边界检查(Bounds Checking)导致运行时的性能损耗 —— Rust 会检查并确认 index 是否落在集合内，但是第二种直接迭代的方式就不会触发这种检查，因为编译器会在编译时就完成分析并证明这种访问是合法的</li>
<li>安全：第一种方式里对 collection 的索引访问是非连续的，存在一定可能性在两次访问之间，collection 发生了变化，导致脏数据产生。而第二种直接迭代的方式是连续访问，因此不存在这种风险( 由于所有权限制，在访问过程中，数据并不会发生变化)。<br>由于 for 循环无需任何条件限制，也不需要通过索引来访问，因此是最安全也是最常用的，通过与下面的 while 的对比，我们能看到为什么 for 会更加安全。</li>
</ul>
<h1 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h1><p>使用 continue 可以跳过当前当次的循环，开始下次的循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i in 1..4 &#123;</span><br><span class="line">    if i == 2 &#123;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码对 1 到 3 的序列进行迭代，且跳过值为 2 时的循环，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h1 id="break"><a href="#break" class="headerlink" title="break"></a>break</h1><p>使用 break 可以直接跳出当前整个循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i in 1..4 &#123;</span><br><span class="line">    if i == 2 &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码对 1 到 3 的序列进行迭代，在遇到值为 2 时的跳出整个循环，后面的循环不再执行，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<h1 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h1><p>如果你需要一个条件来循环，当该条件为 true 时，继续循环，条件为 false，跳出循环，那么 while 就非常适用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut n = 0;</span><br><span class="line"></span><br><span class="line">    while n &lt;= 5  &#123;</span><br><span class="line">        println!(&quot;&#123;&#125;!&quot;, n);</span><br><span class="line"></span><br><span class="line">        n = n + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;我出来了！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该 while 循环，只有当 n 小于等于 5 时，才执行，否则就立刻跳出循环，因此在上述代码中，它会先从 0 开始，满足条件，进行循环，然后是 1，满足条件，进行循环，最终到 6 的时候，大于 5，不满足条件，跳出 while 循环，执行 我出来了 的打印，然后程序结束：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0!</span><br><span class="line">1!</span><br><span class="line">2!</span><br><span class="line">3!</span><br><span class="line">4!</span><br><span class="line">5!</span><br><span class="line">我出来了！</span><br></pre></td></tr></table></figure>
<p>当然，你也可以用其它方式组合实现，例如 loop（无条件循环，将在下面介绍） + if + break：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut n = 0;</span><br><span class="line"></span><br><span class="line">    loop &#123;</span><br><span class="line">        if n &gt; 5 &#123;</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;, n);</span><br><span class="line">        n+=1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;我出来了！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，在这种循环场景下，while 要简洁的多。</p>
<h1 id="while-vs-for"><a href="#while-vs-for" class="headerlink" title="while vs for"></a>while vs for</h1><p>我们也能用 while 来实现 for 的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a = [10, 20, 30, 40, 50];</span><br><span class="line">    let mut index = 0;</span><br><span class="line"></span><br><span class="line">    while index &lt; 5 &#123;</span><br><span class="line">        println!(&quot;the value is: &#123;&#125;&quot;, a[index]);</span><br><span class="line"></span><br><span class="line">        index = index + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，代码对数组中的元素进行计数。它从索引 0 开始，并接着循环直到遇到数组的最后一个索引（这时，index &lt; 5 不再为真）。运行这段代码会打印出数组中的每一个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">the value is: 10</span><br><span class="line">the value is: 20</span><br><span class="line">the value is: 30</span><br><span class="line">the value is: 40</span><br><span class="line">the value is: 50</span><br></pre></td></tr></table></figure>
<p>数组中的所有五个元素都如期被打印出来。尽管 index 在某一时刻会到达值 5，不过循环在其尝试从数组获取第六个值（会越界）之前就停止了。</p>
<p>但这个过程很容易出错；如果索引长度不正确会导致程序 panic。这也使程序更慢，因为编译器增加了运行时代码来对每次循环的每个元素进行条件检查。</p>
<p>for循环代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a = [10, 20, 30, 40, 50];</span><br><span class="line"></span><br><span class="line">    for element in a.iter() &#123;</span><br><span class="line">        println!(&quot;the value is: &#123;&#125;&quot;, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，for 并不会使用索引去访问数组，因此更安全也更简洁，同时避免 运行时的边界检查，性能更高。</p>
<h1 id="loop-循环"><a href="#loop-循环" class="headerlink" title="loop 循环"></a>loop 循环</h1><p>对于循环而言，loop 循环毋庸置疑，是适用面最高的，它可以适用于所有循环场景（虽然能用，但是在很多场景下， for 和 while 才是最优选择），因为 loop 就是一个简单的无限循环，你可以在内部实现逻辑通过 break 关键字来控制循环何时结束。</p>
<p>使用 loop 循环一定要打起精神，否则你会写出下面的跑满你一个 CPU 核心的疯子代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    loop &#123;</span><br><span class="line">        println!(&quot;again!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该循环会不停的在终端打印输出，直到你使用 Ctrl-C 结束程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">again!</span><br><span class="line">again!</span><br><span class="line">again!</span><br><span class="line">again!</span><br><span class="line">^Cagain!</span><br></pre></td></tr></table></figure>
<p>注意，不要轻易尝试上述代码，如果你电脑配置不行，可能会死机！！！</p>
<p>因此，当使用 loop 时，必不可少的伙伴是 break 关键字，它能让循环在满足某个条件时跳出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut counter = 0;</span><br><span class="line"></span><br><span class="line">    let result = loop &#123;</span><br><span class="line">        counter += 1;</span><br><span class="line"></span><br><span class="line">        if counter == 10 &#123;</span><br><span class="line">            break counter * 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;The result is &#123;&#125;&quot;, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码当 counter 递增到 10 时，就会通过 break 返回一个 counter * 2 的值，最后赋给 result 并打印出来。</p>
<p>这里有几点值得注意：</p>
<ul>
<li>break 可以单独使用，也可以带一个返回值，有些类似 return</li>
<li>loop 是一个表达式，因此可以返回一个值</li>
</ul>
<h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 填空</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let n = 5;</span><br><span class="line"></span><br><span class="line">    if n &lt; 0 &#123;</span><br><span class="line">        println!(&quot;&#123;&#125; is negative&quot;, n);</span><br><span class="line">    &#125; else if n &gt; 0 &#123;</span><br><span class="line">        println!(&quot;&#123;&#125; is positive&quot;, n);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        println!(&quot;&#123;&#125; is zero&quot;, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 修复错误</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let n = 5;</span><br><span class="line"></span><br><span class="line">    let big_n =  </span><br><span class="line">    if n &lt; 10 &amp;&amp; n &gt; -10 &#123;</span><br><span class="line">        println!(&quot; 数字太小，先增加 10 倍再说&quot;);</span><br><span class="line"></span><br><span class="line">         10 * n</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        println!(&quot;数字太大，我们得让它减半&quot;);</span><br><span class="line"></span><br><span class="line">        n / 2 </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125; -&gt; &#123;&#125;&quot;, n, big_n);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    for n in 1..=99 &#123; // 修改此行，让代码工作</span><br><span class="line">        if n == 100 &#123;</span><br><span class="line">            panic!(&quot;NEVER LET THIS RUN&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">//</span><br><span class="line">//fn main() &#123;</span><br><span class="line">    //for n in 1..99 &#123; // 修改此行，让代码工作</span><br><span class="line">        //if n == 100 &#123;</span><br><span class="line">            //panic!(&quot;NEVER LET THIS RUN&quot;)</span><br><span class="line">        //&#125;</span><br><span class="line">    //&#125;</span><br><span class="line">//&#125; </span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 修复错误，不要新增或删除代码行</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let names = [String::from(&quot;liming&quot;),String::from(&quot;hanmeimei&quot;)];</span><br><span class="line">    for name in &amp;names &#123;</span><br><span class="line">        // do something with name...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, names);</span><br><span class="line"></span><br><span class="line">    let numbers = [1, 2, 3];</span><br><span class="line">    // numbers中的元素实现了 Copy，因此无需转移所有权</span><br><span class="line">    for n in numbers &#123;</span><br><span class="line">        // do something with name...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, numbers);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a = [4,3,2,1];</span><br><span class="line"></span><br><span class="line">    // 通过索引和值的方式迭代数组 `a` </span><br><span class="line">    for (i,v) in a.iter().enumerate() &#123;</span><br><span class="line">        println!(&quot;第&#123;&#125;个元素是&#123;&#125;&quot;,i+1,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 填空，让最后一行的  println! 工作 !</span><br><span class="line">fn main() &#123;</span><br><span class="line">    // 一个计数值</span><br><span class="line">    let mut n = 1;</span><br><span class="line"></span><br><span class="line">    // 当条件为真时，不停的循环</span><br><span class="line">    while n &lt; 10 &#123;</span><br><span class="line">        if n % 15 == 0 &#123;</span><br><span class="line">            println!(&quot;fizzbuzz&quot;);</span><br><span class="line">        &#125; else if n % 3 == 0 &#123;</span><br><span class="line">            println!(&quot;fizz&quot;);</span><br><span class="line">        &#125; else if n % 5 == 0 &#123;</span><br><span class="line">            println!(&quot;buzz&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            println!(&quot;&#123;&#125;&quot;, n);</span><br><span class="line">        &#125;</span><br><span class="line">        n = n + 1;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;n 的值是 &#123;&#125;, 循环结束&quot;,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li><p>🌟 使用 break 可以跳出循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 填空，不要修改其它代码</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut n = 0;</span><br><span class="line">    for i in 0..=100 &#123;</span><br><span class="line">       if n == 66 &#123;</span><br><span class="line">           break;</span><br><span class="line">       &#125;</span><br><span class="line">       n += 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert_eq!(n, 66);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>🌟🌟 continue 会结束当次循环并立即开始下一次循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 填空，不要修改其它代码</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut n = 0;</span><br><span class="line">    for i in 0..=100 &#123;</span><br><span class="line">       if n != 66 &#123;</span><br><span class="line">           n+=1;</span><br><span class="line">           continue;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert_eq!(n, 66);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>🌟🌟 loop 一般都需要配合 break 或 continue 一起使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 填空，不要修改其它代码</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut count = 0u32;</span><br><span class="line"></span><br><span class="line">    println!(&quot;Let&#x27;s count until infinity!&quot;);</span><br><span class="line"></span><br><span class="line">    // 无限循环</span><br><span class="line">    loop &#123;</span><br><span class="line">        count += 1;</span><br><span class="line"></span><br><span class="line">        if count == 3 &#123;</span><br><span class="line">            println!(&quot;three&quot;);</span><br><span class="line"></span><br><span class="line">            // 跳过当此循环的剩余代码</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println!(&quot;&#123;&#125;&quot;, count);</span><br><span class="line"></span><br><span class="line">        if count == 5 &#123;</span><br><span class="line">            println!(&quot;OK, that&#x27;s enough&quot;);</span><br><span class="line"></span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert_eq!(count, 5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>🌟🌟 loop 是一个表达式，因此我们可以配合 break 来返回一个值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 填空</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut counter = 0;</span><br><span class="line"></span><br><span class="line">    let result = loop &#123;</span><br><span class="line">        counter += 1;</span><br><span class="line"></span><br><span class="line">        if counter == 10 &#123;</span><br><span class="line">            break counter + 10</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    assert_eq!(result, 20);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>🌟🌟🌟 当有多层循环时，你可以使用 continue 或 break 来控制外层的循环。要实现这一点，外部的循环必须拥有一个标签 ‘label, 然后在 break 或 continue 时指定该标签</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 填空</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut count = 0;</span><br><span class="line">    &#x27;outer: loop &#123;</span><br><span class="line">        &#x27;inner1: loop &#123;</span><br><span class="line">            if count &gt;= 20 &#123;</span><br><span class="line">                // 这只会跳出 inner1 循环</span><br><span class="line">                break &#x27;inner1; // 这里使用 `break` 也是一样的</span><br><span class="line">            &#125;</span><br><span class="line">            count += 2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count += 5;</span><br><span class="line"></span><br><span class="line">        &#x27;inner2: loop &#123;</span><br><span class="line">            if count &gt;= 30 &#123;</span><br><span class="line">                break &#x27;outer;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            continue &#x27;outer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert!(count == 30)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/13/learnRust3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Byte的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/13/learnRust3/" itemprop="url">Rust入门-基础 第三节 Rust - 函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-08-13T23:49:28+08:00">
                2024-08-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="函数组成"><a href="#函数组成" class="headerlink" title="函数组成"></a>函数组成</h1><ul>
<li>声朗函数的关键字 fn</li>
<li>函数名 add()</li>
<li>参数i和j和参数类型 i32</li>
<li>返同值类型 i32</li>
<li>函数体i+j</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn add(i:i32,j:i32)-&gt; i32 &#123;</span><br><span class="line">    i + j</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let a = 1;</span><br><span class="line">    let b = 2;</span><br><span class="line">    let c = add(2, b);</span><br><span class="line">    printin!(&quot;&#123;&#125;&quot;,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数如此简单，但是又是如此的五脏俱全，声明函数的关键字 fn ,函数名 add()，参数 i 和 j，参数类型和返回值类型都是 i32，总之一切那么的普通，但是又那么的自信，直到你看到了下面这张图：<br><img src="/../images/function.png"><br>当你看懂了这张图，其实就等于差不多完成了函数章节的学习，但是这么短的章节显然对不起读者老爷们的厚爱，所以我们来展开下。</p>
<h1 id="函数要点"><a href="#函数要点" class="headerlink" title="函数要点"></a>函数要点</h1><ul>
<li>开头是字符，后面是数字，下划线，字母</li>
<li>开头是下划线，后面是数字，下划线，字母，不能仅有下划线</li>
<li>通数名和变量名使用蛇形命名法(snakecase)，例如fn add_two() &#x3D;&gt; {}</li>
</ul>
<h1 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h1><p>Rust 是强类型语言，因此需要你为每一个的数参数都标识出它的具体类型<br>注意:是每一个⚠️</p>
<h1 id="函数返回"><a href="#函数返回" class="headerlink" title="函数返回"></a>函数返回</h1><p>函数的返日值裁是函数体最后一条表达式的返回值，也可以使用return 提前返回想要完全理解这句话需要掌握**语句(statement)和表达式(expression)””的概念初学者裁记住函数的两种形态就行了</p>
<ul>
<li>return + 分号</li>
<li>没有return + 没有分号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn add(i:i32, j:i32)-&gt; i32 &#123;</span><br><span class="line">    i + j</span><br><span class="line">&#125;</span><br><span class="line">fn add(i:i32, j:i32)-&gt; i32 &#123;</span><br><span class="line">    return i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Rust-中的特殊返回类型"><a href="#Rust-中的特殊返回类型" class="headerlink" title="Rust 中的特殊返回类型"></a>Rust 中的特殊返回类型</h1><h2 id="无返回值"><a href="#无返回值" class="headerlink" title="无返回值()"></a>无返回值()</h2><p>如果一个的数没有返回值，那么就返回()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn print(i: i32)&#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, i);</span><br><span class="line">&#125;</span><br><span class="line">fn print(i:i32) -&gt;() &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 Rust 新手来说，有些返回类型很难理解，而且如果你想通过百度或者谷歌去搜索，都不好查询，因为这些符号太常见了，根本难以精确搜索到。</p>
<p>例如单元类型 ()，是一个零长度的元组。它没啥作用，但是可以用来表达一个函数没有返回值：</p>
<p>函数没有返回值，那么返回一个 ()<br>通过 ; 结尾的语句返回一个 ()<br>例如下面的 report 函数会隐式返回一个 ()：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use std::fmt::Debug;</span><br><span class="line"></span><br><span class="line">fn report&lt;T: Debug&gt;(item: T) &#123;</span><br><span class="line">  println!(&quot;&#123;:?&#125;&quot;, item);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与上面的函数返回值相同，但是下面的函数显式的返回了 ()：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn clear(text: &amp;mut String) -&gt; () &#123;</span><br><span class="line">  *text = String::from(&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际编程中，你会经常在错误提示中看到该 () 的身影出没，假如你的函数需要返回一个 u32 值，但是如果你不幸的以 表达式; 的语句形式作为函数的最后一行代码，就会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn add(x:u32,y:u32) -&gt; u32 &#123;</span><br><span class="line">    x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error[E0308]: mismatched types // 类型不匹配</span><br><span class="line"> --&gt; src/main.rs:6:24</span><br><span class="line">  |</span><br><span class="line">6 | fn add(x:u32,y:u32) -&gt; u32 &#123;</span><br><span class="line">  |    ---                 ^^^ expected `u32`, found `()` // 期望返回u32,却返回()</span><br><span class="line">  |    |</span><br><span class="line">  |    implicitly returns `()` as its body has no tail or `return` expression</span><br><span class="line">7 |     x + y;</span><br><span class="line">  |          - help: consider removing this semicolon</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>还记得我们在语句与表达式中讲过的吗？只有表达式能返回值，而 ; 结尾的是语句，在 Rust 中，一定要严格区分表达式和语句的区别，这个在其它语言中往往是被忽视的点。</p>
<h1 id="永不返回的发散函数"><a href="#永不返回的发散函数" class="headerlink" title="永不返回的发散函数 !"></a>永不返回的发散函数 !</h1><p>当用 ! 作函数返回类型的时候，表示该函数永不返回( diverge function )，特别的，这种语法往往用做会导致程序崩溃的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn dead_end() -&gt; ! &#123;</span><br><span class="line">  panic!(&quot;你已经到了穷途末路，崩溃吧！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的函数创建了一个无限循环，该循环永不跳出，因此函数也永不返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn forever() -&gt; ! &#123;</span><br><span class="line">  loop &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // 不要修改下面两行代码!</span><br><span class="line">    let (x, y) = (1, 2);</span><br><span class="line">    let s = sum(x, y);</span><br><span class="line">    print(s);</span><br><span class="line">    assert_eq!(s, 3);</span><br><span class="line">&#125;</span><br><span class="line">fn print(i: i32)&#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, i);</span><br><span class="line">&#125;</span><br><span class="line">fn sum(x:i32, y: i32) -&gt; i32 &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    print();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> // 使用另一个类型来替代 i32</span><br><span class="line"> fn print() -&gt; () &#123;</span><br><span class="line">    println!(&quot;hello,world&quot;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    never_return();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn never_return() -&gt; ! &#123;</span><br><span class="line">    // 实现这个函数，不要修改函数签名!</span><br><span class="line">    // panic!(&quot;error&quot;);</span><br><span class="line">    loop &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    get_option(1);</span><br><span class="line">    println!(&quot;Success!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn get_option(tp: u8) -&gt; Option&lt;i32&gt; &#123;</span><br><span class="line">    match tp &#123;</span><br><span class="line">        1 =&gt; &#123;</span><br><span class="line">            // TODO</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            // TODO</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    // 这里与其返回一个 None，不如使用发散函数替代</span><br><span class="line">    never_return_fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用三种方法实现以下发散函数</span><br><span class="line">fn never_return_fn() -&gt; ! &#123;</span><br><span class="line">    // panic!(&quot;error&quot;);</span><br><span class="line">    //todo!()</span><br><span class="line">    loop &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // 填空</span><br><span class="line">    let b: bool = false;</span><br><span class="line"></span><br><span class="line">    let _v: i32 = match b &#123;</span><br><span class="line">        true =&gt; 1,</span><br><span class="line">        // 发散函数也可以用于 `match` 表达式，用于替代任何类型的值</span><br><span class="line">        false =&gt; &#123;</span><br><span class="line">            println!(&quot;Success!&quot;);</span><br><span class="line">            panic!(&quot;we have no value for `false`, but we can panic&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;Exercise Failed if printing out this line!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/07/learnRust2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Byte的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/07/learnRust2/" itemprop="url">Rust入门-基础 第二节 Rust变量和可变性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-08-07T22:54:03+08:00">
                2024-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="可变变量和不可变变量-Mutable和Immutable"><a href="#可变变量和不可变变量-Mutable和Immutable" class="headerlink" title="可变变量和不可变变量(Mutable和Immutable)"></a>可变变量和不可变变量(Mutable和Immutable)</h1><p>Rust的变量默认是不可改变的(immutable),如果我们想改变变量的值,就需要声明可变变量(mutable)</p>
<h2 id="声明不可变变量"><a href="#声明不可变变量" class="headerlink" title="声明不可变变量"></a>声明不可变变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let x=5;</span><br><span class="line">println!(&#x27;The value of x is:&#123;&#125;&quot;,x);</span><br></pre></td></tr></table></figure>
<h2 id="声明可变变量"><a href="#声明可变变量" class="headerlink" title="声明可变变量"></a>声明可变变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let mut x=5;</span><br><span class="line">println!(&quot;The value of xis:&#123;&#125;&quot;,x);</span><br><span class="line">X = 6;</span><br><span class="line">printin!(&quot;The value of x is: &#123;&#125;&quot;,x);</span><br></pre></td></tr></table></figure>
<h1 id="常量（Constants）"><a href="#常量（Constants）" class="headerlink" title="常量（Constants）"></a>常量（Constants）</h1><p>使用const关键字来定义一个常量。定义常量时需要明确的指定常量的数据类型。</p>
<h2 id="关于常量，需要注意以下几点"><a href="#关于常量，需要注意以下几点" class="headerlink" title="关于常量，需要注意以下几点"></a>关于常量，需要注意以下几点</h2><ul>
<li>必须显示指定数据类型</li>
<li>常量名一般使用大写字母，否则编译器会报 Warning。</li>
<li>必须使用常量表达式进行赋值，即必须是编译期能计算出的值。</li>
<li>常量不支持重定义(遮蔽)，这和变量是不同的。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 常量声明</span><br><span class="line">const NUM: i32 = 5;</span><br><span class="line">println!(&quot;constants values is &#123;&#125;&quot;, NUM);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="不可变变量和常量的区别？"><a href="#不可变变量和常量的区别？" class="headerlink" title="不可变变量和常量的区别？"></a>不可变变量和常量的区别？</h2><ul>
<li>关键字：常量使用const声明，不可变变量使用let</li>
<li>赋值时机：常量在编译期就确定了值，无法再运行时改变。不可变变量直到运行期才能确定下来</li>
<li>能否改变：常量不可以修改，不可变变量可以通过shadowing来修改</li>
<li>声明：常量必须声明类型，不可变变量不需要</li>
<li>命名：常量必须使用大写字母，不可变变量不需要</li>
</ul>
<h1 id="静态变量（Static）"><a href="#静态变量（Static）" class="headerlink" title="静态变量（Static）"></a>静态变量（Static）</h1><p>使用static关键字声明，并在编译时分配内存，且在程序运行期间一直存在；</p>
<p>静态变量可以在整个程序中共享，且可以再多个线程间共享；</p>
<p>静态变量的值在运行期间不会改变，因此它们通常用于存储程序的全局状态。</p>
<h2 id="静态变量与常量的相似之处"><a href="#静态变量与常量的相似之处" class="headerlink" title="静态变量与常量的相似之处"></a>静态变量与常量的相似之处</h2><ul>
<li>定义方式类型，一个使用 static，一个使用const;</li>
<li>名称都要求使用大写，否则会报 Warning;</li>
<li>都必须明确指定类型;</li>
<li>两者都要求必须使用常量表达式进行赋值，即必须是编译期能计算出的值;</li>
<li>两者都不支持重定义(遮蔽)，这和变量是不同的。</li>
</ul>
<h2 id="静态变量和常量区别"><a href="#静态变量和常量区别" class="headerlink" title="静态变量和常量区别"></a>静态变量和常量区别</h2><ul>
<li>常量在编译时被内联，但静态变量不会。在整个程序中静态变量只有一个实例，也就是说所有引用都指向同一个地址 。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 常量的内联</span><br><span class="line">const A: i32 = 1;</span><br><span class="line">static B: i32 = 2;</span><br><span class="line">fn main () &#123;</span><br><span class="line">	println!&#123;&quot;const value = &#123;&#125;&quot;, A&#125;;</span><br><span class="line">	//在编译期间，常量的访问会被替换成常量的值（内联）</span><br><span class="line">	//所以上面的代码会被编译成：println!&#123;&quot;const value = &#123;&#125;&quot;, 1&#125;;</span><br><span class="line">  </span><br><span class="line">  // 但是静态变量的访问指向的是这个变量所对应的内存地址</span><br><span class="line">  println!&#123;&quot;static value = &#123;&#125;&quot;, B&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>常量不可变，而静态变量和普通变量一样，默认不可变但可以通过 mut 关键字定义为可变。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个可变的静态变量</span><br><span class="line">static mut NUM: i32 = 30;</span><br><span class="line"></span><br><span class="line">// 静态变量是全局的，多线程共享的。对它的值的修改不是线程安全的，需要把这段代码放入unsafe代码块中执行。否则编译期间会报错。这里只是举例</span><br><span class="line">unsafe &#123;</span><br><span class="line">	NUM += 1;</span><br><span class="line">	println!(&quot;the static value is &#123;&#125;&quot;, NUM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="作用域和遮蔽-variableshadowing"><a href="#作用域和遮蔽-variableshadowing" class="headerlink" title="作用域和遮蔽(variableshadowing)"></a>作用域和遮蔽(variableshadowing)</h1><p>变量绑定有一个作用域(scope)，它被限定只在一个代码块(block)中生存(live)。代码块是一个被{}包围的语句集合。另外也允许变量遮蔽(variable shadowing)。</p>
<p>通过对不可变变量的重新声明的方式，可以完成对不可变变量值的遮蔽</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个不可变变量</span><br><span class="line">let short_live_binding: i32 = 2;</span><br><span class="line">println!(&quot;before shadowing -- short variable : &#123;&#125;&quot;, short_live_binding);</span><br><span class="line"></span><br><span class="line">// 遮蔽, 对同一个不可变变量的变量名重新声明赋值</span><br><span class="line">let short_live_binding: i32 = 5;</span><br><span class="line">println!(&quot;after shadowing -- short variable : &#123;&#125;&quot;, short_live_binding);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before shadowing -- short variable : 2</span><br><span class="line">after shadowing -- short variable : 5</span><br></pre></td></tr></table></figure>
<p>遮蔽一个比当前作用域声明周期更长的变量的时候，遮蔽的作用范围只在当前的作用域内，超出作用域的变量的值还是遮蔽之前的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let global_value: i32 = 1;</span><br><span class="line">// 声明一个代码块</span><br><span class="line">&#123;</span><br><span class="line">	let global_value: i32 = 2;</span><br><span class="line">	// 完成遮蔽</span><br><span class="line">	println!(&quot;in block value is &#123;&#125;&quot;,global_value);</span><br><span class="line">&#125;</span><br><span class="line">// 在遮蔽的作用域外</span><br><span class="line">println!(&quot;global value is &#123;&#125;&quot;, global_value)</span><br></pre></td></tr></table></figure>
<h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in block value is 2</span><br><span class="line">global value is 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/31/learnRust1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Byte的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/07/31/learnRust1/" itemprop="url">Rust入门-基础 第一节 环境搭建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-07-31T23:12:06+08:00">
                2024-07-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-Rust介绍"><a href="#1-Rust介绍" class="headerlink" title="1.Rust介绍"></a>1.Rust介绍</h1><p>Rust是由Mozilla主导开发的通用、编译型编程语言。设计准则为”安全、并发、实用”，支持函数式、并发式、过程式以及面向对象的编程风格。–维基百科</p>
<h2 id="1-1-内存安全"><a href="#1-1-内存安全" class="headerlink" title="1.1 内存安全"></a>1.1 内存安全</h2><p>为了提供内存安全，它的设计不允许空指针和悬空指针。指针只能透过固定的初始化形态来建构，而所有这些形态都要求它们的输入已经分析过了。Rust有一个检查指针生命期间和指针冻结的系统，可以用来预防在C++中许多的类型错误，甚至是用了智能指针功能之后会发生的类型错误。</p>
<h2 id="1-2-基本类型"><a href="#1-2-基本类型" class="headerlink" title="1.2 基本类型"></a>1.2 基本类型</h2><p>当一门语言不谈类型时，你得小心，这大概率是动态语言(别拍我，我承认是废话)。但是把类型大张旗鼓的用多个章节去讲的，Rust 是其中之一。</p>
<p>Rust 每个值都有其确切的数据类型，总的来说可以分为两类：基本类型和复合类型。 基本类型意味着它们往往是一个最小化原子类型，无法解构为其它类型(一般意义上来说)，由以下组成：</p>
<ul>
<li>数值类型: 有符号整数 (i8, i16, i32, i64, isize)、 无符号整数 (u8, u16, u32, u64, usize) 、浮点数 (f32, f64)、以及有理数、复数</li>
<li>字符串：字符串字面量和字符串切片 &amp;str</li>
<li>布尔类型： true和false</li>
<li>字符类型: 表示单个 Unicode 字符，存储为 4 个字节</li>
<li>单元类型: 即 () ，其唯一的值也是 ()</li>
</ul>
<h2 id="1-3-静态类型"><a href="#1-3-静态类型" class="headerlink" title="1.3 静态类型"></a>1.3 静态类型</h2><p>与 Python、JavaScript 等动态语言不同，Rust 是一门静态类型语言，也就是编译器必须在编译期知道我们所有变量的类型，但这不意味着你需要为每个变量指定类型，因为 Rust 编译器很聪明，它可以根据变量的值和上下文中的使用方式来自动推导出变量的类型，同时编译器也不够聪明，在某些情况下，它无法推导出变量类型，需要手动去给予一个类型标注。</p>
<h2 id="1-4-并发编程"><a href="#1-4-并发编程" class="headerlink" title="1.4 并发编程"></a>1.4 并发编程</h2><p>Rust提供了强大的并发编程支持，使得开发者能够编写高效的多线程程序。通过其所有权系统和并发原语，Rust能够确保并发安全，并避免数据竞争和其他并发问题。</p>
<h1 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2.环境搭建"></a>2.环境搭建</h1><p>通过 rustup 下载 Rust，这是一个管理 Rust 版本和相关工具的命令行工具。下载时需要联网</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --proto &#x27;=https&#x27; --tlsv1.2 https://sh.rustup.rs -sSf | sh</span><br></pre></td></tr></table></figure>
<p>这个命令将下载一个脚本并开始安装 rustup 工具，此工具将安装 Rust 的最新稳定版本。可能会提示你输入管理员密码。</p>
<p>如果安装成功，将出现下面这行：</p>
<p>Rust is installed now. Great!<br>OK，这样就已经完成 Rust 安装啦。</p>
<h2 id="在-Windows-上安装-rustup"><a href="#在-Windows-上安装-rustup" class="headerlink" title="在 Windows 上安装 rustup"></a>在 Windows 上安装 rustup</h2><p>Windows 上安装 Rust 需要有 C++ 环境，以下为安装的两种方式：</p>
<h3 id="1-x86-64-pc-windows-msvc（官方推荐）"><a href="#1-x86-64-pc-windows-msvc（官方推荐）" class="headerlink" title="1. x86_64-pc-windows-msvc（官方推荐）"></a>1. x86_64-pc-windows-msvc（官方推荐）</h3><p>先安装 Microsoft C++ Build Tools，勾选安装 C++ 环境即可。安装时可自行修改缓存路径与安装路径，避免占用过多 C 盘空间。安装完成后，Rust 所需的 msvc 命令行程序需要手动添加到环境变量中，否则安装 Rust 时 rustup-init 会提示未安装 Microsoft C++ Build Tools，其位于：%Visual Studio 安装位置%\VC\Tools\MSVC%version%\bin\Hostx64\x64（请自行替换其中的 %Visual Studio 安装位置%、%version% 字段）下。</p>
<p>如果你不想这么做，可以选择安装 Microsoft C++ Build Tools 新增的“定制”终端 Developer Command Prompt for %Visual Studio version% 或 Developer PowerShell for %Visual Studio version%，在其中运行 rustup-init.exe。</p>
<p>准备好 C++ 环境后开始安装 Rust：<br>在 RUSTUP-INIT 下载系统相对应的 Rust 安装程序，一路默认即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Hehongyuan&gt; rustup-init.exe</span><br><span class="line">......</span><br><span class="line">Current installation options:</span><br><span class="line"></span><br><span class="line">default host triple: x86_64-pc-windows-msvc</span><br><span class="line">    default toolchain: stable (default)</span><br><span class="line">            profile: default</span><br><span class="line">modify PATH variable: yes</span><br><span class="line"></span><br><span class="line">1) Proceed with installation (default)</span><br><span class="line">2) Customize installation</span><br><span class="line">3) Cancel installation</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-x86-64-pc-windows-gnu"><a href="#2-x86-64-pc-windows-gnu" class="headerlink" title="2. x86_64-pc-windows-gnu"></a>2. x86_64-pc-windows-gnu</h3><p>相比于 MSVC 版本来说，GNU 版本具有更轻量，更靠近 Linux 的优势。</p>
<p>首先，根据 MSYS2 官网 配置 MSYS。</p>
<p>若您觉得下载太慢，可以试试由 Caviar-X 提供的 代理。</p>
<p>在安装 mingw-toolchain 后，请将 %MSYS 安装路径%\mingw64\bin 添加到系统变量 PATH 中。</p>
<p>配置好后，在 MSYS 中输入下面的命令来安装 rustup。</p>
<p>在 RUSTUP-INIT 下载系统相对应的 Rust 安装程序，一路默认即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    Current installation options:</span><br><span class="line"></span><br><span class="line">default host triple: x86_64-pc-windows-msvc</span><br><span class="line">    default toolchain: stable (default)</span><br><span class="line">            profile: default</span><br><span class="line">modify PATH variable: yes</span><br><span class="line"></span><br><span class="line">1) Proceed with installation (default)</span><br><span class="line">2) Customize installation</span><br><span class="line">3) Cancel installation</span><br><span class="line">&gt;2</span><br><span class="line"></span><br><span class="line">I&#x27;m going to ask you the value of each of these installation options.</span><br><span class="line">You may simply press the Enter key to leave unchanged.</span><br><span class="line"></span><br><span class="line">Default host triple? [x86_64-pc-windows-msvc]</span><br><span class="line">x86_64-pc-windows-gnu</span><br><span class="line"></span><br><span class="line">Default toolchain? (stable/beta/nightly/none) [stable]</span><br><span class="line">stable</span><br><span class="line"></span><br><span class="line">Profile (which tools and data to install)? (minimal/default/complete) [default]</span><br><span class="line">complete</span><br><span class="line"></span><br><span class="line">Modify PATH variable? (Y/n)</span><br><span class="line">Y</span><br><span class="line"></span><br><span class="line">Current installation options:</span><br><span class="line"></span><br><span class="line">default host triple: x86_64-pc-windows-gnu</span><br><span class="line">    default toolchain: stable</span><br><span class="line">            profile: complete</span><br><span class="line">modify PATH variable: yes</span><br><span class="line"></span><br><span class="line">1) Proceed with installation (default)</span><br><span class="line">2) Customize installation</span><br><span class="line">3) Cancel installation</span><br><span class="line">&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再之后，按下 1，等待。完成后，您就已经安装了 Rust 和 rustup。</p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>要更新 Rust，在终端执行以下命令即可更新：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rustup update</span><br></pre></td></tr></table></figure>
<ul>
<li>update:升级rust工具链和rustup本身</li>
<li>self uninstall: 卸载rust</li>
<li>doc:在浏览器中打开离线文档</li>
</ul>
<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>要卸载 Rust 和 rustup，在终端执行以下命令即可卸载：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rustup self uninstall</span><br></pre></td></tr></table></figure>
<h2 id="检查安装是否成功"><a href="#检查安装是否成功" class="headerlink" title="检查安装是否成功"></a>检查安装是否成功</h2><p>检查是否正确安装了 Rust，可打开终端并输入下面这行，此时能看到最新发布的稳定版本的版本号、提交哈希值和提交日期：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ rustc -V</span><br><span class="line">rustc 1.56.1 (59eed8a2a 2021-11-01)</span><br><span class="line"></span><br><span class="line">$ cargo -V</span><br><span class="line">cargo 1.57.0 (b2e52d7ca 2021-10-21)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注：若发现版本号不同，以您的版本号为准<br>恭喜，你已成功安装 Rust！</p>
<p>如果没看到此信息:</p>
<ol>
<li>如果你使用的是 Windows，请检查 Rust 或 %USERPROFILE%.cargo\bin 是否在 %PATH% 系统变量中。</li>
<li>如果你使用的是 Windows 下的 Linux 子系统，请关闭并重新打开终端，再次执行以上命令。</li>
</ol>
<h1 id="3-vscode配置"><a href="#3-vscode配置" class="headerlink" title="3 vscode配置"></a>3 vscode配置</h1><h2 id="推荐插件"><a href="#推荐插件" class="headerlink" title="推荐插件"></a>推荐插件</h2><ul>
<li>社区驱动的rust-analyzer其他几个rust语言插件虽然是官方的，但都不如这个好用。</li>
<li>even-better-toml支持.toml 文件完整特性</li>
<li>crates 显示 crate 的最新版本，以及显示所有能使用的crate版本</li>
</ul>
<h2 id="安装-VSCode-的-Rust-插件"><a href="#安装-VSCode-的-Rust-插件" class="headerlink" title="安装 VSCode 的 Rust 插件"></a>安装 VSCode 的 Rust 插件</h2><p>在 VSCode 的左侧扩展目录里，搜索 rust, 你能看到两个 Rust 插件，如果没有意外，这两个应该分别排名第一和第二：</p>
<p>官方的 Rust，作者是 The Rust Programming Language, 官方出品，牛逼就完了，但是……我们并不推荐（事实上已经不再维护了，官方收编了第二个插件，现在第二个插件的作者也是 The Rust Programming Language），这个插件有几个问题：<br>首先是在代码跳转上支持的很烂，只能在自己的代码库中跳转，一旦跳到别的三方库，那就无法继续跳转，对于查看标准库和三方库的源码带来了极大的困扰<br>其次，不支持类型自动标注，对于 Rust 语言而言，类型说明是非常重要的，特别是在你不知道给变量一个什么类型时，这种 IDE 的自动提示就变得弥足珍贵<br>代码提示不太好用，有些方法既不会提示，也不能跳转<br>社区驱动的 rust-analyzer，非常推荐，上面说的所有问题，在这个插件上都得到了解决，不得不说，Rust 社区 yyds!<br>所以，综上所述，我们选择 rust-analyzer 作为 Rust 语言的插件，具体的安装很简单，点击插件，选择安装即可，根据提示可能需要重新加载 IDE。</p>
<table>
    <tr>
        <td bgcolor=#F0F8FF>在搜索 VSCode 插件时，报错：提取扩展出错，XHR failed，这个报错是因为网络原因导致，很可能是你的网络不行或者翻墙工具阻拦你的访问，试着关掉翻墙，再进行尝试。</td>
    </tr>
</table>

<p>安装完成后，在第一次打开 Rust 项目时，需要安装一些依赖，具体的状态在左下角会进行提示，包括下载、代码构建、building 等。</p>
<p>当插件使用默认设置时，每一次保存代码，都会出进行一次重新编译。</p>
<table>
    <tr>
        <td bgcolor=#F0F8FF>如果你的电脑慢，有一点一定要注意：
在编译器构建代码的同时，不要在终端再运行 cargo run 等命令进行编译，不然会获得一个报错提示，大意是当前文件目录已经被锁定，等待其它使用者释放。如果等了很久 IDE 还是没有释放（虽然我没遇到过，但是存在这个可能性），你可以关掉 IDE，并手动 kill 掉 rust-analyzer，然后重新尝试。</td>
    </tr>
</table>

<h3 id="rust-analyzer"><a href="#rust-analyzer" class="headerlink" title="rust-analyzer"></a>rust-analyzer</h3><p><img src="/../images/rust-analyzer.png"></p>
<h3 id="even-better-toml"><a href="#even-better-toml" class="headerlink" title="even-better-toml"></a>even-better-toml</h3><p>支持.toml文件（项目配置文件，类似Gradle）完整特性<br><img src="/../images/even-better-toml.png"></p>
<h3 id="crates-io"><a href="#crates-io" class="headerlink" title="crates-io"></a>crates-io</h3><p>crates已经无法使用 可以使用crates-io代替<br><img src="/../images/crates-io.png"></p>
<h3 id="logo-error-lens-png"><a href="#logo-error-lens-png" class="headerlink" title="logo-error-lens.png"></a>logo-error-lens.png</h3><p>更好的获得错误展示<br><img src="/../images/logo-error-lens.png"></p>
<h3 id="One-Dark-Pro"><a href="#One-Dark-Pro" class="headerlink" title="One Dark Pro"></a>One Dark Pro</h3><p>非常好看的 VSCode 主题</p>
<h3 id="CodeLLDB"><a href="#CodeLLDB" class="headerlink" title="CodeLLDB"></a>CodeLLDB</h3><p>Debugger 程序</p>
<h1 id="3-Hello-World"><a href="#3-Hello-World" class="headerlink" title="3. Hello,World"></a>3. Hello,World</h1><p>既然安装好了 Rust，是时候来编写第一个 Rust 程序了</p>
<h2 id="编写rust代码"><a href="#编写rust代码" class="headerlink" title="编写rust代码"></a>编写rust代码</h2><p>首先创建一个存放 Rust 代码的目录。Rust 并不关心代码的存放位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir hello world</span><br><span class="line">cd hello world</span><br></pre></td></tr></table></figure>
<p>接下来，新建一个源文件，命名为 main.rs。Rust源文件总是以,s扩展名结尾。如果文件名包含多个单词，那么按照命名习惯，应当使用下划线来分隔单词。例如命名为 hello_world.rs，而不是 he&#x2F;loworld.rs。现在打开刚创建的 main.rs 文件，输入示例 1-1中的代码,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    println!(&quot;Hello, world!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main文件夹下存在.rs结尾的rust源文件；</p>
<p>target下存放build之后的可执行文件；</p>
<p>Cargo.toml则是项目的配置文件，里面描述了我们项目的名称，版本号，依赖包管理等等….非常像Android中的Gradle。；</p>
<p>Cargo_lock文件是cargo工具根据同一项目的toml文件生成的项目依赖详细清单，我们一般不用去编辑它，只需要关注Cargo.toml文件内容即可。</p>
<h1 id="4-认识-Cargo"><a href="#4-认识-Cargo" class="headerlink" title="4. 认识 Cargo"></a>4. 认识 Cargo</h1><p>但凡经历过 C&#x2F;C++ 或 Go 语言 1.10 版本之前的用户都知道，一个好的包管理工具有多么的重要！！我那个时候是如此的渴望类似 nodejs 的 npm 包管理工具，但是却求而不得。</p>
<p>包管理工具最重要的意义就是任何用户拿到你的代码，都能运行起来，而不会因为各种包版本依赖焦头烂额。</p>
<p>Go 语言在 1.10 版本之前，所有的包都是在 github.com 下存放，导致了所有的项目都公用一套依赖代码，在本地项目复杂后，这简直是一种灾难。</p>
<p>说多了都是泪，笔者目前还有一个早期 Go 的项目 (15 年写的），用到了 iris （一个坑爹 HTTP 服务），结果现在运行不起来了，因为找不到 iris 当时的那个版本了！！</p>
<p>作为一门现代化语言，Rust 吸收了多个语言的包管理优点，为大家提供超级大杀器： cargo，真的，再挑剔的开发者，都对它赞不绝口。👍</p>
<p>总而言之，cargo 提供了一系列的工具，从项目的建立、构建到测试、运行直至部署，为 Rust 项目的管理提供尽可能完整的手段。同时，与 Rust 语言及其编译器 rustc 紧密结合，可以说用了后就忘不掉，如同初恋般的感觉。</p>
<h2 id="创建一个”你好，世界”项目"><a href="#创建一个”你好，世界”项目" class="headerlink" title="创建一个”你好，世界”项目"></a>创建一个”你好，世界”项目</h2><p>又见”你好，世界”，肯定有读者在批评了：你就不能有点创意吗？”世界，你好”难道不配？你是读者，你说了算，那我们就来创建一个”世界，你好”。</p>
<p>上文提到，Rust 语言的包管理工具是 cargo。不过，我们无需再手动安装，之前安装 Rust 的时候，就已经一并安装了。</p>
<p>终于到了紧张刺激的 new new new 环节：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo new test_demo</span><br><span class="line">cd test_demo</span><br></pre></td></tr></table></figure>
<p>上面的命令使用 cargo new 创建一个项目，项目名是 world_hello （向读者势力低头的项目名称，泪奔），该项目的结构和配置文件都是由 cargo 生成，意味着我们的项目被 cargo 所管理。</p>
<table>
    <tr>
        <td bgcolor=#F0F8FF>如果你在终端无法使用这个命令，考虑一下 环境变量 是否正确的设置：把 cargo 可执行文件所在的目录添加到环境变量中。

<p>如果是在 Windows 的 WSL2 子系统下，出现以下错误：</p>
<p>error: command failed: ‘rustc’ error: caused by: Permission denied (os error 13)</p>
<p>可尝试先卸载，再使用sudo命令进行安装：$ sudo curl –proto ‘&#x3D;https’ –tlsv1.2 <a target="_blank" rel="noopener" href="https://sh.rustup.rs/">https://sh.rustup.rs</a> -sSf | sh<br>        </td><br>    </tr></p>
</table>
进入 world_hello 目录并列出文件
+ Cargo.toml/文件
+ src 目录
  + src 目录中的 main.rs 文件
  
<h2 id="文件名-Cargo-toml"><a href="#文件名-Cargo-toml" class="headerlink" title="文件名:Cargo.toml"></a>文件名:Cargo.toml</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[package]</span><br><span class="line">name = &quot;world_hello&quot;</span><br><span class="line">version = &quot;0.1.0&quot;</span><br><span class="line">edition = &quot;2021&quot;</span><br><span class="line"></span><br><span class="line">[dependencies]</span><br><span class="line">ferris-says = &quot;0.3.1&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>[package]</p>
<ul>
<li>项目的名称</li>
<li>项目的版本</li>
<li>使用的 RuSt 版本</li>
</ul>
<p>[dependencies]<br>罗列项目依赖，在 Rust中，代码包被称为 crates</p>
<h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><p>有两种方式可以运行项目：</p>
<p>cargo run</p>
<p>手动编译和运行项目</p>
<p>首先来看看第一种方式，一码胜似千言，在之前创建的 world_hello 目录下运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.09s</span><br><span class="line">     Running `target\debug\world_hello.exe`</span><br><span class="line"> __________________________ </span><br><span class="line">&lt; Hello fellow Rustaceans! &gt;</span><br><span class="line"> -------------------------- </span><br><span class="line">        \</span><br><span class="line">         \</span><br><span class="line">            _~^~^~_</span><br><span class="line">        \) /  o o  \ (/     </span><br><span class="line">          &#x27;_   -   _&#x27;       </span><br><span class="line">          / &#x27;-----&#x27; \</span><br></pre></td></tr></table></figure>

<p>好了，你已经看到程序的输出：”Hello, world”。</p>
<p>如果你安装的 Rust 的 host triple 是 x86_64-pc-windows-msvc 并确认 Rust 已经正确安装，但在终端上运行上述命令时，出现类似如下的错误摘要 linking with <code>link.exe</code> failed: exit code: 1181，请使用 Visual Studio Installer 安装 Windows SDK。</p>
<p>可能有读者不愿意了，说好了”世界，你好”呢？别急，在下一节，我们再对代码进行修改。（认真想来，”你好，世界“强调的是我对世界说你好，而”世界，你好“是世界对我说你好，明显是后者更有包容性和国际范儿，读者真·好眼光。）</p>
<p>上述代码，cargo run 首先对项目进行编译，然后再运行，因此它实际上等同于运行了两个指令，下面我们手动试一下编译和运行项目：</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>在运行 Rust 程序之前，必须先使用 Rust 编译器编译它，即输入 rustc 命令并传入源文件名称，如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustc main.rs</span><br></pre></td></tr></table></figure>
<p>编译成功后，Rust 会输出一个二进制的可执行文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LSmain main.rs</span><br></pre></td></tr></table></figure>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>Rust是一种 预编译静态类型(ahead-of-time compiled)语言，这意味着你可以编译程序，并将可执行文件送给其他人，他们甚至不需要安装 Rust 就可以运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main</span><br></pre></td></tr></table></figure>

<h2 id="发布构建"><a href="#发布构建" class="headerlink" title="发布构建"></a>发布构建</h2><p>当项目最终准备好发布时，可以使用cargobuild–release 来优化编译项目</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build -release</span><br></pre></td></tr></table></figure>
<p>这会在 target&#x2F;release 而不是 target&#x2F;debug 下生成可执行文件。这些优化可以让 Rust代码运行的更快，不过启用这些优化要消耗更长的编译时间。<br>这也就是为什么会有两种不同的配置:</p>
<ul>
<li>一种是为了开发，你需要经常快速重新构建;</li>
<li>另一种是为用户构建最终程序，它们不会经常重新构建，并且希望程序运行得越快越好</li>
</ul>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>我们添加一个随机数功能的库(crate)。crate是一个 Rust 代码库，库 crate 可以包含任意能被其他程序使用的代码，但是不能自执行<br>文件名:Cargo.toml<br>[dependencies]rand &#x3D;”0.8.5’<br>重新构建项目</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build</span><br></pre></td></tr></table></figure>
<p>当有了新依赖，Cargo 会从 Crates.io 获取依赖，并将指定的依赖版本写入Cargo.lock文件中</p>
<p>为什么需要Cargo.lock文件<br>确保任何人在任何时候重新构建代码，都会产生相同的结果:Cargo只会使用你指定的依赖版本</p>
<p>当你 确实 需要升级 crate 时，Cargo提供了这样一个命令，update，它会忽路 Carga.&#x2F;ock文件，并计算出所有符合 Cargo.tom声明的最新版本。Cargo接下来会把这些版本写入Carga.1ock文件。不过，Cargo默认只会寻找大于 0.8.5 而小于 0.9.0 的版本。如果rand crate发布了两个新版本，0.8.6和0.9.0，在运行 cargo update 时会出现如下内容:</p>
<table>
    <td bgcolor=#F0F8FF>$ cargo updateUpdating crates.io indexUpdating randv.8.5->v.8.6
    </td>
</table>

<p>Cargo 忽略了 0.9.0版本。这时，你也会注意到的 Carg.1ock文件中的变化无外乎现在使用的 rand crate版本是 0.8.6。如<br>果想要使用 0.9.0版本的rand 或是任何 0.9.x 系列的版本，必须像这样更新 Cargo.tom&#x2F;文件:</p>
<table>
    <td bgcolor=#F0F8FF>[dependencies]
rand = "0.9.0"
    </td>
</table>

<h2 id="cargo-check"><a href="#cargo-check" class="headerlink" title="cargo check"></a>cargo check</h2><p>当项目大了后，cargo run 和 cargo build 不可避免的会变慢，那么有没有更快的方式来验证代码的正确性呢？大杀器来了，接着！<br>cargo check 是我们在代码开发过程中最常用的命令，它的作用很简单：快速的检查一下代码能否编译通过。因此该命令速度会非常快，能节省大量的编译时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cargo check</span><br><span class="line">    Checking world_hello v0.1.0 (/Users/sunfei/development/rust/world_hello)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.06s</span><br></pre></td></tr></table></figure>
<p>Rust 虽然编译速度还行，但是还是不能与 Go 语言相提并论，因为 Rust 需要做很多复杂的编译优化和语言特性解析，甚至连如何优化编译速度都成了一门学问: 优化编译速度</p>
<p>Cargo.toml 和 Cargo.lock<br>Cargo.toml 和 Cargo.lock 是 cargo 的核心文件，它的所有活动均基于此二者。</p>
<p>Cargo.toml 是 cargo 特有的项目数据描述文件。它存储了项目的所有元配置信息，如果 Rust 开发者希望 Rust 项目能够按照期望的方式进行构建、测试和运行，那么，必须按照合理的方式构建 Cargo.toml。</p>
<p>Cargo.lock 文件是 cargo 工具根据同一项目的 toml 文件生成的项目依赖详细清单，因此我们一般不用修改它，只需要对着 Cargo.toml 文件撸就行了。</p>
<p>什么情况下该把 Cargo.lock 上传到 git 仓库里？很简单，当你的项目是一个可运行的程序时，就上传 Cargo.lock，如果是一个依赖库项目，那么请把它添加到 .gitignore 中。</p>
<p>现在用 VSCode 打开上面创建的”世界，你好”项目，然后进入根目录的 Cargo.toml 文件，可以看到该文件包含不少信息：<br>package 配置段落<br>package 中记录了项目的描述信息，典型的如下：</p>
<table>
    <td bgcolor=#F0F8FF>[package]
name = "world_hello"
version = "0.1.0"
edition = "2021"
    </td>
</table>

<p>name 字段定义了项目名称，version 字段定义当前版本，新项目默认是 0.1.0，edition 字段定义了我们使用的 Rust 大版本。因为本书很新（不仅仅是现在新，未来也将及时修订，跟得上 Rust 的小步伐），所以使用的是 Rust edition 2021 大版本，详情见 Rust 版本详解</p>
<h2 id="配置国内镜像"><a href="#配置国内镜像" class="headerlink" title="配置国内镜像"></a>配置国内镜像</h2><p>为了使用 crates.10之外的注册服务，我们需要对 $HOME&#x2F;.cargo&#x2F;conf1g.toml 文件进行配置，添加新的服务提供商cargo 1.68版本卉始支持稀疏索引:不再需要完整克隆 crates.io-index 仓库，可以加快获取包的速度<br>协议推荐使用 git，但对于 htps 和 git 协议，一般各镜像源都支持，并且是可以互换的。如果你所处的环境中不允许使用git 协议，或者配置 git 协议后不能正常获取和编译 crate，可以换 https 协议再试试有两种方式可以实现:增加新的镜像地址和覆盖默认的镜像地址。</p>
<h2 id="两者相同，选择一种方式即可"><a href="#两者相同，选择一种方式即可" class="headerlink" title="两者相同，选择一种方式即可"></a>两者相同，选择一种方式即可</h2><h3 id="https的"><a href="#https的" class="headerlink" title="https的"></a>https的</h3><p>[registries]ustc &#x3D;{index&#x3D;”<a target="_blank" rel="noopener" href="https://mirrors.ustc.edu.cn/crates.io-index/%22%7D">https://mirrors.ustc.edu.cn/crates.io-index/&quot;}</a><br>[registries.ustc]index &#x3D;”<a target="_blank" rel="noopener" href="https://mirrors.ustc.edu.cn/crates.io-index/">https://mirrors.ustc.edu.cn/crates.io-index/</a>“</p>
<h3 id="git的"><a href="#git的" class="headerlink" title="git的"></a>git的</h3><p>[registries]ustc &#x3D;{index&#x3D;”git:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;crates.io-index” }<br>[registries.ustc]index&#x3D;”git:&#x2F;nirrors.ustc.edu.cn&#x2F;crates.io-index”</p>
<h2 id="如果支持稀疏索引的话。两者相同，选择一种方式即可"><a href="#如果支持稀疏索引的话。两者相同，选择一种方式即可" class="headerlink" title="如果支持稀疏索引的话。两者相同，选择一种方式即可"></a>如果支持稀疏索引的话。两者相同，选择一种方式即可</h2><h3 id="https的-1"><a href="#https的-1" class="headerlink" title="https的"></a>https的</h3><p>[registries]<br>ustc &#x3D;{ index&#x3D;”sparse+<a target="_blank" rel="noopener" href="https://mirrors.ustc.edu.cn/crates.io-index/%22%7D[registries.ustc]index=%22sparse+https://mirrors.ustc.edu.cn/crates.io-index/">https://mirrors.ustc.edu.cn/crates.io-index/&quot;}[registries.ustc]index=&quot;sparse+https://mirrors.ustc.edu.cn/crates.io-index/</a>“</p>
<h3 id="git的-1"><a href="#git的-1" class="headerlink" title="git的"></a>git的</h3><p>[registries]<br>ustc &#x3D;{ index&#x3D;”sparse+git:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;crates.io-index” }<br>[registries.ustc]<br>index&#x3D;”sparse+git:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;crates.io-index”</p>
<h2 id="覆盖默认的镜像地址"><a href="#覆盖默认的镜像地址" class="headerlink" title="覆盖默认的镜像地址"></a>覆盖默认的镜像地址</h2><p>而第二种方式，则不需要修改 Cargo.toml 文件，因为它是直接使用新注册服务来替代默认的 crates.io 。在 $HOME&#x2F;.cargo&#x2F;config.toml 添加以下内容:<br>[source.crates-io]replace-with &#x3D;’ustc!’<br>[source.ustc]registry &#x3D;”git:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;crates.io-index”<br>首先，创建一个新的镜像源【source.ustc)，然后将默认的crates-10 替换成新的镜像源:replace-with&#x3D;’ustc’</p>
<h2 id="可用的镜像列表"><a href="#可用的镜像列表" class="headerlink" title="可用的镜像列表"></a>可用的镜像列表</h2><p>#中国科学技术大学”<a target="_blank" rel="noopener" href="https://mirrors.ustc.edu.cn/crates.io-index'%22git://mirrors.ustc.edu.cn/crates.i0-index">https://mirrors.ustc.edu.cn/crates.io-index&#39;&quot;git://mirrors.ustc.edu.cn/crates.i0-index</a>“<br>#上海交通大学”<a target="_blank" rel="noopener" href="https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index/">https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index/</a>“<br>#清华大学”<a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git">https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git</a>“<br>#字节跳动”<a target="_blank" rel="noopener" href="https://rsproxy.cn/crates.io-index">https://rsproxy.cn/crates.io-index</a>“</p>
<h2 id="Cargo小结"><a href="#Cargo小结" class="headerlink" title="Cargo小结"></a>Cargo小结</h2><p>对于简单项目，Cargo并不比rustc提供了更多的优势，不过随着开发的深入，终将证明其价值。一旦程序壮大到由多个文件组成，亦或者是需要其他的依赖，让 Cargo 协调构建过程就会简单得多。<br>我们回顾下已学习的 Cargo 内容:<br>。可以使用 cargo new 创建项目<br>。Cargo 期望源文件放在 src 目录中<br>。项目根目录只存放 README、license 信息、配置文件和其他跟代码无关的文件<br>。使用 Cargo 帮助你保持项目干净整洁，一切井井有条。可以使用 cargo build 构建项目<br>。cargo build-release 构建最终用户程序，编译时间更长。可以使用 cargo run 一步构建并运行项目<br>。大多数开发者开发者的选择</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>rust是一个类型安全 静态编译的语言。rust官网拥有丰富的学习资料。</li>
<li>使用rustup来管理rust版本和相关工具的命令行(cargo rustc..)</li>
<li>vscode 推荐插件rust-analyzer even-better-toml crates</li>
<li>rustc是rust的编译器，</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives%7C%7C%20archive">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">One Byte</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
